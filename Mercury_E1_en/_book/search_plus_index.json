{"./":{"url":"./","title":"Introduction","keywords":"","body":"myCobot Pro 450 The first choice for getting started with the full harmonic collaborative robot arm Core Document This document contains comprehensive information from product introduction, detailed technical parameters to user instructions and product development guidance. The document will introduce the basic functions of the myCobot Pro 450 robot arm in depth, provide software development guidelines, and show successful application cases to help you understand how to effectively integrate myCobot Pro 450 into various applications. In addition, we also provide a wealth of support and service information to ensure that you can get the necessary help when you encounter any technical challenges. Document Description Depending on your needs and your level of expertise in myCobot Pro 450 application development, you can choose to follow this order from beginning to end or use it as a standalone reference. You can always use the sidebar navigation on the left to jump to any part of this document. The full text is divided into the following five sections: Product Information The product information section will provide you with a basic overview of the robot arm, including detailed technical specifications such as main functions, product parameters and electrical characteristics, to help you quickly understand the basic characteristics and usage environment of the product. In addition, this section will detail the application examples and supported extended development of the product, providing you with the necessary development guides and resources. At the end of the article, relevant purchase links and channels will be provided for your convenience. Basic Settings This section is an important section that every user of this product must read carefully. It covers key information about the use, transportation, storage and maintenance of the product, aiming to ensure the safety and efficiency of users when operating the product. In addition, this section also details the division of responsibilities for product failure or damage that may occur due to failure to follow these guidelines. Functions and Applications The Functions and Applications section details the basic functions of the robotic arm and how to use the software, including instructions for using myBlockly and system and firmware updates. The Software Development Guide provides guidance based on different development environments, such as Python and ROS, to support technical developers in expanding their applications. By showcasing successful application cases and providing supporting resources, we provide practical references and essential support materials for a deeper understanding and use of the product. Support and Services The Support and Services section will provide you with comprehensive troubleshooting guides and post-purchase service information, such as warranty and service terms, to help you quickly resolve problems when you encounter them, and ensure that you understand your rights and obligations after purchase. In addition, the 'About Us' section reinforces the user's understanding of the myCobot series product design and manufacturer, aiming to build trust and brand loyalty. Acknowledgements We appreciate your taking the time to read the myCobot Pro 450 User Manual. We hope that this document will help you better understand and effectively use this robot, thereby inspiring your creativity. If you have any questions or need further assistance, please feel free to contact our customer support team. We look forward to seeing the innovative projects you complete with myCobot Pro 450 and welcome you to join our fast-growing developer community. Document Directory "},"1-ProductInformation/1.ProductIntroduction/1-ProductIntroduction.html":{"url":"1-ProductInformation/1.ProductIntroduction/1-ProductIntroduction.html","title":"1. IntroductionProduct ","keywords":"","body":"Product Introduction 1. Product Description myCobot Pro 450 The first choice for getting started with the full harmonic collaborative robot arm 1.1 Product Introduction The myCobot Pro 450 is a compact, fully harmonic, six-axis collaborative robot arm designed for use in education, scientific experiments, commercial demonstrations, and light industrial automation. It boasts a wide range of core functions and precise manipulation capabilities, including a working radius of up to 450 mm, a payload capacity of 1 kg, and positioning repeatability up to ±0.1 mm. It excels at a wide range of light-load, high-precision tasks. In terms of control, it relies on a built-in industrial-grade core control board and self-developed control system, which can be easily connected to terminal devices such as computers, tablets, and mobile phones. The pre-installed drag-and-drop programming software and quick debugging interface make it easy for users with no basic knowledge to get started. At the same time, the integrated interface design on the tool side eliminates the trouble of cables when connecting the grippers, and the newly added CAN and RS485 interfaces on the base provide ample space for secondary development and function expansion. Its core value lies in providing users in different fields with a high-performance, easy-to-use and highly scalable collaborative robot arm solution, helping to improve work efficiency and innovation capabilities. 1.2 Design Concept The myCobot Pro 450 was designed to meet the growing demand for diverse applications. In education, it aims to help students more intuitively engage with and learn robotics, cultivating practical skills and innovative thinking. In scientific research, it aims to provide researchers with stable and precise experimental tools, accelerating their research progress. In commercial displays, it aims to create engaging interactive experiences and enhance presentations. 1.3 Design Goals Design goals description Application scenarios and features Meet diverse high-precision operation needs The 450mm working radius covers a standard tabletop, the 1kg payload supports multiple end effectors, and the repeatability accuracy is controlled to ±0.1mm. - Educational and scientific research scenarios: can be used for experimental data collection, and its high precision can ensure the accuracy and reliability of the data；- Light industrial automation scenarios: It can perform fine material processing, such as the installation and sorting of electronic components, to improve production efficiency and product quality. Lowering usage thresholds and technical barriers Multi-terminal connection, pre-installed drag-and-drop programming software, 4 industrial-grade connections and multi-standard protocols, easy to use even with zero basic knowledge. - Educational teaching scenario: Students can easily connect and operate the robotic arm through terminal devices, learn robot programming knowledge with the help of programming software, and improve practical skills；- Business scenarios: Enterprise personnel can use this robotic arm to conduct preliminary research and verification of solutions without complex technical training, reducing the cost of using technology. Promote innovative application and expansion It integrates multimodal and embodied intelligent large models, features visual and voice control, provides four out-of-the-box solutions, and supports secondary development through its interfaces. - Research scenarios: Researchers can conduct cutting-edge research on robot intelligent decision-making, autonomous motion strategies, and other topics based on large models and embodied intelligence capabilities.；- Commercial display scenarios: Leverage multimodal interaction and unique application solutions to create a novel interactive display experience, attract customer attention, and enhance brand image. 1.4 Feature Features Feature description Ultra-long standby Laboratory-verified lifespan > 10,000 hours (Note: actual operating conditions may affect this), long-lasting stability, making teaching and research less stressful. Commercial-grade safety joints The integrated harmonic reducer + servo motor + joint brake + controller self-locks upon power failure, ensuring safety and reliability, and greater peace of mind for human-machine collaboration. Integrated precision, solid and reliable The all-metal integrated high-temperature die-cast body has uniform structural strength and a built-in controller, eliminating the need for external electrical boxes and complex cables, making it simple and efficient. The Internet of Things Support for four industrial-grade connections (WLAN/EtherNet/RS485/CAN) and a variety of protocols (Socket-TCP/Modbus/CANOpen) allows for easy integration into existing systems and worry-free Industry 4.0 integration. Precise and efficient, lightweight choice Working radius: 450mm, load: 1kg, accuracy: ±0.1mm, weight: Zero threshold control myCobot Pro cross-platform control center - connect directly from your browser (just enter the IP address), no installation required! Integrated: Blockly graphical programming & drag-to-teach: turn novice programmers into programming experts in seconds. Fast mobile control & status monitoring. Supports multiple connection configurations including Modbus, VNC, and Socket. One-stop firmware upgrades and management. Open source ecosystem, unlimited possibilities Provides a complete URDF model and exposes low-level interfaces for joint motors (including queryable position, velocity, acceleration, and current), facilitating kinematic and dynamic simulation modeling (ROS2, Isaac Sim, and MuJoCo). Over 90 standard control interface libraries (Python and C++) are available, covering status query and joint and Cartesian motion control. This is developer-friendly and efficiently enables secondary development. Infusion of \"soul\" into large models Supports integration with large multimodal models (such as DeepSeek and ChatGPT) to enable intelligent grasping using voice commands and visual recognition, making interaction more intuitive. Supports integration with large embodied intelligence models (such as Lerobot) to enable autonomous motion strategy learning and deployment, exploring the frontiers of intelligent agents. Cool App Suite Provides three out-of-the-box solutions: 3D visual disordered sorting, high-precision writing and painting, and mobile composite robots, allowing you to quickly build teaching/experimental/display scenarios. 2. Product Application 2.1 Client Educators and students It is suitable for course teaching, experimental training and skills competitions in robotics engineering, artificial intelligence, automation control, mechatronics and other majors in colleges and vocational schools, providing teachers and students with an ideal platform from theory to practice. Researchers and developers It provides a stable hardware platform and deep software open interfaces for scientific research institutes, corporate R&D departments and a large number of robotics enthusiasts to assist in algorithm verification, prototype development and cutting-edge technology exploration. Commercial and industrial users It is suitable for interactive product display in commercial showrooms, small-batch precision production in light industrial environments, sample sorting, quality inspection and other tasks, providing efficient and reliable automation solutions. 2.2 Application Scenario user group Core application scenarios (out-of-the-box) Expand application scenarios (unlimited possibilities) Teachers and students in the field of education - Basic teaching of robotics: mechanical structure, kinematics, and trajectory planning principle experiments.- Drag-and-drop programming: manual craftsmanship imitation, action recording and reproduction.- Introduction to graphical programming: Use Blockly for basic training in logical thinking and programming. - Advanced algorithm development: Research on machine vision, path planning, force control and other algorithms based on Python/C++/ROS2.- Artificial intelligence integration: Develop AI comprehensive application projects such as voice control and intelligent visual recognition and grasping. Makers and technology developers - Rapid Prototyping (PoC): Verify the feasibility of automated processes or gripping solutions.- High-precision simulation: Provides accurate URDF models and seamlessly integrates with simulation environments such as Isaac Sim and MuJoCo. - Exploration of cutting-edge fields: As a physical platform, it is used for research on cutting-edge topics such as embodied intelligence, reinforcement learning, and human-machine collaboration.- Composite system development: Integrate with AGV/AMR mobile chassis to build mobile manipulation robots. Commercial demonstrations and light industry - Automated commercial display: 24/7 automated product display and fun interaction with the audience.- Precision operations: high-precision writing and drawing, circuit board point detection, and sample sorting.- 3D visual sorting: Combined with 3D cameras, it can realize the grasping and sorting of disordered workpieces in cluttered environments. - Production line automation integration: Communicate with PLCs via Modbus/TCP/IP and other protocols, and integrate into small production lines to perform tasks such as loading and unloading, and precision assembly.- Laboratory automation: Replace manual labor to perform repetitive experimental operations, such as sample pipetting and culture dish transportation. 3. Supported Extension Development The mycobot series of robotic arms are extremely valuable in the fields of education and scientific research, especially in Python and ROS (Robot Operating System), two widely used development environments. These environments provide strong support, allowing the mycobot series of products to be widely used in machine learning, artificial intelligence research, complex motion control, and visual processing tasks. At the same time, with dozens of accessories such as adaptive grippers, camera flanges, suction pumps, etc., you can give full play to myCobot's creative ideas. Python The robot supports Python and has a complete Python API library. The robot's joint angles, coordinates, grippers, etc. can be controlled through Python. ROS It supports both ROS1 and ROS2 versions and provides RVIZ simulation environment support. It allows users to display the robotic arm and collect its status information in real time, making the myCobot Pro 450 suitable for ROS beginners and educational purposes. Hardware interface Including IO, USB, etc., to facilitate the connection of various sensors and actuators. Software library Provides a wealth of open source libraries and APIs to simplify the development process. System compatibility Compatible with Windows, Linux, MacOS, and adaptable to a variety of development environments. C++ Using the C++ language, you can freely develop (coordinate control, angle control, IO control, gripper control, etc.) through the C++ dynamic library developed by our company, and control some robots that our company has developed. myStudio Pro This is a one-stop software for robot programming and control, supporting visual programming interaction, quick motion control, drag-and-drop teaching, and robot status inquiry and configuration. It includes the myBlockly module within myStudio Pro. 4. Purchase Address If you are interested in purchasing this device, please click on the link below Taobao：https://shop504055678.taobao.comShopify：https://shop.elephantrobotics.com/AliExpress：https://elephantrobotics.aliexpress.com/store/1101941423 ← Previous Chapter | Next Chapter→ "},"1-ProductInformation/2.ProductParameter/2-ProductParameters.html":{"url":"1-ProductInformation/2.ProductParameter/2-ProductParameters.html","title":"2. ProductParameters","keywords":"","body":"Robot Parameters In the first chapter, we discussed the selling points of the product and its design concept, providing you with a panoramic perspective of the high-level understanding of the product. Now, let's move on to the second chapter - Robot Parameters. This chapter will be the key to your understanding of the product's technical details. A detailed understanding of these technical parameters will not only help you fully realize the advancement and practicality of our products, but also ensure that you can use these technologies more effectively to meet your specific needs. 1. Robot Specifications Index Parameters Name Full harmonic collaborative robotic arm Model myCobot Pro 450 Degrees of Freedom 6 Payload 1 Kg Working Radius 450mm Repeatability ±0.1mm Weight Power Input 24V，9.2A Operating Temperature 0-45℃ Communication TCP/IP-SocketMODBUSEthernet IP 2. Structural Dimension Parameters ！This chapter uses millimeters as distance units and degrees as angle units. 2.1 Product Dimensions And Working Space 2.2 Joint Range Of Motion Hardware joint range of motion Joints Range J1 -169 ~ +169 J2 -131 ~ +131 J3 -159 ~ +159 J4 -167 ~ +167 J5 -168 ~ +168 J6 -168 ~ +168 Software joint range of motion Joints Range 1 -162 ~ 162 2 -125 ~ 125 3 -154 ~ 154 4 -162 ~ 162 5 -162 ~ 162 6 -165 ~ 165 2.3 Hole Installation The robot base is mounted with flanges. The base is compatible with both LEGO technology and M4 screw installation. The robot end is equipped with a flange, and the end of the robotic arm is compatible with both LEGO technology holes and screw thread holes. 3. Electrical Characteristic Parameters 3.1 Electrical Interface Of The Robotic Arm Base 3.1.1 Base Introduction Base front view： ① RJ45：Dual network ports, used for connecting the device to the Internet or other network devices. ② USB3：High-speed USB interface for connecting to computers or peripheral devices. ③ RS485：Industrial serial communication, connecting PLC, sensors, etc. ④ CAN：CAN bus communication, connecting drives, I/O modules, etc. ⑤ Function IO: digital signal input/output. ⑥ Power switch: Press and hold to turn on the power, press and hold again to turn off the power. ⑦ DC24V power supply: Connect the power adapter. ⑧ Emergency stop interface: Connect an external emergency stop button to cut off the power supply in an emergency to ensure safety. 3.1.2 Base Interface Description The definition of each interface is shown in the following table: Label Signal Name Type Function 2 1-12 I/O 24V 3.2 Electrical Interface At The End Of The Robotic Arm 3.2.1 Introduction To The End Of The Robotic Arm Side View Of The End Of The Robotic Arm: Number Interface Definition Function 12 M8 aviation socket End-of-line tool IO interface 24V/2A output, supports short-circuit, reverse polarity, lightning strike, overcurrent, and overvoltage protection M8 aviation socket RS485 interface Supports configurable baud rates of 9600 and 115200 3.2.2 Robotic Arm End Interface Description The definition of each interface is shown in the following table: The definitions of the various tool I/O ports are shown in the table below. Note that the tool I/O output is PNP type and the input is NPN type. The wiring method is the same as the bottom output interface. Number Signal Explanation Matching M8 line color 1 GND DC24V negative pole white 2 OUT1 Tool output interface 1 brown 3 OUT2 Tool output interface 2 green 4 485A 485 standard interface A yellow 5 24V DC24V positive pole gray 6 IN1 Tool input interface 1 pink 7 IN2 Tool input interface 2 blue 8 485B 485 standard interface B purple 4. Cartesian Coordinate Parameters ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/":{"url":"2-BasicSettings/3.UserNotice/","title":"3. UserNotice","keywords":"","body":"User Notes This section is crucial for every user of this product and must be read carefully. It includes essential information on product use, transportation, storage, and maintenance to ensure safety and efficiency during operation. Additionally, it outlines liability for product failure or damage resulting from non-compliance with these guidelines. The User Notice is divided into subsections, each providing detailed guidance on different topics: Chapter Summary 3.1-Safety Information Includes liability, safety warning signs, general safety rules, personal safety, and emergency response. 3.2-Transportation and Storage Describes packaging, transport, and long-term storage requirements, along with liability. 3.3-Maintenance and Care Offers guidance on routine maintenance to extend product lifespan. 3.4-FAQs and Solutions Provides a navigable guide for quickly resolving common issues. By thoroughly reading this section, users will better understand how to use the product safely and efficiently, maximizing performance and lifespan. If you have already read all the content in this chapter, please proceed to the next chapter. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.1-SafetyInstruction.html":{"url":"2-BasicSettings/3.UserNotice/3.1-SafetyInstruction.html","title":"3.1 SafetyInstruction","keywords":"","body":"Safety Instructions 1. Introduction This chapter details general safety information for personnel who perform installation, maintenance and repair work on the Elephant Robot. Please fully read and understand the contents and precautions of this chapter before handling, installing and using it. 2. Hazard Identification The safety of collaborative robots is based on the premise of correctly configuring and using the robots. Moreover, even if all safety instructions are followed, injuries or damage to the operator may still occur. Therefore, it is very important to understand the safety hazards of robot use, which is conducive to preventing them before they happen. Tables 1-1 to 3 below are common safety hazards that may exist when using robots: Table 1-1 Dangerous safety hazards 1 Personal injury or robot damage caused by incorrect operation during robot handling. 2 Failure to fix the robot as required, such as lack of screws or screws not tightened, insufficient base locking capacity to stably support the robot for high-speed movement, etc., causing the robot to fall over, resulting in personal injury or robot damage. 3 Failure to correctly configure the robot's safety functions, or insufficient installation of safety protection tools, etc., causing the robot's safety functions to fail to function, thus causing danger. Table 1-2 Warning-level safety hazards 1 Do not stay in the robot's motion range when debugging the program. Improper safety configuration may not be able to avoid collisions that may cause personal injury. 2 The connection between the robot and other equipment may cause new hazards, and a comprehensive risk assessment needs to be re-performed. 3 Scratches and punctures caused by sharp surfaces such as other equipment or the robot's end effector in the working environment. 4 The robot is a precision machine and trampling may cause damage to the robot. 5 Failure to clamp in place or not removing the clamped object before turning off the robot's power or air source (not confirming whether the end effector is secure and the clamped object falls due to power loss) may cause dangers, such as damage to the end effector and injuries to people. 6 The robot may move unexpectedly. Do not stand under any axis of the robot under any circumstances! 7 The robot is a precision machine. If it is not placed stably during transportation, it may cause vibration, which may cause damage to the robot's internal components. 8 Compared with ordinary mechanical equipment, the robot has more degrees of freedom and a larger range of motion. Failure to meet the range of motion may cause unexpected collisions. Table 1-3 Safety hazards that may cause electric shock 1 Using non-original cables may cause unknown dangers. 2 Electrical equipment in contact with liquid may cause leakage. 3 There may be a risk of electric shock when the electrical connection is incorrect. 4 Always turn off the power of the controller and related devices and unplug the power plug before replacing. If the work is carried out in the power-on state, it may cause electric shock or malfunction. 3. Safety Precautions The following safety rules should be followed when using the robot arm: The robot arm is a live device. Non-professionals are not allowed to change the circuit at will, otherwise it is easy to cause damage to the equipment or personal injury. When operating the robot arm, local laws and regulations should be strictly observed. The safety precautions and \"Danger\", \"Warning\" and \"Caution\" items described in the manual are only used as supplements to local safety regulations. Please use the robot arm within the specified environmental range. Exceeding the robot arm specifications and load conditions will shorten the product life or even damage the equipment. Personnel responsible for installing, operating and maintaining the myCobot robot arm must first undergo rigorous training, understand various safety precautions, and master the correct operation and maintenance methods before operating and maintaining the robot. Do not use this product in a humid environment for a long time. This product is a precision electronic component. Long-term operation in a humid environment will damage the device. Do not use this device in a high temperature environment. The outer surface of this device is made of photosensitive resin as raw material. Higher temperatures will damage the outer shell of the device and cause equipment failure. Highly corrosive cleaning is not suitable for cleaning the robot arm, and anodized parts are not suitable for immersion cleaning. Do not use this product without a base installed to avoid damage to the device or accidents. This product should be used in a fixed environment with no obstacles around. Do not use other power adapters for power supply. If the device is damaged due to the use of an adapter that does not meet the standards, it will not be covered by after-sales service. Do not disassemble, disassemble, or unscrew the screws or casing of the robot arm. If disassembled, warranty service cannot be provided. Personnel who have not received professional training are not allowed to repair faulty products or disassemble the robot arm without authorization. If the product fails, please contact myCobot technical support engineers in time. If the product is scrapped, please comply with relevant laws to properly dispose of industrial waste and protect the environment. Children must be monitored by someone during use, and the device must be turned off in time when the operation is completed. When the robot is in motion, do not put your hand into the range of motion of the robot arm to avoid injury. It is strictly forbidden to change or remove and modify the nameplate, instructions, icons and markings of the robot arm and related equipment. Please be careful during transportation and installation. Please place the robot gently and correctly in the direction of the arrow according to the instructions on the packaging box, otherwise it is easy to damage the machine. Do not burn other product drivers without authorization, or use unofficial recommended methods to burn firmware. If the device is damaged due to the user's personal burning of other firmware, it will not be covered by after-sales service. If you have any questions or suggestions about the contents of this manual, please log in to the official website of Elephant Robotics to submit relevant information: https://www.elephantrobotics.com Do not use the robot arm for the following purposes: Medical and life-critical applications. In an environment that may cause an explosion. Direct use without risk assessment. Use with insufficient safety function level. Use that does not meet the robot performance parameters. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.2-TransportandStorage.html":{"url":"2-BasicSettings/3.UserNotice/3.2-TransportandStorage.html","title":"3.2 TransportandStorage","keywords":"","body":"Transportation And Storage Packing And Packaging   When packing and packaging the robot product, please make sure to use packaging materials and boxes designed for it. These materials can provide sufficient cushioning and support to prevent impact and vibration during transportation. Be sure to check that all parts are properly fixed to avoid looseness and damage. For fragile or sensitive parts, additional anti-vibration protection materials should be used for reinforcement. Finally, make sure that the outside of the packaging box is marked with clear handling and warning labels to indicate the correct handling method and storage direction. Logistics And Transportation   During transportation, the robot product should be transported in the original packaging. During transportation, it should be ensured that the robot product is stable as a whole in the packaging box and protected by appropriate measures. During transportation and long-term storage, the ambient temperature should be maintained in the range of -20 to +55°C, and the humidity should be ≤95% without condensation.   Because the robot is a precision machine, the robot product should be handled with care when it is removed from the packaging. During transportation, if it is not placed stably, it may cause vibration and damage the internal parts of the robot. Equipment Storage   After transportation, the original packaging should be properly stored in a dry place, the ambient temperature should be kept within the range of -20 to +55°C, the humidity should be ≤95% and there should be no condensation, in preparation for future repackaging and transportation needs. Do not stack other items on the original packaging box of the robot arm to prevent deformation of the packaging box and damage to the robot arm. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.3-MaintenanceandCare.html":{"url":"2-BasicSettings/3.UserNotice/3.3-MaintenanceandCare.html","title":"3.3 MaintenanceandCare","keywords":"","body":"Maintenance And Care As a robot manufacturer, we value ensuring that our customers can properly and safely maintain and upgrade their robot equipment. To this end, we provide the following detailed maintenance and care guide, including common maintenance items and parts for repairing or upgrading hardware. Please read carefully: 1. Common Maintenance Items And Recommended Cycles Maintenance items Description Recommended cycle Visual inspection Inspect the robot for obvious damage, foreign material accumulation or wear. Daily Structural cleaning Clean the robot structural parts with a clean, dry cloth. Avoid moisture and aggressive cleaning agents. Daily Fastener inspection Inspect and tighten all bolts and connectors. Daily Lubrication Lubricate joints and moving parts with the lubricant recommended by the manufacturer. Every 3 months Cable and wiring inspection Inspect the cables and wiring to ensure that there is no damage or wear. Monthly Electrical connection check Ensure that all electrical connections are secure and free of corrosion or damage. Monthly Software update Check and update the control software and application. Every update Software data backup Regularly back up key software configuration and data. Quarterly Firmware update Regularly check and update the firmware to obtain the latest features and security patches. Every update Sensor and device check Check sensors and other key devices to ensure normal operation. Monthly Emergency stop function test Regularly test the emergency stop function to ensure its reliability. Monthly Environmental condition monitoring Monitor the temperature, humidity, dust, etc. of the working environment to ensure that it meets the operating specifications of the robot. Continuous monitoring Safety configuration review Regularly check and confirm the safety configuration of the robot, such as speed limit and working range settings. Monthly Preventive maintenance plan execution Perform regular inspections and maintenance according to the manufacturer's maintenance plan. By Manufacturer's Guide 2. Guide To Independently Changing Robot Hardware We understand that customers may have the need to upgrade or repair robot hardware by themselves. Before performing any upgrade operations, please be sure to read the relevant parameters of the product in detail and confirm with our official personnel whether such operations are allowed. Operations without official permission may cause product failure and are not covered by the warranty. Material Requirements Officially manufactured or recommended materials: All accessories and components required for repairs and upgrades must be officially manufactured or explicitly recommended by us. This includes but is not limited to electronic components, sensors, motors, connectors, and any other replaceable parts. Material Acquisition: Customers can purchase the required repair and upgrade materials through our official channels. This ensures the quality and compatibility of the accessories. Repair or Upgrade Process Customer Self-Repair: Customers are responsible for completing the repair work. We will provide detailed repair instructions and manuals to guide customers through the repair steps. Follow official instructions: Repair operations should strictly follow the official instructions provided by us. Any deviation from the official instructions may cause damage to the equipment. Liability and Warranty Policy Division of Responsibilities: Manufacturer: Provide official instructions for repairs and upgrades, officially manufactured or recommended materials, and handle problems caused by manufacturing defects. Customer: Responsible for completing repairs in accordance with official instructions and using official accessories. Warranty Policy: Warranty Valid: Warranty is valid only if the repair operation fully follows our instructions and uses official accessories. Warranty Void: If the customer does not follow the official instructions or uses unofficial accessories for repairs or upgrades, any damage caused will not be covered by the warranty. Notes Safety First: Before performing any repair or upgrade operations, please make sure to follow all safety guidelines, including powering off and using appropriate protective equipment. Technical Support: If you encounter problems during the repair process, it is recommended to stop the operation and contact our technical support team for assistance. We strongly recommend that customers strictly follow these guidelines to ensure the safe and effective operation of the robot equipment. Improper repair operations may cause damage to the equipment and affect the warranty status. For further guidance or support, please contact our professional technical team in a timely manner. If you have read all of this chapter, please continue to the next chapter. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.4-FAQs.html":{"url":"2-BasicSettings/3.UserNotice/3.4-FAQs.html","title":"3.4 FAQs","keywords":"","body":"FAQ This section lists some frequently asked questions, covering both hardware and software aspects. 1 software problem 2 Hardware problem 3 other ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.4.1-software.html":{"url":"2-BasicSettings/3.UserNotice/3.4.1-software.html","title":"3.4.1 Software","keywords":"","body":"Software Issues 1. ROS1 Related 1.1 Environment-Related Issues Issue 1: Running roslaunch results in the error package 'mycobot_pro_450' not found Cause: The ROS workspace was not compiled correctly or the environment variables were not loaded Solution:cd ~/catkin_ws catkin_make source devel/setup.bash 1.2 Network Communication Issues Issue 1: Error: \"Trying to connect to real MyCobot Pro450... Timeout\" Cause: The PC and robot are not on the same network segment, or the IP address is incorrectly set Solution: Confirm that the robot's default IP address is 192.168.0.232 Set the PC network card to the same network segment, for example, 192.168.0.100 Test connectivity: ping 192.168.0.232 1.3 Python API/Library Issues Issue 1: Runtime Error ModuleNotFoundError: No module named 'pymycobot' Cause: pymycobot is not installed in the Python environment Solution: pip3 install pymycobot Issue 2: Runtime Error ImportError: cannot import name 'Pro450Client' from 'pymycobot' Cause: pymycobot version is too low Solution: pip install -U pymycobot Issue 3: Runtime Error RuntimeError: The version of the pymycobot library must be greater than 3.9.9 or higher. The current version is 3.9.7. Please upgrade the library version. Cause: Pymycobot version is too low Solution: pip install -U pymycobot Note: Version must be greater than 4.0.0 1.4 ROS Node Operation Issues Problem 1: Model not displayed after opening in rviz Cause 1: robot_description not loaded correctly Solution: Check that the roslaunch command is complete In the terminal, enter: rosparam list | grep robot_description If you see the /robot_description parameter, the model has been loaded. Please check that the joint_state_publisher and robot_state_publisher are running properly. Use the rostopic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Problem 2: After opening rviz, the model is incomplete, and the terminal continuously outputs a warning message similar to: Warning [Invalid frame ID \"base\" passed to canTransform argument target frame frame does not exist rviz] rviz at line 133 in /tmp/binarydeb/ros-foxy-tf2-0.13.13/src/buffer core.cpp Cause 1: Robot communication is abnormal and angle coordinates cannot be read normally. Solution: Is joint_states being published (a message will be printed)? In the terminal, enter: rostopic echo -n 5 /joint_states If /joint_states does not output anything, it is likely that the robot communication or the mycobot service is not receiving data. Please check that joint_state_publisher and robot_state_publisher are running properly. - Use the rostopic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Check the robot's communication status. For details, see Python Exception Handling Check whether the robot can read angles and coordinates normally. from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() != 1: mc.power_on() print(mc.get_angles(), mc.get_coords()) Problem 3: Error message: [WARN]: Coordinate control disabled. Please press '2' first. Solution: First enter 2 on the keyboard control interface to return the robot to its starting point, then resume coordinate control 2. ROS2 Related 2.1 Environment-Related Issues Issue 1: Running ros2 launch results in the error package 'mycobot_pro_450' not found Cause: The ROS workspace was not compiled correctly or the environment variables were not loaded Solution:cd ~/colcon_ws colcon build source install/setup.bash 2.2 Network Communication Issues Issue 1: Error: \"Trying to connect to real MyCobot Pro450... Timeout\" Cause: The PC and robot are not on the same network segment, or the IP address is incorrectly set Solution: Confirm that the robot's default IP address is 192.168.0.232 Set the PC network card to the same network segment, for example, 192.168.0.100 Test connectivity: ping 192.168.0.232 2.3 Python API/Library Issues Issue 1: Runtime Error ModuleNotFoundError: No module named 'pymycobot' Cause: pymycobot is not installed in the Python environment Solution: pip3 install pymycobot Issue 2: Runtime Error ImportError: cannot import name 'Pro450Client' from 'pymycobot' Cause: pymycobot version is too low Solution: pip install -U pymycobot Issue 3: Runtime Error RuntimeError: The version of the pymycobot library must be greater than 3.9.9 or higher. The current version is 3.9.7. Please upgrade the library version. Cause: Pymycobot version is too low Solution: pip install -U pymycobot Note: Version must be greater than 4.0.0 2.4 ROS Node Operation Issues Problem 1: Model not displayed after opening in rviz Cause 1: robot_description not loaded correctly Solution: Check that the ros2 launch command is complete In the terminal, enter: ros2 param list | grep robot_description If you see the /robot_description parameter, the model has been loaded. Please check that the joint_state_publisher and robot_state_publisher are running properly. Use the ros2 topic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Problem 2: After opening rviz, the model is incomplete, and the terminal continuously outputs a warning message similar to: Warning [Invalid frame ID \"base\" passed to canTransform argument target frame frame does not exist rviz2-2] rviz2-2 at line 133 in /tmp/binarydeb/ros-foxy-tf2-0.13.13/src/buffer core.cpp Cause 1: Robot communication is abnormal and angle coordinates cannot be read normally. Solution: Is joint_states being published (a message will be printed)? In the terminal, enter: rostopic echo -n 5 /joint_states If /joint_states does not output anything, it is likely that the robot communication or the mycobot service is not receiving data. Please check that joint_state_publisher and robot_state_publisher are running properly. - Use the ros2 topic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Check the robot's communication status. For details, see Python Exception Handling Check whether the robot can read angles and coordinates normally. from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() != 1: mc.power_on() print(mc.get_angles(), mc.get_coords()) Problem 3: Error message: [WARN]: Coordinate control disabled. Please press '2' first. Solution: First enter 2 on the keyboard control interface to return the robot to its starting point, then resume coordinate control ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.4.2-hardware.html":{"url":"2-BasicSettings/3.UserNotice/3.4.2-hardware.html","title":"3.4.2 Hardware","keywords":"","body":"Hardware Issues Under preparation ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/3.UserNotice/3.4.3-other.html":{"url":"2-BasicSettings/3.UserNotice/3.4.3-other.html","title":"3.4.3 Other","keywords":"","body":"Other Issue Q1: Where is the download path for the urdf file? A1: Please refer to the following path. The urdf of all mycobot models is in this path: https://github.com/elephantrobotics/mycobot_ros/tree/noetic/mycobot_description/urdf Q2: What is the base coordinate system of the mycobot pro 450 robot? Q3: Are the joints of 450 controlled by the serial bus? A3: Yes Q4: Is there more explanation about the understanding of coordinates? A4: The API for controlling coordinate movement is send_coords([x,y,z,rx,ry,rz], speed) x, y, z coordinates: Control the position of the end effector of the robot in space. Changing these coordinate values ​​will move the robot to different spatial positions, thereby achieving positioning in three-dimensional space. rx, ry, rz attitude angles: Control the attitude or orientation of the end effector of the robot. These values ​​are usually given in the form of Euler angles, describing the rotation of the end effector of the robot relative to the base coordinate system, and the order of Euler angles is zyx. Changing these values ​​will rotate the end effector of the robot to different angles or directions. For example: When you adjust +X, this means that the position of the end effector of the current robot arm moves a certain distance along the positive direction of the X axis of the current end effector. This action will cause the robot to move in a certain direction as a whole. And when you adjust RX, this means that the attitude of the end effector of the current robot arm rotates a certain angle around the X axis of the current end effector. This action will cause the robot to rotate as a whole and the direction of the end effector will change. In general, the adjustment of +X and RX will directly affect the motion state of the robot arm. +X controls the movement of the position, while RX controls the change of attitude. If you want to see the changes more intuitively, we recommend that you use myblockly's serial control tool to adjust a parameter at a time and observe its changes in the coordinate system. Please note that when observing rx, ry, and rz, if you want to be more intuitive, please pay attention to adjusting x and ry when the J1 joint is 0, and adjusting y and rx when the joint is 90. You can refer to the coordinate system diagram below: Q5: Is there more explanation about the Offset of the DH parameter? Is the Offset rotated around z? A5: The DH parameter describes the geometric and kinematic relationship between adjacent links in the robot arm. In the DH parameter table, the Offset parameter indicates the effect of the previous link rotating around its z-axis on the position of the next link, that is, the offset when connecting two links. For the Offset parameter in the robot arm, it generally indicates the effect of the previous link rotating around its own z-axis on the position of the next link, rather than rotating around the z-axis of the next link. Therefore, Offset is not a rotation around z, but a displacement when connecting two links. Q6: What is the voltage range of the 450 robot arm power supply? How much is the instantaneous current? A6: 24V ，9.2A Q7: If the servos of each axis are controlled and feedback is obtained, what is the shortest communication cycle? A7: This needs to be determined according to the speed. The minimum response time is 50ms Q8: Does the mycobot series machine have collision detection? A8: 450 has algorithmic collision self-interference, which has been integrated into the API for setting joint angles and coordinates Q9: How to deal with the VNC dragging jam? A9: If the jam is caused by dragging any window in VNC, you can make some configurations according to the picture below. The options need to be consistent with the picture below. After successful setting, the problem of VNC disconnection caused by dragging the window will be solved. Q10: When replacing the second joint of 450, I found that 4 screws were stripped. How to remove them? A10：Regarding the replacement of joints, the 4 screws do not need to be removed. Please remove the large screw in the middle, then fix the J2 joint body back, and then use force to pull out the entire coupling. I recorded a video for you to refer to for specific operations Q11: Is the joint torque information provided? A11: Our machines only provide the overall information of the entire joint, and do not provide the internal torque, voltage and current of the servo and motor actuator. The overall parameters of the robot arm are disclosed, such as repeatability, power supply voltage, etc. Q12: How do you understand the relationship between the two coordinates in the following figure? A12: If you want to view the transformation relationship between the coordinate system named \"turtle1\" and the coordinate system named \"turtle2\", you can use this command. In layman's terms, when you run this command, it will tell you the position and direction information of an object (\"turtle1\") relative to another object (\"turtle2\"). Just like you can know the position of a city relative to another city on a map Q13: The environment of ROS2 has been accidentally changed. Can I just delete the ROS and reinstall it myself? A13: Regarding the issue of reinstalling ROS, we do not recommend users to reinstall it themselves, because the construction of the ROS environment is relatively complex and prone to errors. If you need to reset the ROS environment, we recommend users to re-write the system image. For specific methods, please refer to Development and Use Based on ROS2 Q14: How to transfer files from the host to the virtual machine A14: Set up a shared folder as shown below to transfer files from the PC to the virtual machine Q15: What is the difference between API and serial port instructions to directly control joints? A15：API provides a simplified and abstract interface to make development more efficient and easy, suitable for rapid development and integration. Serial port commands provide direct, low-level control, suitable for scenarios that require fine-tuning or development of custom functions, but are usually more complex to develop and debug. In general: Using serial port commands to directly control the robot arm is more flexible, but also more complex, requiring a deep understanding of the communication protocol; while using API control is simpler and more convenient, but may be limited by the functions and performance provided by the API. Q16: Windows runs git commands and reports errors A16: This is caused by not installing git. You need to install git first and then use git commands Q17: What is the difference between MDI and JOG? A17: MDI (Manual Data Input) is called the set value direct given operation mode. That is, after the upper controller directly sets the target position, speed, acceleration and deceleration, the axis automatically moves to the target position. MDI is also the most commonly used positioning function in practical applications. JOG moves continuously in a certain direction. Q18: End zero position abnormality A18: After using the adaptive gripper to grip objects for a long time, the gripper and end zero position abnormality will occur, and the gripper needs to be stationary. Q19: What is forward kinematics and inverse kinematics? A19: Forward kinematics refers to solving the position and posture of the robot's end effector (such as the gripper of the robot arm) in Cartesian space when the angles (or displacements) of each joint of the robot are known. It is implemented in the get_coords() API, but the specific algorithm is not public. Inverse kinematics is the opposite of forward kinematics. It refers to solving the angles (or displacements) of each joint of the robot when the position and posture of the robot's end effector in Cartesian space are known. write_coords(), send_coords() ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/4.FirstTimeInstallation/":{"url":"2-BasicSettings/4.FirstTimeInstallation/","title":"4. FirstTimeInstallation","keywords":"","body":"First Installation And Use Thank you for choosing our product Before we begin, we would like to sincerely thank you for choosing our product. We are committed to providing you with an excellent user experience. First time use and problem handling This chapter will introduce in detail the initial use of the product after receiving it, and provide relevant information for solving problems to ensure that you have no worries during use. Jump to each section 4.1 Product Standard List 4.2 Product Unboxing Guide 4.3 Power-on Test Guide ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/4.FirstTimeInstallation/4.1-ProductStandardList.html":{"url":"2-BasicSettings/4.FirstTimeInstallation/4.1-ProductStandardList.html","title":"4.1 ProductStandardList","keywords":"","body":"Product Standard List 1. Product List Image Thank you for choosing the Elephant Robot myCobot 280 M5 robot arm. This chapter is designed to help you easily get started with Elephant Robot products and enjoy every wonderful moment brought by the product. 2. Product Standard List Comparison Table Serial Number Product 1 myCobot Pro 450 Robotic Arm 2 DC 24V Power Adapter 3 AC Power Cord 4 Emergency Stop Switch 5 DVD burner、USB to RS485 adapter [CH343G supports 6Mbps] Shangxin IoT 6 3Pin pluggable terminal blocks *2 7 14-pin pluggable terminal blocks*2 8 Flexible Jaw 9 G-clamp*2 10 Gigabit network cable 2m 11 myGripper F100 12 Dual-ended M8-8pin connector 13 Tool kit * 2 14 Dual-ended USB cable 15 Front mounting flange 16 Side mounting flange 17 M8 molded right-angle pin connector Note: After the packing box arrives, please confirm that the robot packaging is intact. If there is any damage, please contact the logistics company and the supplier in your area in time. After unpacking, please check the actual items in the box according to the item list. ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/4.FirstTimeInstallation/4.2-ProductUnboxingGuide.html":{"url":"2-BasicSettings/4.FirstTimeInstallation/4.2-ProductUnboxingGuide.html","title":"4.2 ProductUnboxingGuide","keywords":"","body":"Product Unpacking Guide 1. Product Unpacking Graphic Guide Why do you need to follow the steps to disassemble the product In this section, we strongly recommend that you follow the specified steps to disassemble the product. This will not only help ensure that the product is not damaged during transportation, but also minimize the risk of unexpected failures. Please read the following graphic guide carefully to ensure the safety of your product during the unpacking process. 1 Check the packaging box for damage. If there is damage or missing accessories, please contact the logistics company and the supplier in your area in time. 2 Open the box and take out the product brochure, sponge packaging cover, myCobot robot arm, matching power supply, flat base and accessory bag. 3 Make sure each step is completed before proceeding to the next step to prevent unnecessary damage or omissions. Note: After taking out the product, please carefully check the appearance of each item. Please check the actual items in the box against the item list. 2. Product Unboxing Video Guide ！Product unboxing video is in production ← Previous Chapter | Next Chapter→ "},"2-BasicSettings/4.FirstTimeInstallation/4.3-PowerOnDetectionGuide.html":{"url":"2-BasicSettings/4.FirstTimeInstallation/4.3-PowerOnDetectionGuide.html","title":"4.3 PowerOnDetectionGuide","keywords":"","body":"Startup Troubleshooting Guide 1. Self-check upon first use. Note: After unpacking, please place the robotic arm horizontally on a table that can support at least three times the weight of the robotic arm. The correct posture of the robotic arm is as follows: 2. Structural installation and fastening During the movement of the robotic arm, if the base of the myCobot is not connected to the tabletop or other supporting surface, it can still cause the myCobot to shake or tip over. Before beginning assembly, please clean your workspace and prepare the necessary tools. Working environment: Place the robot arm on a level surface with a load capacity at least three times greater than the weight of the robot arm itself, and ensure there is sufficient space for installation, operation, maintenance, and repair within the robot arm's working range. Tool list: mycobot pro 450 robot arm main body, product accessories package, product user guide, etc. Place the robotic arm flat on the table and position it facing the edge of the table, then secure it with a G-clamp. 3. The robotic arm is shipped to the user with the base plate already installed. If the user needs to disassemble or replace the base plate, please refer to the following video for instructions: Note: myCobot base screw hole connections The robot must be securely mounted on a sturdy base for proper operation. The base can be either a fixed or mobile type. Please ensure that the mounting base has corresponding threaded holes before proceeding with the installation. Before proceeding with the installation, please confirm the following: The installation environment must meet the requirements specified in the \"Working Environment and Conditions\" table above. The installation location must be no smaller than the robot's working range, and there must be sufficient space for installation, operation, maintenance, and repair. Place the machine base in the appropriate position. The necessary installation tools, such as screws and wrenches, are ready. After confirming the above information, please move the robot to the mounting platform on the base, adjust the robot's position, and align the mounting holes on the robot base with the holes on the mounting platform. Once the holes are aligned, insert the screws and tighten them. Note: When adjusting the robot's position on the mounting base, please avoid directly pushing or pulling the robot on the mounting surface to prevent scratches. When manually moving the robot, please avoid applying external force to fragile parts of the robot body to prevent unnecessary damage. Power connections can only be made after the structural installation is complete. 3. External cable connections Required tools: a myCobot Pro 450 robotic arm with the base mounting platform already installed, a DC 24V power supply, an emergency stop button, etc. Note： Please ensure you have completed the structural assembly as described above and secured the robotic arm base to the tabletop to ensure safe operation. Please connect the power adapter to the corresponding interface on the robotic arm according to the following diagram: Step 1: Connect the DC power supply (please ensure you use the official adapter or a DC power supply with a power capacity of 24V 15A or higher) to the corresponding DC circular connector on the myCobot Pro 450 robotic arm. Connect the other end of the adapter to a 110-220V power outlet. Step 2: Connect the emergency stop button to the corresponding interface on the myCobot Pro 450 robotic arm. Step 3: Connect the corresponding LAN1 interface on the myCobot Pro 450 robotic arm to the host computer. Note: The myCobot Pro 450 must be powered by an external power supply to provide sufficient power. Rated voltage: 24V Rated current: 10A Plug type: DC24V MIC4 (NEUTRIK XLR NC4FX equivalent) 4. Power-on status display First, let's double-check that all necessary cables are properly connected and the connectors are secure. Once you've confirmed this, please press the [power switch]. After turning on the device, you will observe several normal phenomena: The power button will illuminate with a green light, indicating that the power supply is working correctly. The LAN1 interface will flash a yellow light, indicating that the network is initializing. At the same time, this small screen will first display our logo for about 3 seconds, and then it will automatically switch to the main page displaying the angles of each joint. 5. Introduction to MiniRobot Main Interface Function Description Button instructions: After powering on, the robot will perform a self-check for 3 seconds and then default to the main interface, where you can view the robotic arm's coordinates in real time; you can switch to other function interfaces using the buttons below. The horizontal line at the bottom of the interface indicates the currently active interface. Menu Interface Function Description ① Drag-and-drop teaching: Press and hold the end effector interaction button (as shown in Figure 4) to freely drag the robotic arm; trajectory recording and playback are supported. ② Blockly Runner: Allows playback of saved waypoint files. ③ Fast movement: Offers two fast movement modes: free movement and jog movement. ④ Calibration: Offers two modes: automatic calibration per joint and manual calibration per joint. ⑤ Firmware information: Displays robot ID, screen driver, and firmware system version. ⑥ Connections: Supports viewing configuration information for three interfaces: LAN1, LAN2, and WLAN. 6. Basic Functionality Testing Record the trajectory Notice: Data stored in RAM is for temporary storage and will be lost when the power is turned off; data stored in Flash memory is for long-term storage and will not be lost when the power is turned off. Dragging the robotic arm In step 3 of recording the trajectory, the user can freely drag the robotic arm to form any posture (within the range of the robotic arm's joints) and record the trajectory. The image below shows an example: Playback Track Notice： If you attempt to play the recorded track before actually recording a track, a warning screen like the one shown in the image below may appear. Simply return to the menu page and follow the track recording steps described above. 7. Gripper installation and usage Taking the myCobot Pro 450 robotic arm as an example, the following are instructional videos demonstrating the installation of the robotic arm and gripper, as well as some small application examples. Notice： ！Hot-swapping is not supported when connecting the gripper. Before operation, ensure that the robotic arm's power supply is turned off and the system is disabled to avoid equipment damage or safety hazards caused by live-wire operation. Please describe the usage details as thoroughly as possible. If convenient, please provide a video demonstrating the process. This will help us quickly analyze and pinpoint the problem. Thank you in advance! ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/":{"url":"3-FunctionsAndApplications/5-BasicApplication/","title":"5. BasicFunctions","keywords":"","body":"Chapter 5: Basic Functions This chapter mainly explains the basic functions and usage of the product and the basic software. This chapter is crucial and should be read carefully. Please ensure you understand the described operations correctly before actually using the robot. 5.1 SystemInstructions This section introduces the integrated operating solution for the myCobot Pro robot control system, covering local simplified control (MiniRobot), remote professional programming (myStudio Pro), a secure and flexible network architecture, and standard industrial communication interfaces. 5.2 MiniRobot This section introduces MiniRobot, the local control panel for the myCobot Pro robotic arm. Based on miniroboflow adaptation, it supports offline on-site operation via buttons. Its core functions include drag-and-teach programming, status inquiry, basic configuration, communication forwarding, and zero-point calibration, providing an intuitive and convenient human-machine interface. 5.3 myStudio Pro This section introduces myStudio Pro, a multi-functional robot programming and control software that provides users with a one-stop solution for visual programming interaction, quick motion control, drag-and-drop teaching, and robot status inquiry and configuration. The software primarily integrates four functional modules: myBlockly, Quick Motion, Resource Links, and Settings, covering the entire process from programming to debugging, and from learning to deployment. 5.4 SystemUpdate This section provides a detailed explanation of the complete process for flashing/updating the system image on the Pro450 robotic arm. The core operation involves writing the new system image file to the device's main controller using a dedicated PC-based tool (RKDevTool). ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.1-SystemInstructions.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.1-SystemInstructions.html","title":"5.1 SystemInstructions","keywords":"","body":"5.1 System Usage Instructions 1. System Overview The myCobot Pro 450 robot control system is a powerful and intuitive robot software platform designed to help users easily program, control, and monitor robots. Whether you are an engineer, teacher, or operator, you can quickly get started with this system and implement various automation tasks with the robot. The system mainly consists of the following parts: myStudio Pro (WebApp): A browser-based visual programming and control interface that supports remote operation and advanced feature development. MiniRobot (Local Control Interface): A simple local control panel, suitable for quick on-site control and teaching. Network Control System: Supports a secure control architecture with multiple network interfaces (LAN1, LAN2, WLAN), ensuring the isolation of control traffic from internet traffic. Serial Communication Interface: Supports industrial communication protocols such as RS485, facilitating connection to external devices such as PLCs or sensors. 2 Introduction to MiniRobot MiniRobot is a locally controlled interface designed for the robot, acting like a \"remote control.\" With 4 buttons and a small screen, it's easy to operate, requires no computer, and works offline. Main functions: Local Trajectory Recording: Record motion paths using buttons or manual guidance, with an accuracy of ±0.1mm. Simplified File Management: Delete or directly execute saved program files. Fast Execution Control: Supports single or loop execution modes, provides a progress bar display, and offers quick emergency stop response. Status Inquiry: View real-time robot position, speed, load, and other status information. Basic Configuration: Supports speed settings, safety parameter adjustments, and zero-point calibration. Communication Forwarding: Supports UART/SPI data relay for convenient interaction with local devices. Features: Simple operation, fast response, and support for offline use, making it suitable for quick on-site debugging and teaching. 3 myStudio Pro Introduction myStudio Pro is a feature-rich web-based control platform suitable for advanced development and remote management. Main functions: Graphical Programming (Blockly): Quickly write robot programs by dragging and dropping code blocks, supporting motion control, logical judgments, and sensor interaction. Virtual Trajectory Planning and Drag-and-Drop Teaching: Plan paths in a 3D simulation environment, supporting manual dragging to record trajectories and preview motion effects. File Management: Remotely upload, download, and manage program and trajectory files, supporting categorized browsing and a recycle bin function. Execution Monitoring: View the robot's execution status in real time, supporting control operations such as start, pause, and stop. Firmware Updates and Tutorial Integration: One-click check and update of system firmware, with built-in video tutorials and operation guides. Network Configuration Integration: Manage network permissions through a user interface, supporting whitelisting and permission toggling. Features: Comprehensive functionality, strong visualization capabilities, suitable for remote collaboration and complex task development. 4 Network Port Introduction The system supports three network interfaces, each used for a different purpose, ensuring both security and network flexibility. LAN1 (Control Network): Purpose: Dedicated to the transmission of robot control commands. Features: Static IP configuration, not connected to the internet, ensuring real-time control and security. Applicable Scenarios: Local high-real-time control, such as motion commands and sensor data broadcasting. LAN2 (Wired Internet Interface): Purpose: Connects to the internet for remote access, software updates, etc. Features: Supports DHCP for automatic IP address assignment and allows manual configuration of static IP addresses. Applicable Scenarios: Remote debugging, firmware upgrades, cloud service access. WLAN (Wireless Local Area Network): Purpose: Wireless connection to the internet, functionally equivalent to LAN2. Features: Supports Wi-Fi connectivity, suitable for mobile device access. Applicable scenarios: Mobile device control, temporary network access. Security notice: By default, the system only allows control via LAN1. Control functions via LAN2/WLAN must be manually enabled and configured with authentication to ensure secure operation. Port Configuration Table Port Number Protocol Function Real-time Performance Default Network 8000 TCP Main Control Commands High Real-time LAN1 Only 8001 UDP 100ms Position Broadcast Medium Real-time LAN1 Only 8002 UDP 10ms Position Broadcast Ultra-high Real-time LAN1 Only 8100 WebSocket Web Control Medium Real-time LAN1 Only 9000 TCP Modbus Control High Real-time LAN1 Only 8080 HTTP Management Interface Low Real-time All Networks Security Mechanisms 1. Permission Switch Control Remote control for LAN2 and WLAN can be switched on or off independently. Default state: Both are off (most secure). When enabled: The control port is simultaneously bound to the corresponding network. 2. Key Security Measures Broadcast Port Locking: Ports 8001 and 8002 will only be used on LAN1. Mandatory Authentication: Remote access requires account login. IP Whitelisting: Only trusted devices are allowed to connect. Network Configuration Recommendations Usage Scenario Recommended Configuration Advantages Production Environment LAN1 control + LAN2 monitoring Secure control, remote viewing Debugging Environment LAN1 control + WLAN debugging Flexible connection with mobile devices Educational Environment LAN1 control + LAN2 internet access Student programming, teacher monitoring Demonstration Environment Enable all network permissions Convenient for demonstration and operation 5. Introduction to Serial Ports The system has a built-in RS485 industrial serial communication interface, which is mainly used to connect external industrial equipment such as PLCs, sensors, and frequency converters to achieve stable and reliable data exchange and command control. This interface is based on the Modbus protocol (a standard communication protocol widely used in the industrial field), which allows for monitoring the robot's status, controlling its motion, and setting its parameters through simple read and write commands. Main Applications: Read Robot Status: Such as joint angles, end effector coordinates, motion mode, I/O status, etc. Send Control Commands: Control robot movement, start/stop, mode switching, etc. Connect to External Devices: Interact with industrial equipment such as PLCs, touchscreens, and sensors to build automated systems. Typical Use Cases: Robotic arm movements are centrally scheduled by a PLC on the production line. In conjunction with vision sensors, positioning and grasping are achieved. Local control via serial port in environments without a network connection. Communication Configuration Recommendations: Baud Rate: 115200 (Default, compatible with most devices) Protocol: Modbus RTU Tools: Common serial port tools such as Modbus Debug Assistant and SSCOM can be used for testing. Note: Before use, please ensure that the external device supports the Modbus protocol and set the corresponding slave address (default is 45) and register address. For details, please refer to the function list in the protocol manual. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/","title":"5.2 MiniRobot","keywords":"","body":"MiniRobot User Guide MiniRobot is the control panel for the myCobot Pro 450 robotic arm, providing a rich set of functional interfaces for easy and intuitive operation and monitoring. This document summarizes the main functional modules of MiniRobot and their usage methods. Main Functional Modules 1.First Use After the robotic arm is powered on, MiniRobot will display its logo and enter the main interface. The main interface displays the robotic arm's joint information and static IP information by default. Different information can be switched using the buttons at the bottom of the screen: On the main interface: A button: Enter the menu interface (automatically returns to the main interface after 30 seconds of inactivity) B button: Display angle information and static IP C button: Display coordinate information and static IP D button: Display the input/output status of the M8 interface at the end 2.DragTeach Record and play back the robotic arm's motion trajectory using intuitive drag-and-drop operations: Record: Record the robotic arm's motion trajectory (maximum 120 seconds) Play: Play back a saved trajectory file Supports both RAM and Flash storage methods Trajectories saved in Flash can be uploaded to the myStudio Pro production folder 3.BlocklyRunner Manage and execute trajectory files published by myStudio Pro or MiniRobot: Automatically checks published trajectories in the myStudio Pro production folder Supports play, pause, and stop operations Sets single-loop or infinite loop playback mode Supports deleting published track files 4.QuickMove Provides precise movement control for the robotic arm: FreeMove: Press and hold the end effector button to drag the robotic arm freely JogMove: Controls the movement of a single joint by jogging Supports angle and coordinate modes 0.1° single step, long press for continuous movement 5.Calibration Used to calibrate the zero position of each joint of the robotic arm: Select the joint to be calibrated Use the A and B keys to adjust the joint position After moving to the calibration position, press the C key to save; the joint angle will be reset to 0° 6.Firmware Displays all version information of the robotic arm: RobotID: Unique identifier for the robotic arm Screen: MiniRobot version System: System version Soft: myStudio Pro version + Motion Control version Tool: End-effector version 7.Connection View the robotic arm's network connection information: Select different network interfaces Display current network configuration information Operation Precautions In free movement mode, the motor brake will release; please be careful. The menu interface will automatically return to the main interface after 30 seconds of inactivity. There is a maximum recording time limit (120 seconds). Tracks saved in RAM will be lost after a machine restart. File Saving Instructions myStudio Pro production folder: Published track files myStudio Pro test folder: Unpublished track files Saving to Flash in MiniRobot will overwrite previous files, keeping only the latest version Only track files saved in Flash in MiniRobot can be uploaded to the myStudio Pro production folder Error Codes Error codes that occur during machine operation are divided into software error codes and motor error codes. The error code table is as follows: Software Bits Description 0 CAN initialization error. Check the main control board, repair the error, and then power off and restart. Symptoms: The robot cannot be enabled or controlled. 1 Motor initialization error. Check the motor communication lines, repair the error, and then power off and restart. Symptoms: The robot cannot properly provide joint information or control. 2 Motor malfunction. Check the motor communication lines, etc. Symptoms: Abnormal machine position feedback. Can be cleared using error recovery. 3 Motor malfunction. Check the motor communication lines, etc. Symptoms: Abnormal machine position feedback. Can be cleared using error recovery. 4 Position out of tolerance. Check the motor encoder, etc. Symptoms: Abnormal machine connection, unable to move and control. Can be cleared using error recovery. 5 Emergency stop not triggered. Check the communication lines, etc. Symptoms: Abnormal feedback of not triggering emergency stop. Can be cleared using error recovery. 6 Emergency stop not triggered. Check communication lines, etc. Symptom: Abnormal feedback indicating no emergency stop triggered; can be cleared using error recovery. 7 Motor encoder damaged. Motor cannot move when encoder is damaged; encoder needs replacement. 8 Emergency stop triggered by button. Enable state must be restored before movement. Motor Bit Description 0 CAN bus error. Error recovery can be used. If recovery fails, check communication lines, repair, and then power on to enable. 1 Short circuit. Error recovery can be used. 2 Invalid setting data. 3 Control error. Error recovery can be used. 4 CAN communication error. Error recovery can be used. If recovery fails, check communication lines, repair, and then power on to enable. 5 Feedback error. Error recovery can be used. 6 Positive limit switch activated. 7 Negative limit switch activated. 8 Overcurrent, recovery available. 9 I2T protection, recovery available. 10 Overtemperature, recovery available. 11 Driver board overtemperature, recovery available. 12 Overvoltage, recovery available. 13 Undervoltage, recovery available. 14 Command error. 15 Enabled but inactive. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.1-home.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.1-home.html","title":"5.2.1 Home Function","keywords":"","body":"First Use MiniRobot is an interactive module consisting of a TFT screen and buttons. The buttons on the bottom, from left to right, are A, B, C, and D. These buttons allow you to switch between displaying different robotic arm information and control the robotic arm's status. Before starting MiniRobot, the robotic arm must be powered on and the emergency stop button must be connected. After the robotic arm is powered on, if the backend is not started, MiniRobot will default to displaying all current data as 0, including angle, coordinates, and IP. MiniRobot will automatically update the current data approximately 10 seconds after the robotic arm is powered on. Note that MiniRobot, myStudio Pro, and the Python interface have mutually exclusive control over the robotic arm's motion. Only one interface can control the robotic arm at a time. If MiniRobot enters the control interface, myStudio Pro or the Python interface will not be able to control the robotic arm, and vice versa. Entering the control interface is indicated by the following: Dragging the teaching interface and its subpages. The BlocklyRunner interface and its subpages. Quick Movement Interface and its sub-interfaces. Zero-position Calibration Interface and its sub-interfaces. After the robotic arm is powered on, MiniRobot will first display its logo. Then it will enter the main interface, which by default displays the joint information and static IP information of the current robotic arm. Pressing the A button will enter the menu interface. Use the icons at the bottom of the screen to select specific functions. Note that if there is no operation on this interface for 30 seconds, it will automatically redirect back to the main interface. ** You can switch between displaying different robotic arm information using the buttons at the bottom of the screen. Pressing the C button displays the robotic arm's current coordinates and static IP information. Pressing the D button displays the current input/output status of the M8 interface at the end. No small dot indicates a low level, and a white dot indicates a high level. ← Previous Chapter |Next Page → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.2-dragteach.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.2-dragteach.html","title":"5.2.2 DragTeach Function","keywords":"","body":"DragTeach In the Program interface, select the asterisk (*) to enable drag-and-drop teaching. Press the C key to enter drag-and-drop teaching mode. The production folder in myStudio Pro contains published track files, while the test folder contains unpublished track files. Select the Record function and press the C key to enter the recording interface. It defaults to a stopped state upon entry; you can exit the interface directly at this point. Press the A key to start recording. During recording, the end light strip will be solid yellow. Saving is not allowed during recording or pausing. The maximum recording time is 120 seconds. ** You can press the A key to pause recording during the recording process. At this time, the end light strip will be solid blue. Press the B key to stop recording. At this time, the end light strip will be solid green. After stopping recording, you can press the C key to save. Then the interface redirects to the save screen. You can choose to save to RAM or Flash. If saved to RAM, the recorded track files will be lost after a machine restart. If saved to Flash, the recorded track files will not be lost after a machine restart. Track files saved in Flash can be uploaded to the myCobot Pro test folder and named tpr-1. Each save to Flash is an overwrite save, meaning only the most recently recorded track file saved to Flash is retained. Files uploaded to myCobot Pro will be named in tpr-x format, where x represents the number of uploads. After selecting the save path, press the C key; it will display \"Saving.\" After approximately 3 seconds, a \"Save Successful\" screen will appear. This screen will then automatically redirect back to the drag-and-drop teaching interface after approximately 2 seconds. ** During recording, if the recording time exceeds the maximum limit or the recording exits without saving, a warning interface will pop up. At this time, the end light strip will flash red for 1 second. After saving the track file, you can select the Play function in the DragTeach interface to play the most recently saved track file. The track playback defaults to infinite loop. The playback path can be selected to play from RAM or from Flash. After entering the playback interface, press the A key to start playback. The end light strip will flash yellow for 1 second. Pressing the A button again during playback will pause playback; the LED strip will then be solid blue. Pressing the B button will stop playback; the LED strip will then be solid green. After stopping playback, you can choose whether to upload to BlocklyRunner. If you choose to upload, the track file will be saved in the myStudio Pro production folder. Files saved in RAM cannot be uploaded to the myStudio Pro production folder; they can only be played in the drag-and-drop teaching interface. Files saved in Flash can be uploaded to the myStudio Pro production folder. After selecting the save path, press the C key; it will display \"Saving in progress.\" After approximately 3 seconds, a \"Saved Successfully\" screen will appear. This screen will then automatically redirect back to the playback screen after approximately 2 seconds. When attempting to play a track, a warning will be displayed if neither playback path has a file available. If one path has a file but the other does, clicking on it will also display a corresponding warning. At this moment, the red light on the end LED strip flashes for 1 second. ← Previous Chapter |Next Page → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.3-blocklyrunner.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.3-blocklyrunner.html","title":"5.2.3 BlocklyRunner Function","keywords":"","body":"BlocklyRunner In the Program interface, select the BlocklyRunner function by the asterisk. After entering the BlocklyRunner function, it will first check if there are any published track files in the myStudio Pro production folder. The production folder in myStudio Pro contains published track files, while the test folder contains unpublished track files. BlocklyRunner only displays published track files. If no published track files are found, an error message will be displayed. At this time, the end-of-line indicator light will flash red for 1 second. If a published track file exists, it will be displayed in the BlocklyRunner interface, and you can select to play it. After selecting a published track file, its status will be checked first. If the file is normal, press the A key to start playback. During playback, the current loop status of the track file will be displayed in the upper right corner of the screen. Gray indicates single loop playback, white indicates infinite loop playback, and the default is infinite loop playback. Before the track file has started or stopped executing, you can press the C key's menu option to delete the track file, perform single playback, or loop playback. If you select loop playback, playback will automatically restart after the track file finishes playing. The icon indicated by the arrow will turn white. **If you select single playback, playback will automatically stop after the track file finishes playing. The icon indicated by the arrow will turn gray. Pressing the A button again while playing will pause playback. Press the B key to stop playback. If you choose to delete the track file. When you click delete, you will be prompted to confirm the deletion of the track file. After confirmation, a message indicating successful deletion will pop up. After the deletion operation, the corresponding track file in the myStudio Pro production folder will also be deleted synchronously. You need to manually return after deletion; returning will redirect to the interface that reads the myStudio Pro production folder. ← Previous Page |Next Page → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.4-quickmove.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.4-quickmove.html","title":"5.2.4 QuickMove Function","keywords":"","body":"QuickMove In the Program interface, select the QuickMove function by clicking the asterisk (*). Press the C key to enter QuickMove mode. Once in this mode, the end light strip will remain constantly lit with a yellow light. After entering QuickMove mode, you can choose between free movement or joint tapping. In FreeMove mode, the robot arm's angle data is displayed in real-time by default. Press and hold the buttons on either side of the end effector to freely drag the robot arm. This will release the brakes on all motors; please be careful. Pressing the C key will display the current robot arm's coordinate data in real-time. The end effector light will then turn solid blue; returning to the starting position will display a yellow light. Return and select JogMove mode After entering JogMove mode, you can select either the jog angle or the jog coordinate mode. In angle-based motion mode, the current angle information of the robotic arm will be displayed in real time. Select the joint you want to move to control the movement of the robotic arm joint; the selected joint will be highlighted. In single-point motion, the step angle is 0.1°. Holding down the press and holding button will rotate the joint at a speed of 10, automatically stopping when it reaches near its limit. In coordinate jog mode, the current coordinate information of the robotic arm will be displayed in real time. Select the joint you want to jog to control the movement of the robotic arm joints; the selected joint will be highlighted. In single-point jog mode, the step angle is 0.1°. Holding down the jog button will rotate the joint at a speed of 10, automatically stopping when it reaches near its limit. When using the jog mode, the robotic arm will automatically stop when it reaches near the limit. A warning message will pop up, and the blue indicator light will remain on. Pressing the C key at this point will return the arm to the previous position. ← Previous Page |Next Page → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.5-calibration.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.5-calibration.html","title":"5.2.5 Calibration Function","keywords":"","body":"Calibration In the Program interface, select the Calibration function by clicking the asterisk (*), and press the C key to enter the Calibration function. The end LED strip in this interface and its sub-interfaces will remain constantly lit with a green light. After entering the Calibration function, you can select the joint you want to calibrate using the A and B keys. Once selected, the selected area will be highlighted in reverse. The selected joint can then be rotated using the A and B keys. A short press moves the step angle by 0.1°, while a long press is supported. After moving to the desired zero position, press the C key to save. The corresponding joint angle data on the screen will then change to 0°. ← Previous Page |Next Page → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.6-firmware.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.6-firmware.html","title":"5.2.6 Home Function","keywords":"","body":"Firmware In the Program interface, select the Firmware function by marking the asterisk (*), and press the C key to enter the Firmware function. After entering the Firmware function, all version information for the current robotic arm will be displayed. RobotID corresponds to the unique identifier of the robotic arm, used to distinguish different robotic arms. Screen corresponds to the MiniRobot version. System corresponds to the system version. Soft corresponds to the myStudio Pro version + motion control version (e.g., 1.0.1 + 1.0.2 + 1.0.3 = 1.101.102.103). Tool corresponds to the end effector version. ← Previous Chapter |Next Page → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.7-connection.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.7-connection.html","title":"5.2.7 Wireless Connect Function","keywords":"","body":"Wireless Connection Status (Connection) In the Program interface, select the Connection function by clicking the asterisk (*), and press the C key to enter the Connection function. After entering the Connection function, you can select the corresponding network interface to display the configuration information of the current robotic arm network interface. LAN1 is a static IP address. After selection, detailed configuration information of the current network interface will be displayed. LAN1 is a static IP address. After selection, detailed configuration information for the current network interface will be displayed. LAN2 is a static IP address. After selection, detailed configuration information for the current network interface will be displayed. Select the WLAN option. After selection, detailed configuration information for the current network interface will be displayed. ← Previous Page |Next Page → "},"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.8-Q&A.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.2-minirobot/5.2.8-Q&A.html","title":"5.2.8 Q&A","keywords":"","body":"Q&A This chapter lists common questions about using MiniRobot to control robotic arms for your reference. Q1: Are the end effector buttons on the robotic arm only available in the MiniRobot's FreeMove page or under JogMove? A: Yes, the end effector button on the robotic arm can only be used in the MiniRobot's FreeMove page or under JogMove, and can also be controlled through Python's Set_Free_Mode interface. Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/","title":"5.3 MyStudio Pro","keywords":"","body":"What is myStudio Pro? myStudio Pro is a robot programming and control software integrating multiple functions, providing users with one-stop solutions such as visual programming interaction, quick movement control, drag teaching, robot status query and configuration. The software mainly integrates four functional modules: myBlockly, Quick Move, Firmware and Applications, and Settings, covering the entire process requirements from programming to debugging, from learning to deployment. The myBlockly module draws on Scratch, a children's programming language developed by the Massachusetts Institute of Technology, in terms of functionality and design concept, and uses a graphical building block assembly method for programming. Users can gradually build a complete code logic by intuitively dragging and dropping module combinations. The entire process is simple to operate and easy to understand, making it especially suitable for programming beginners and teaching scenarios. From the perspective of user experience, myBlockly is a low-threshold visual code generation tool that makes programming as easy and intuitive as building with blocks. From the perspective of developers, this module is essentially a text editor capable of dynamically generating structured code. The code generated by users through drag-and-drop interactions will eventually be transformed into a sequence of instructions that can be executed on robots. This design and interaction method not only reduce the difficulty of use but also ensure the professionalism and executability of the program. Quick Move The module focuses on the rapid positioning and real-time control of the robotic arm. The rapid movement function can quickly move the robotic arm to the designated position. The read and write states of the end and bottom IO can be set. In addition, the module provides a dedicated operation area, supporting step-by-step or continuous motion control of joints or coordinates, achieving high-precision position adjustment and flexible motion debugging. Firmware and Applications The module provides users with a convenient resource navigation function, centrally displaying the entry points of commonly used external links, including firmware downloads, technical documents, official contact information, etc. Users can quickly access relevant supporting materials without manually searching, improving the efficiency of use and maintenance. Settings The module covers the basic configuration options of software and robot systems. Users can perform operations such as language switching, joint movement limit setting, system update detection and update here. myStudio Pro interface display and the use of basic functions Open the software. The main interface is as shown in the following figure. Interface function introduction: The interface is divided into three areas: Reset to zero and power on/off Function realization Information display Note: The software will automatically communicate and connect to the machine. If the lower right corner shows \"Not connected\", please check whether the network connection between the PC and the machine is unobstructed, or try restarting the machine. Return to zero The function of this button is to control all the joints of the robot to return to the zero position. Note : The function of this button takes effect only if the communication of the robot has been successfully connected. After long pressing and clicking this button with the left mouse button, the robot will start to execute the return-to-zero command. The mechanical arm will slowly move to the zero position. Once the mouse button is released after long pressing, the return-to-zero command stops executing. After the zeroing process is completed, a pop-up window will appear to prompt that the zeroing is done. Soft emergency stop The function of this button is to control the power failure of the entire robot. When visiting the page, it will detect whether the current robot is powered on. If it is powered on, this button will be in red. If the robot is not powered on, this button will change to green and a pop-up window will appear to indicate that the robot is not powered on. You can click this button to power it on. Power on When this button is in a green pattern, its function is to power on. After left-clicking this button with the mouse, the robot will start to execute the power-on command. The entire interface of the application will be covered with a layer of transparent light gray shadow. Before the power-on is completed, do not click on other functions within the interface, and a rotating pattern indicating that the application is power-on will be displayed at the center of the application. After power-on is completed, the icon will turn red and a pop-up window will appear to prompt. Power off When this button is marked in red, its function is to power off. After left-clicking this button with the mouse, the robot begins to execute the power-off command. After the power-off is completed, the icon will turn green and a pop-up window will appear as a prompt. Function implementation Here you can choose the functions you want to use. The functions include the following: myBlockly Graphical Programming Move quickly Firmware and Applications Settings myBlockly myBlockly is a fully visual modular programming interface, belonging to a graphical programming language, suitable for beginners to get familiar with programming. Users can develop applications by dragging and dropping puzzles to create both simple and complex functions. Supports functions such as saving, loading, single-step debugging and execution of graphical code, and executing specified individual building blocks. Note: To use myBlockly, you must first connect the device for communication. myBlockly Here is a clickable button. Clicking it with the left mouse button will redirect you to myBlockly Graphical Programming Interface. Open File Here is a clickable button. After clicking, it will automatically redirect to myBlockly and open the file management list, allowing you to perform operations related to JSON files based on the file list. Create File This button has the same function as myBlockly. quickly load the historically saved blockly file When you have used myBlockly programming and have already saved blockly files, the names of the saved files and their saving times will be displayed at the position shown in the following figure. The maximum number of displayed files is 4. If it exceeds 4, only the latest 4 saved files will be shown. Left-click the mouse button to open myBlockly and automatically load the selected blockly file. Common tools Quick move Function: Provide quick control of robot IO as well as quick control of joint angles and coordinates Firmware and Applications Functions: Provide updates and upgrades for the embedded firmware of robots, product user manuals, official videos, official GitHub online stores, and feedback functions. Settings Functions: Integrates the following core functions: real-time monitoring of robot status and information, one-click check and update of application versions, personalized Settings (language/motion parameters), as well as quick configuration of network connections and login accounts, helping you manage the robot system efficiently. Information display The underlying part of the application includes the logo of Elephant Robot Company, the current type of machine, alarm prompts, and the current operating status of the robot. Alarm prompt Function: Display robot error messages, and left-clicking with the mouse can open the error log window. Left-click the mouse button to open the error log window. If the robot reports an error during operation, the application will capture the exception and display it in the error log interface. The meaning in the error log table is as follows: No: Error log serial number Time: The time when the error occurred Type: The type of error that occurs Description: Incorrect description information After the application captures an error, it will first pop up a window to prompt and provide a solution. If you don't want to deal with the error, you can also ignore it. When you disconnect and reconnect the device or enter the error log interface and click the \"Clear\" button, a pop-up window will appear again to prompt you and save it to the error log table. Robot status Function: Display the current operating status of the robot Color meaning not connected standby operation error ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.1-mystudiofirstuse.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.1-mystudiofirstuse.html","title":"5.3.1 MyStudioFirstUse","keywords":"","body":"MyStudioFirstUse Supported Operating Systems for myStudio Pro Windows macOS Linux arm64 Supported Modern Browsers for myStudio Pro Chrome Edge Safari ... Preparations Before Using myStudio Pro Hardware Configuration Before using myStudio Pro, please ensure your machine is powered on. > The following are the steps to start the server program (using Windows as an example): Static IP Configuration First, you need a working network cable. Connect one end of the cable to the network port on your machine's dock and the other end to the network port on your PC. After connecting the network cable, you need to manually configure a static IP address for your machine for subsequent SSH connections. The configuration steps are as follows: Open Control Panel, select Network and Internet, and then click View network status and tasks. This will take you to the Network and Sharing Center panel. Select Change adapter settings in the left-hand menu and then click to open the Network Connections panel. Select Ethernet and right-click to open the Properties panel. Then, left-click to select Internet Protocol Version 4 (TCP/IPv4), and finally click the Properties button at the bottom. In the Properties panel, click Use the following IP address (S), configure a static IP address 192.168.0.x, and a subnet mask 255.255.255.0. Finally, click OK to close the corresponding configuration panel. To verify successful static IP configuration, press Win+R to open the Run window, then type cmd to open the Windows Command Prompt. Type ping 192.168.0.232 and press Enter. If the following output is displayed, the static IP configuration is successful and the network cable connection is normal. Starting the Server Program Note: The system has already been configured to enable the auto-start service. The following steps are instructions for manual startup. You can log in to the machine system via ssh for operation and control. This chapter uses the MobaXterm graphical tool as an example. Open the application, click the Session button in the top left corner to bring up the panel, select SSH to connect, enter the corresponding Remote host, and click \"Confirm\". After a successful connection, the panel will ask you to enter your username and password (both are root by default) and press Enter to log in to the system. The MyCobot Pro 450 server program is located by default in the following path: /root/MyCobot450/bin. Use the command to view the files in the current directory to check if the corresponding executable file exists. The executable file name is usually MyCobotPro. ls Executing the server file. If the terminal outputs the following information without any error messages, the file has run successfully. ./MyCobotPro If the robot control service script is executed and the terminal does not report an error and outputs the following information, the file runs successfully. /opt/webapp/api/launcher.sh Of course, you can also log in and operate using the cmd panel. The specific steps are as follows (taking Windows as an example): Use win + r to open the cmd panel and enter the following command. Enter ssh-keygen -R 192.168.0.232 Enter ssh root@192.168.0.232 Then enter the login password root Next, follow the steps above to run the server program. Software Configuration Before using myStudio Pro, ensure that a browser, such as Chrome / Edge / Safari or other modern browsers, is installed on your computer. Accessing myStudio Pro myStudio Pro is a web application and does not require installation. It can be used in a browser via IP address. In the ssh connection terminal, enter ifconfig to view, configure, and manage network interface parameters, and confirm the IP. ifconfig Then enter the IP and port number (default deployment to port 8000) into the browser's URL address. Note: the http protocol must be included. The complete address is as follows: http://: Note: If you access myStudio Pro via the LAN1 network port, the system will perform an automatic login operation. After the login is completed, you will automatically enter the main page When you access myStudio Pro using the LAN2 or WLAN network port, you need to log in first. The default username and password are admin and 123. When the browser loads the login page, enter the default password and click the 'Login' button to perform the login operation. How to modify the default login account? When the browser renders the page, it means that myStudio Pro has been successfully accessed. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.2-myBlockly.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.2-myBlockly.html","title":"5.3.2 MyBlockly","keywords":"","body":"MyBlockly myStudio Pro is already configured on your machine. You can access it via your PC by opening a browser and using ip:8000. After the homepage loads, the system will automatically establish a connection with the machine (default static IP: 192.168.0.232:8000). You can click the myBlockly icon or the Create File button to enter the myBlockly programming page. Alternatively, you can click the Create File button to automatically jump to the blockly programming page, loading your saved file content, including the workspace, waypoints, and track file (for information on saving the workspace, click here). Clicking the myBlockly icon or the Create File button to enter the myBlockly programming page is equivalent to creating a new workspace. The myBlockly homepage is shown below: 1 Introduction to the myBlockly Main Interface Number Function Introduction 1 File: Allows Create, Open, Save, Save As and Case about workspaces; 2 Quick Control: Powers on/off the robotic arm, releases/tightens joints; 3 Waypoints&Trajectory: Quickly create and run teaching points, and record and reproduce trajectories; 4 Quick Move: Used for rapid control of the robotic arm's movement; 5 Exit: Exit the myBlockly main interface; 6 One-step: Select a block, click the button to execute only the currently selected block; 7 Run Plane: Open the run plane, where you can run and debug workspace code; 8 Posture: Open the attitude page to see the real-time simulated motion attitude of the 3D model; 9 Toolbox: Provides pre-built blocks for users to use; 10 Workspace Calibration: Clicking this will return the workspace to its origin; 11 Zoom In: Zoom in on the workspace; 12 Zoom Out: Zoom out on the workspace; 13 Trash Can: Blocks in the workspace can be dragged here to delete them, and deleted blocks can also be retrieved from here; 14 Workspace: Blocks in the toolbox can be dragged here for programming; 2 Basic Function Usage Let's write a small case study to introduce the basic usage of myBlockly Case Description: Control the robotic arm to return to zero, then control one joint to move to a 20-degree position, and then return to zero. Step 1: First, click the Posture button to open the attitude view, where you can see the current attitude of the simulated robotic arm. 1: Switch the posture panel: Click to show when the posture panel is hidden, and click to collapse when it is hidden. 2: Robotic arm simulation model, which can simulate motion in real time based on the current actual angle. Step Two: Start Programming Open the toolbox, first-level category Movement, select the second-level category Angle & Coord, and drag the Set Angles block to the workspace. This block is used to control the movement of each joint of the robotic arm to a given angle. The default movement speed is 20. Open the toolbox's primary category Basic, select the secondary category Time, drag the Sleep block to the workspace, and set the sleep time to 3 seconds. Copy the Set Angles block and modify the J 1 angle to 20: Click to select the Set Angles block in the workspace; Press Ctrl + C to copy the Set Angles block; Press Ctrl + V to paste the Set Angles block; Modify the J 1 angle of the new block to 20; Drag the block to connect it to the Sleep block; Similarly, copy the Sleep block and set the sleep time to 3. Seconds; Copy the first Set Angles block in the workspace again; The complete code is as follows: This code means: > Control the robotic arm to return to the zero point Wait 3 seconds Move one joint (J1) to a 20-degree position Wait 3 seconds Control the robotic arm to return to the zero point Finally, click the Run Plane button. After opening the panel, click the Run All button to start executing the code. The right side of the Run Plane will display the joint and angle coordinates in real time, and the 3D model will also simulate motion. The code has finished running. Click the X on the panel to close it. Step 3: Saving and Loading Files (or Saving and Loading the Workspace) myBlockly supports saving and loading the workspace. Click the File button, and a drop-down menu will appear. Click the Save button, and a file naming modal will appear. Enter your desired name and click Confirm to save (by default, it will be saved to the test space). The saved result will be displayed as a message in the lower left corner. Step 4: Creating a New Workspace (This operation will clear all code in the workspace) Click the File button. A drop-down menu will appear. Click the Create button. A prompt will appear. Click the OK button. Workspace creation complete. Step 5: Load the previously saved workspace file. Click the File button. A drop-down menu will appear. Click the Open button in the menu. A list of saved files will be displayed. Select the file you want to load, and use the edit button in the operation column to load the file into the workspace. Loading complete. 3 Quick Fill This chapter introduces the Quick Fill function in the block. When a block has too many data items, filling them one by one is too tedious. Therefore, for blocks with too many data items, we can use the Quick Fill function. Quick Fill Source: Angle or coordinate data of the current robotic arm posture. The following blocks currently support quick fill: How to Use Quick Fill Taking the Set Angles block as an example, first select the block, then click the Quick Fill button within it. When the following prompt box appears on the page, the fill was successful. 4 Quick Move What is Quick Move? Simply put, it's controlling the robot's movement quickly with just mouse clicks, without any programming. Note: myStudio Pro has two Quick Move control panels; their functions are largely the same. Step 1: Click the Quick Move button to open the Quick Move panel and wait for the robot data to return. If all data is zero, please check if the robotic arm is connected and if it is functioning correctly. Step 2: Use the - and + buttons to control different joints of the robotic arm. Single-point movement, long-press for continuous movement, and direct modification of angles and coordinates followed by pressing Enter are supported. Step 3: Control the coordinates. First, you need to move joint 3 to approximately -90 degrees, as shown in the image below. Then you can click the - / + buttons on different axes to control the coordinates. For other functions, please refer to Quick Move 5 Learning to Use Coordinate Control Main APIs Involved: Set Coord Prototype: send_coords(values,speed) Interface Description: Sets multiple coordinates for the robotic arm Parameters: values: [X,Y,Z,RX,RY,RZ] speed: Speed, range 1-100 Small Case Some operations to be performed before first using coordinate movement: Return the robotic arm to zero position. Refer to Controlling the robotic arm to zero Set the initial posture of the robotic arm's coordinate movement (machine J3 needs to be parallel to the ground) As shown in the code below: Open the Run Plane and run the code. Coordinate Movement Drag a Set Coord block to the workspace, and click the Quick Fill button on the block to fill in the data. Change the Z axis data to 300. The complete code is as follows: Execute the code; observe the robotic arm moving up and down throughout the process. 6 One-step One-step execution refers to executing one block at a time. When there are many blocks in the workspace, I only want to execute one block to see the effect. This is where you can use the One-step button. The One-step button is disabled by default and cannot be clicked. Step 1: Drag several joint setting blocks into the workspace. Step 2: Select the Set Joint block. You will observe that the One-step button has been unlocked (its color has changed to a darker shade). Step 3: Click the One-step button. This will automatically open the run panel and begin executing the code. Simultaneously, observe the changes in the robotic arm's movement. (Single-step execution sets joint 1 to 30°) 7 Program Control Introduces how to debug block code using the Run Plane , enabling program Pause, Recover, One-step, and Stop. Edit a program to control the movement of joint 1 of the robotic arm. Click the Run Plane button. When the Run Plane pops up, click Run All, and immediately click the Pause button. The program will pause after executing the first instruction mc.send_angle(1,0,20). The program is paused. The next instruction to be executed, time.sleep(3), appears. At this point: If you click the Recover button, the program will automatically continue execution; If you click the One-step button, The program will execute the time.sleep(3) instruction. When One-step is clicked again, the program will execute the next instruction, namely mc.send_angle(1,-90,20); If you click the Stop button, the program will be terminated; What happens next is up to you! 8 Using Drag-and-Teach This chapter introduces how to use the drag-and-teach function in myBlockly. This refers to the movement of the manipulator along the direction of the operator's force under the operator's traction (traction of the end or traction of a manipulator). This function makes it easy to plan trajectories (for tasks where the process trajectory accuracy is not high), so that the operator can record and reproduce the trajectory without manual programming, lowering the barrier to entry for operators and improving efficiency. API Display Small Case Study We will achieve the following effect: A robotic arm can be dragged freely to perform some actions. After dragging, the robotic arm will execute the actions just performed. This is equivalent to recording and playing back a trajectory. The complete code is as follows: Code Explanation: Record trajectory: After executing this block, the robotic arm's joint brakes release, and the robotic arm can now be dragged. Wait 10 seconds (equivalent to recording for 10 seconds) Pause recording: The robotic arm's joint brakes lock, and it cannot be dragged manually. Wait 10 seconds Play trajectory: The robotic arm begins executing the previously recorded trajectory. Wait 10 seconds (equivalent to playing back the previously recorded 10-second trajectory) 9 Using the Gripper This chapter introduces how to use myBlockly to control the F100 force control gripper connected to a robotic arm. API display We will use the following blocks: 1: Set F100 Force Control Gripper Angle: Makes the gripper enter a specified state (open or closed) at a specified angle. Parameter description: This block has two adjustable parameters: Gripper ID parameter: Default 14 Gripper Angle parameter: Represents the angle to be set, with a value range of 0~100 2: Read F100 Force Control Gripper Angle: Reads the current gripper angle value. This block has one adjustable parameter: Gripper ID parameter: Default 14 Small Case The graphical code is as follows: Code execution results: Control the F100 force control gripper to reach a position with a value of 80 Wait 3 seconds Control the F100 force control gripper to reach a position with a value of 20 Wait 3 seconds Read the current angle value of the F100 force control gripper Wait 3 seconds Control the F100 force control gripper to reach a position with a value of 0 Note: If you cannot control the gripper from the above examples, please ensure that your F100 force control gripper communication method is modbus protocol control. After setting, run the small case code again. 10 Waypoints This chapter introduces how to use the waypoint function to control a robotic arm. Function Description: By inputting multiple waypoint data (robotic arm joints and coordinates), you can quickly control the robotic arm to reach the position of each waypoint. Open the waypoint list page, long press the end effector button, release the robotic arm, manually adjust the robotic arm's posture, and click New Point to add a waypoint data entry. Number Description 1 Clicking the \"Import\" button imports a previously saved waypoint information JSON file. 2 Clicking the \"Export\" button exports all waypoint information into a single JSON file. 3 Clicking the \"Delete\" button deletes all selected waypoints in the current waypoint list. 4 Clicking the \"Copy\" button copies the coordinate information of all currently selected waypoints. 5 Clicking the \"Rename\" button renames all currently selected waypoints. 6 Clicking the \"Cover current point\" button quickly overwrites the coordinate information of all selected waypoints with the current robot arm coordinates. 7 Selecting columns in the list data is a prerequisite for functions 3-6. 8 Clicking the \"Run\" button moves the robot arm to the currently recorded waypoint position. 9 Clicking the \"New Point\" button records the current robot arm coordinates. 10 Clicking the \"Generate Code\" button quickly generates waypoint blocks in the Blockly program coding area. Select a waypoint block in myBlockly and add it to the program coding area. Alternatively, use the Generate Code button in the waypoint list to add the generated waypoint block to the last block in the workspace. The waypoint block associates data from the waypoint list. Select any waypoint in the list to associate. Adds point information to the waypoint block. Select \"Add Waypoint,\" click the \"Edit\" icon to open the \"Add Waypoint\" pop-up. The default waypoint name will be displayed. Adjust the waypoint information using the \"+\" or \"-\" buttons, and then click the \"Save Waypoint\" button to add the waypoint data. Furthermore, the waypoint blocks can have their motion modes modified: Joint Motion Mode: moves based on the joint information of the current waypoint; Linear Motion Mode: moves based on the coordinate information of the current waypoint. Number Description 1 Select a waypoint. Clicking the edit icon will open the waypoint editing pop-up. 2 Enter the waypoint name. 3 Displays the joint and coordinate data of the robotic arm. Adjust the waypoint data using the left (-) and right (+) buttons. 4 Click \"Save Waypoint\" to add or modify waypoint data. 11 Trajectory Introduces how to use the track function to control the robotic arm and achieve drag-and-drop teaching. Function Description: By recording multiple track data (robotic arm joints), quickly control the robotic arm to reach each track point position. Open the track list page, click the \"Record trajectory\" button, the joints of the robotic arm will relax, manually drag the robotic arm to record the track, click \"Stop Recording\" and wait for the track to be saved. Once saved, the track recording is complete. Successfully recorded tracks will automatically generate a track type file in the \"draft\" (For file function related operations, please click here). Number Description 1 First, select the trajectory to be deleted. At least one data point must be checked for the button to be available. Clicking \"Delete\" will delete all checked trajectories. 2 Select columns in the list data. Function 1 requires this function. 3 Clicking the \"Reprtition\" button allows you to reproduce the trajectory. 4 Clicking the \"Copy\" button copies the current trajectory to the test file workspace. 5 Clicking the \"Record trajectory\" button will prompt the robotic arm to confirm the recording operation. After confirmation, recording will begin (maximum 60 seconds; recording will automatically stop after this time). Then, select the trajectory block in myBlockly and add it to the program programming area. Clicking the drop-down menu of a trajectory block in the workspace allows you to select data from the current trajectory list page. After selection, open the Run Plane and click Run All to reproduce the trajectory using the block-by-block method. After the program runs, the trajectory is reproduced. Of course, you can also use other blocks for more complex programming. 12 File Management Introduces how to use the file management module. Function Description: The file management module allows for easy saving, importing, and exporting of files from different file spaces. There are two ways to open the file list: Open File from the Homepage - or Open from the file operation menu on the myBlockly page. This will open the file management list and load your saved file content, including workspaces, waypoints, and track files (for information on how to save workspaces, click here). Number Description 1 draft: Switching to this option will paginate and display all test files. 2 runner: Switching to this option will paginate and display all production files. 3 Recycle Bin File Space: Switching to this option will paginate and display all recycle bin files (files deleted from the test/production space will go to the recycle bin and will be automatically reclaimed after 30 days). 4 Search condition input box. Currently, only fuzzy search by filename is supported. You can press Enter to search directly or click the function 5 button. 5 Search button. Clicking this button allows you to perform a paginated search based on the input box content. 6 Import button. Clicking this button allows you to import files from the current device. 7 Export button. Disabled by default, enabled when a single file is selected. Clicking this button allows you to export the selected file. 8 List data selection column. Functions 7 and 11-14 require this function. 9 Single file operation buttons, including the following function buttons: Edit - Loads the file content into the workspace; Preview - Only applicable to trajectory files; 3D models simulate trajectory points; Copy - Copies the production space file to the test space; Recover - Restores the recycle bin space file to the test space. 10 Pagination button: Enables pagination when the current file space exceeds the specified limit. 11 | Batch operation button: Delete - deletes selected files to the recycle bin.| |12 | Single file operation button: Selecting a file and clicking this button loads the file's content into the workspace and automatically opens the debug panel.| | 13 | Single file operation button: Selecting a file and clicking this button loads the file's content into the workspace and automatically opens the debug panel. The panel allows you to set the number of times the file will run – infinite loop or multiple loops.| | 14 | Single file operation button: Selecting a file and clicking this button publishes the file to the production space.| Search By default, queries all files. You can enter a filename for a fuzzy search. When the input box contains content, the search will be based on the current file space and the content. A successful search will display a message. Import Click the Import button, select the file to import, and click OK. Note: The file selected for import must be exported from myStudio Pro; otherwise, you will encounter an import failure or import success but \"cannot be edited\" error. Click the Import button, select the file to import, and click OK. Edit Click the Edit button to load the file content into the workspace. Preview ClickThe Preview button will open the preview panel. The 3D model will simulate motion based on the actual points in the trajectory file. Delete Click the Delete button to delete files in batches, moving the selected files to the Recycle Bin. Select the files you want to delete, then click the Delete button. Switch to the Recycle Bin option to view the deleted files in the list. Recover Click the Recover button to restore the file from the recycle bin to the test space. Debug Select the files you want to debug, then click the Debug button. It will first check if there is any unsaved content in the workspace and prompt you. If so, a pop-up window will appear; click \"Ok\" to load it into the workspace. Otherwise, it will load directly and open the debug panel. Click \"Run All\" to begin debugging. Run Select the file you want to run, then click the Run button. First, it will check if there is any unsaved content in the workspace and prompt you. If so, a pop-up window will appear; click \"Ok\" to load it into the workspace. Otherwise, it will load directly, and the Run panel will open; click \"Run\" to run the file. You can choose to run the file infinitely or specify the number of runs (the following explains the looping process). After setting, it will run in a loop. First, it will prompt you twice for confirmation; click \"Confirm\" to start the loop. After running. Publish Select the files to be published, and then click the Publish button. This will publish the corresponding files from the test space to the production space. Copy Click the Copy button to copy the file from the production space to the test space. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.3-quickmove.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.3-quickmove.html","title":"5.3.3 QuickMove","keywords":"","body":"Quick Move Before Starting 1. Ensure the machine is powered on 2. Ensure the machine connection and communication are normal 3. Ensure the machine is in zero position 4. The machine server is running 1 Interface Introduction Number Description 1 myCobot Pro 450 3D Simulation Model (Coordinate system: Red arrow: X, Green arrow: Y, Blue arrow: Z) 2 Bottom IO pins 1-12, Input, belongs to the safety module detection item 3 Bottom IO pins 1-12, Output, the output can be set by clicking the switch button 4 End-effector I/O pins 1 and 2, inputs 5 End-effector I/O pins 1 and 2, outputs, can be used to control the F100 force control gripper 6 Exit the quick movement interface 7 Angle control: By clicking the + - buttons, the joint angle of the robotic arm is controlled. The value represents the current joint angle information of the robotic arm. The value can also be directly modified for joint control. 8 Coordinate control: By clicking the + - buttons, the coordinate control of the robotic arm is performed. The value represents the current coordinate posture information of the robotic arm. The value can also be directly modified for coordinate control. 9 Set the movement speed of the robotic arm joints, default 20 degrees/s 10 Set the movement speed of the robotic arm coordinates, default 20 mm/s 11 Angle step size: The angle value that increases or decreases each time the angle is adjusted 12 Coordinate step size: The coordinate value that increases or decreases each time the coordinate posture is adjusted 2 Angle Control In the angle control area, by clicking the + The - button controls the joint angles of the robotic arm. The value represents the current joint angle information of the robotic arm, and you can also directly modify the value to control the joints, Enter the position within the limit range and then click Enter to start the control. 3 Coordinate Control Before using coordinate control, joint 3 needs to be moved to an angle of approximately -90 degrees. In the coordinate control area, click the + and - buttons to control the coordinates of the robotic arm. The value represents the current coordinate posture information of the robotic arm, and you can also directly modify the value to control the coordinates, Enter the position within the limit range and then click 'Enter' to start the control. 4 Continuous Movement By long-pressing the + and - buttons in the corresponding areas, you can control the robot to move continuously at a specified angle/coordinate. Note: After each 3-second long press of the + and - buttons, you need to release the buttons, press and hold them again, and then continue the continuous movement. Note: When controlling the coordinates, the robotic arm must first be moved to the coordinate control posture. 5 IO Control 5.1 Bottom IO Set the bottom IO pin numbers 1-12 for output; users can customize the control actuators. For example, you can customize the control of the gripper and suction pump. Click the On and Off buttons to configure. 5.2 End-of-Line I/O Setting the end-of-line I/O pin numbers 1-2 allows you to control the F100 force-controlled gripper. Turn on the F100 force-controlled gripper by clicking the Off and On buttons. Disable the F100 force Control Gripper by clicking the On and Off buttons. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.4-resource.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.4-resource.html","title":"5.3.4 Firmware and Applications","keywords":"","body":"Firmware and Applications 1 Interface Introduction The homepage is shown below: The myCobot Pro 450 supports remote upgrades and flashing of the latest versions of the main controller, terminal, and screen firmware. The machine defaults to using the latest firmware version. If a new firmware version is released, myStudio Pro will automatically download the latest firmware information as long as a stable network connection is maintained while using it. 2 Firmware Function Introduction: mainControl Main controller firmware name Version Number The default is the latest released firmware version, but other versions can also be selected for flashing. Description Information Description information for the corresponding firmware version, generally including update information for this firmware version. Delete Delete Button: The firmware delete button is used to delete the specified firmware version stored locally. Clicking this button will bring up a prompt asking you to confirm whether you want to delete the firmware. Clicking the \"Confirm\" button confirms the deletion; clicking the \"Cancel\" button cancels the deletion. Download When there is an undownloaded firmware or after deleting firmware, the Flash/Update button will change to a Download button, and the \"Delete\" button will disappear. Clicking \"Download\" will automatically download the firmware. After the download is complete, the \"Update\" and \"Delete\" buttons will reappear. Clicking the update button will initiate the firmware update. A text overlay will appear on the page indicating that the page cannot be accessed during the firmware update. Please wait patiently and do not close the page until the firmware upgrade is complete. Screen Screen Firmware Name Description Information Description information for the corresponding firmware version, usually including update information for this firmware version. End End Firmware Name Version Number The default is the latest released firmware version, but other versions can also be selected for flashing. Description Information Description information for the corresponding firmware version, generally including update information for this firmware version. 3 Document This function is a webpage redirection link. Clicking it will open the product's Gitbook page in your current browser. 4 Tutorial This function is a webpage redirection link. Clicking it will open the official video tutorial in your current browser. The English version will redirect to YouTube, and the Chinese version will redirect to Bilibili, with the corresponding links accessed in an embedded manner. 5 Github This function is a webpage redirection link. Clicking it will open the official Github page in your current browser. 6 Shopping This function is a webpage redirection link. Clicking it will open the purchase page for the corresponding product in your current browser. The Chinese version will redirect to Taobao, and the English version will redirect to Shopify, with the corresponding links accessed in an embedded manner. 7 Contact If you have any questions or ideas, you can contact us here. Function Introduction: Name You can enter your nickname here. This is a required field. If you submit without filling it in, you will receive a message indicating that you are not there. Email You can enter your email address here. This is a required field. You can enter your email address here so that our staff can reply to you. If you submit without filling it in, you will receive a message indicating that you are not there. Message Enter your comments here. This is a required field. Enter your questions or thoughts here. If you submit without filling it out, you will receive a prompt. Upload Click this button to upload files. You can upload a maximum of 3 files, and each file must not exceed 50MB. After clicking, a pop-up window will appear allowing you to select files. If the file you select exceeds 50MB, clicking \"Open\" will fail, and a pop-up window will warn you that the file is too large. When you are uploading more than three files, a pop-up window will warn you. Note: Only .log, .json, video, and image files are supported for uploading. Submit Click the submit button to submit all information. This step may take a long time, please be patient. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.5-setting.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.5-setting.html","title":"5.3.5 Setting","keywords":"","body":"Settings 1 Interface Introduction Number Function Introduction 1 General Settings Module, mainly for setting the language 2 Limit Settings Module 3 Check for Updates Module 4 Initial Posture Module 5 Test Module 6 Network Configuration Module 7 Account Settings Module 8 Module Content Display Area 9 Exit Settings 2 General Setting Clicking the General Setting icon button will take you to the language settings page. Language selection supports Chinese and English. After selecting the corresponding language, click the Save button. A confirmation pop-up will appear; click Confirm to successfully set the language. 3 Limit Setting Note: Limit parameter modification only supports the minimum and maximum angles of the joint; other parameters cannot be modified. Clicking the Limit Setting icon button will take you to the joint limit settings page. The Limit Setting interface displays the joint and coordinate limit parameters of the current robotic arm by default. The Parameter lock button is locked by default, and its blue color indicates that the limit parameters cannot be modified. When the parameter is locked, clicking the Parameter lock button will turn it gray, indicating that the limit parameters can be modified (only the minimum and maximum angle values ​​can be changed). Click the Save button, and define the filename according to the prompts in the pop-up window. This will save the parameters of the current limit setting page to a local file (JSON file), and set the joint limits of the robotic arm. A message will be displayed on the page after successful setting. Click the \"Reset\" button to restore all joints and coordinate limits to their default Settings. When clicked, it prompts \"Whether to restore the default Settings?\" When you click \"Confirm\", a prompt will appear saying \"Set successful\" 4 Update Check Clicking the Update Check icon button will take you to the update status page. The update page primarily checks the status of the robotic arm's end effector firmware, main control firmware, and myStudio Pro version. If the corresponding firmware or software for the robotic arm is not the latest version, an update message will be displayed, and the status item will highlight \"Update Required.\" Clicking this will initiate the corresponding update process. Additionally, this page also provides a system image Upgrade button. This item displays the current version; clicking it will trigger a pop-up window with detailed upgrade instructions. 5 Initial Position Clicking the Initial Position icon will take you to the Initial Pose page. This page contains Initial Position and Packaging Position content. You can switch between the content you want to access using the toggle button. Initial Pose Page: Displays the robot arm's initial pose model, joint angle information, and coordinate pose information. Packaging Pose Page: Displays the robot arm's packaging pose model, joint angle information, and the packaging button. This button is a function button; clicking it will move the robot arm to the packaging pose. 6 Test Module Clicking the Test Module icon will take you to the test page. The Test page primarily tests the robotic arm's communication connection, firmware version, servo motor status, etc. Clicking the Start Detection button will begin the test. After the test is complete, click the Save Test Log button. Following the pop-up prompts, the test results will be saved to a local log file. 7 Network Configuration Clicking the Network Configuration icon will take you to the network configuration page. This page primarily displays the robotic arm's network port information, including LAN1, LAN2, and WLAN. Note: The page content is displayed in real-time; network port information is only shown when a port is in use. Simultaneously, you can connect to WiFi on this page. Enter the WiFi username and password you want to connect to and click the Connect WiFi button to connect. Furthermore, you can modify the robot control permissions for this network port on this page. If robot control permissions are not enabled, accessing myStudio Pro will display \"No control permissions.\" MyStudio Pro can only be used normally when control permissions are enabled. The following explanation is based on the WLAN port. The control logic for the LAN2 port is the same. In your browser, enter the IP address of the WLAN port to access MyStudio Pro (Wi-Fi connected & control permissions not enabled). When enabling/disabling control permissions, a second confirmation is required. Clicking Confirm will successfully enable/disable control permissions. In your browser, enter the IP address of your WLAN port to access myStudio Pro (Wi-Fi connected & control permissions enabled). You will be taken to the account login page. Enter the correct username and password to use myStudio Pro. The default username and password are admin and 123. If you have changed your username and password (see point 8 for instructions), please use the changed username and password to log in; otherwise, you will not be able to use myStudio Pro. After successful login, the system will first check if any network port is currently using myStudio Pro. If so, a second login confirmation will be required. Clicking \"Login\" will automatically log the currently used network port offline, allowing you to use myStudio Pro normally. Clicking \"Cancel Login\" will return you to the login page. Otherwise, you will directly enter the myStudio Pro main interface. 8 Account Settings Clicking the Account Settings icon will take you to the account settings page. This page is mainly used to set the username and password for logging into myStudio Pro using the LAN2 or WLAN network port. If the username and password are saved successfully, they will be used to log in to myStudio Pro the next time; otherwise, you will not be able to use myStudio Pro normally. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.6-modbus.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.6-modbus.html","title":"5.3.6 Modbus","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.7-Q&A.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.3-myStudioPro/5.3.7-Q&A.html","title":"5.3.7 Q&A","keywords":"","body":"Q&A This chapter lists frequently asked questions about using myStudio Pro to control a robotic arm for your reference. Q1: ​​When running myBlockly, the error message ModuleNotFoundError: No module named 'pymycobot' appears. A: This is because the pymycobot library was not installed when setting up the Python environment. To install the pymycobot library, open a terminal (Win key + R key), type pip install pymycobot --upgrade --user and press Enter. You should then see \"pymycobot installed successfully\". Q2: The robotic arm is not responding because the sleep method module was not added? A:** The program for operating the robotic arm takes a certain amount of time to complete. Therefore, after completing one action, a sleep module needs to be connected to allow the robotic arm sufficient time before performing the next action (the required time depends on the specific situation and machine; the default setting for the robotic arm is a minimum sleep time of 0.5 seconds when running myBlockly). Otherwise, the robotic arm will not be able to perform the desired actions. Q3: SSH connection failure A: This is generally caused by a poor network cable connection. Try unplugging and replugging the network cable from the PC. When the control panel detects the connection (usually as Ethernet), open the Windows command prompt and use the ping command to check. If normal output is available, try connecting via SSH. If the above steps do not solve the problem, try restarting the machine. Q4: Why does the browser remain in the loading stage or fail to access the IP address? ** A: Please ensure your PC and robotic arm are on the same local area network (you can ping the robotic arm's IP address from your PC). Try using a different browser (Chrome/Edge recommended) and refresh the cache (Ctrl + F5). Q5: Why can't I control the gripper using blocks in myBlockly programming? A: Please check the F100 force control gripper control method. The myCobotPro 450 gripper requires the modbus control method. Please configure the F100 force control gripper correctly and try again. Q6: Why does the firmware download on the General Firmware page fail? A: The General Firmware page requires the robotic arm to be connected to the internet. Note that this refers to the robotic arm itself, not the myStudio Pro device. Firmware cannot be downloaded without an internet connection. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/5-BasicApplication/5.4-system_flash.html":{"url":"3-FunctionsAndApplications/5-BasicApplication/5.4-system_flash.html","title":"5.4 SystemUpdate","keywords":"","body":"Pro450 System Image Burning Instructions Note: After the system image is burned, each joint of the robotic arm needs to be recalibrated at its zero position before it can be used normally. This section will guide you on how to use a burning tool on your PC to correctly burn the system image to the Pro450 controller. Please follow the steps strictly to ensure a safe and successful burning process. 1 Preparation Before starting the flashing process, please ensure the following hardware and software are ready: Hardware Requirements Device Quantity Description Windows PC 1 unit Running flashing tools and driver installation Double-headed USB cable 1 piece Connecting the PC and the Pro450 Pro450 robot 1 unit Device to be flashed Stable power supply 1 set Powering the Pro450 (keep powered on) Emergency stop switch 1 unit Safety protection Network cable 1 piece Connecting the robotic arm to the PC Software Requirements Official system image file Flashing tool (e.g., RKDevTool_Release_v3.15, subject to availability) Corresponding USB driver (usually a USB-to-serial driver for the device) 🔔 Tip: It is recommended to place all tools in the same folder and avoid Chinese characters or spaces in the path. Network Configuration MyCobot Pro 450 Default IP Address: 192.168.0.232 Default Port Number: 4500 Note: The PC's network card IP address needs to be set to the same subnet (e.g., 192.168.0.xxx, where xxx is any number between 2 and 254, and it cannot conflict with the robotic arm). Example: Robotic Arm IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet Mask: 255.255.255.0 Verification: After completing the network configuration, you can execute the following command in the PC terminal. If it successfully returns data packets, the network connection is normal: ``bash ping 192.168.0.232 ``` 2 System Image Download Click to download the image:myCobot_Pro_450_buildroot_20251110.img 3 Install USB Driver Click to download the driver:DriverAssitant_v5.12.zip After downloading the driver, extract and open the provided DriverAssitant_v5.12 folder. Double-click DriverInstall.exe to install. 4 Install the burning tool Click to download the burning tool:RKDevTool_Release_v3.15.zip After downloading the driver, extract and open the provided folder RKDevTool_Release_v3.15/RKDevTool_v3.15_for_window. Double-click RKDevTool.exe to run it. 5 Connecting the Pro450 Device Connect the device to your PC using a double-ended USB cable. Connect one end of the double-ended USB cable to your computer and the other end to the USB1 port (the USB port on top) on the Pro450's dock. Ensure the Pro450 is powered on and connected to your computer using an Ethernet cable. Remotely SSH into the Pro450 system from your PC to execute the flashing command. 6 SSH Remote Connection Use the Win + R shortcut to open the cmd command prompt and enter the following command: ssh-keygen -R 192.168.0.232 ssh root@192.168.0.232 Follow the prompts to enter yes, then enter the login password root. 7. Start the System Flashing Function After logging in via SSH, enter the following command to start the system flashing function: reboot loader 8 Start the flashing tool After starting the system flashing function in Step 7, opening the flashing tool will display the following image: Click the Upgrade Firmware button Click the Firmware button to open File Explorer, select the system image file to be flashed, and then click Open. After selecting the image file, click the Upgrade button. After the system image is successfully burned, a prompt message will appear on the right side of the burning tool: 9 Verify System Image Burning After burning the system image, reconnect to the robotic arm system remotely using SSH and enter the following command to check the system version number: cat /etc/version The system image file name is associated with the system version number. If the output version number matches the date name of the image file, it means the system image was successfully burned. Note: After the system image is burned, each joint of the robotic arm needs to be recalibrated at its zero position before it can be used normally. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/6.developmentGuide/":{"url":"3-FunctionsAndApplications/6.developmentGuide/","title":"6. SoftwareDevelopmentGuide","keywords":"","body":"Chapter 6 Software Development Guide Usage Environment myCobot Pro 450 is developed and used based on PC. Since there is no built-in system in the robot arm, the robot arm and PC need to be combined during use. Please prepare the PC before use. Development Environment In order to meet the diverse application needs of robots in different scenarios, we have adapted the robot to multiple programming languages. So far, we have adapted the following mainstream programming languages, and we think you can use any of the following languages ​​for development. Please be sure to follow the instructions strictly. Any omitted steps may cause the corresponding language to fail to run successfully. I wish you a smooth use of the robot. 6.1 Python Our robot supports Python, and the development of the Python API library is also becoming more and more perfect. The robot's joint angles, coordinates, grippers and other aspects can be controlled by Python. 6.2 ROS1 ROS (Robot Operating System), as an open source robot operating system, provides unlimited possibilities for robot development and control. Our robot can be controlled in a modular way through ROS's rich control functions. Whether it is joint control, path planning or sensor feedback, ROS provides corresponding tools and libraries to make the control process more flexible and efficient. 6.3 ROS2 ROS 2 (Robot Operating System 2) is a flexible software framework designed for robot software development. Our robot can make application development more efficient and modular through a series of services and functions such as hardware abstraction, device drivers, library functions, visualization tools, messaging, and package management. 6.4 C++ C++ is the inheritance of C language. It can be used for both procedural programming in C language and object-based programming characterized by abstract data types. Using C++ language, you can freely develop (coordinate control, angle control, io control, gripper control, etc.) through the C++ dynamic library developed by our company, and control some robots that our company has developed. 6.5 Communication If you have a certain understanding of information theory, coding and robot communication functions, then you should understand that all communication originates from data transmission. In order to facilitate users to operate the robot, we have opened a communication protocol based on serial communication. You can use the serial assistant or encapsulate it into any programming language you are familiar with to control the robot. ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/","title":"6.1 Python","keywords":"","body":"What is Python? Our products are very friendly to Python, and the development of Python API library is also improving day by day. Through Python, the robot's joint angles, coordinates, grippers and other aspects can be controlled. There are many options. If you want to control our robot arm through Python programming, you can learn this chapter. Python was designed by Guido van Rossum of the Netherlands Institute for Mathematical and Computer Science Research in the early 1990s as a replacement for a language called ABC. Python provides efficient high-level data structures and simple and effective object-oriented programming. Python syntax and dynamic typing, as well as the nature of interpreted languages, make it a programming language for writing scripts and rapidly developing applications on most platforms. With the continuous update of versions and the addition of new language functions, it is gradually used for the development of independent and large projects. Python interpreter is easy to extend, and can be extended with new functions and data types using C or C++ (or other languages ​​that can be called from C). Python can also be used as an extension language in customizable software. Python has a rich standard library that provides source code or machine code for all major system platforms. Python development and use guide You can use Python to develop our robot arm according to the following guidelines Environment construction API description Joint control Coordinate control IO control Gripper control Robot exception handling ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/1_download.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/1_download.html","title":"6.1.1 EnvironmentConstruction","keywords":"","body":"Environment Setup pymycobot is a Python package for serial communication with myCobot, supporting Python3.5 and later versions. Before using pymycobot to control the robot arm, you need to build a Python environment. The following is a detailed description of Python download and installation. Linux System Install the pymycobot library in the console terminal: pip install pymycobot --upgrade --user Windows System Download And Install Python Applicable devices: myCobot Pro 450 Currently, there are two versions of Python, one is 2.x version and the other is 3.x version. These two versions are incompatible. As 3.x version is becoming more and more popular, our tutorial will take the latest 3.10.7 version as an example. Install Python Note: Before installing, please confirm whether your computer is 64-bit or 32-bit. Right-click My Computer and select Properties. As shown in the figure below, it is a 64-bit operating system, so select the 64-bit Python installation package. Python official download address: https://www.python.org/downloads/ Click the Downloads option to start downloading Python, click Add Python 3.10 to PATH, click Install Now to start installing Python The prompt \"Setup was successful\" appears, indicating that the installation is complete Run Python After successful installation, open the command prompt window (Win+R, enter cmd and press Enter), and type python. Two situations will occur. Situation 1: The prompt in the picture indicates that Python has been successfully installed. The prompt >>> indicates that we are already in the Python interactive environment. We can enter any Python code and get the execution result immediately after pressing Enter. Case 2: If the input is wrong (for example, enter pythonn), an error message will appear: Note: The error message is generally caused by not configuring the environment variables. You can refer to 1.3 Configure environment variables to modify the environment variables. Configure Environment Variables Since Windows will search for python.exe according to the path set by a Path environment variable, if it is not found, an error will be reported. Therefore, if you miss checking Add Python 3.10 to PATH during installation, you need to manually add the path where python.exe is located to Path, or reinstall Python and remember to check the Add Python 3.10 to PATH option. The following are the steps to manually add the path where python.exe is located. Right-click My Computer –> Select Properties –> Select Advanced System Settings –> Select Environment Variables in the lower right corner: Environment variables mainly include user variables and system variables. The environment variables that need to be set are in these two variables. As shown in the figure below: User variables are used to download programs that can be used in cmd commands. Write the absolute path of the program to the user variable and you can use it, as shown in the figure below: After completing the above steps, open the command prompt window (Win+R, then enter cmd, press Enter), type Python, and the prompt in the figure below indicates success: PyCharm Installation And Use PyCharm is a powerful Python editor with cross-platform capabilities. First, let's introduce the installation steps of PyCharm in Windows system. Download address: https://www.jetbrains.com/pycharm/download/#section=windows Download And Install After entering the website, we will see the following interface: Download the file according to the interface introduction. Professional means professional version, and Community means community version. It is recommended to install the community version because it is free to use. After downloading, start installing and click Next: Select the corresponding options according to your personal preferences, and then click Next: The following interface appears and continue to click Next: Click Finish to complete the installation: Create A Project After PyCharm is installed, enter the software and create the first program. Click the PyCharm icon on the desktop to enter PyCharm, as shown in the figure below, and click New Project: After clicking, find Interpreter, start setting the interpreter, and click Add Interpreter: Click New, find the python.exe storage location, and check the Inherit global site-package option: Set Location. Location is where the PyCharm project is stored. You can choose it according to your needs. Create a new PyCharm file. Right-click the document icon pointed by the arrow, click New, click Python File, and the new file is created successfully. Name Python File: After the file is successfully created, you will enter the following interface and you can write your own program Before Use Firmware burning. Firmware refers to the device \"driver\" stored inside the device. Only through firmware can the operating system implement the operation of a specific machine according to the standard device driver. Different versions of the robot arm need to burn different firmware (refer to the MyStudio chapter). pymycobot installation. Open a console terminal (shortcut Win+R, enter cmd to enter the terminal), and enter the following command: pip install pymycobot --upgrade --user The following words appear, indicating that the pymycobot package has been successfully installed Source code installation. Open a console terminal (shortcut Win+R, enter cmd to enter the terminal), enter the following command to install: git clone -b develop https://github.com/elephantrobotics/pymycobot.git #Where fills in your installation address, if not filled in, the current path is used by default cd /pymycobot #Enter the pymycobot folder of the download package #Run one of the following commands according to your python version # Install python2 setup.py install # or python3 setup.py install Simple Use Of Python After the above preparations are completed, start to control the robot arm through Python code. Here, the MyCobot Pro 450 version is used as an example for demonstration. First, open the PyCharm you installed, create a new Python file, enter the following code, and import our library: from pymycobot import Pro450Client Note: If you enter from pymycobot import Pro450Client, there is no red wavy line under the font, which proves that it has been successfully installed and can be used. If a red wavy line appears, you can refer to How ​​to install the API library , How ​​to call the API library. If you do not want to install the API library through the above command, you can download the project to your local computer through the following github. First, go to the project address: https://github.com/elephantrobotics/pymycobot. Then click the Code button on the right side of the webpage, and then click Download ZIP to download it locally. Put the pymycobot folder in the compressed package pymycobot file project into your python dependency library directory, and you can directly import and use it. Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 Simple Demonstration import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication if pro450.is_power_on() !=1: pro450.power_on() # Power on print(pro450.get_angles()) # Read all joint angles pro450.send_angle(1, 90, 50) # Control J1 joint movement to 90 degrees at a speed of 50 ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/2_API.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/2_API.html","title":"6.1.2 APIDescription","keywords":"","body":"Pro 450 Python Socket API Preparing For Use Before using the Python API, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). For detailed configuration instructions, please refer to the section on Static IP Configuration. Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 DNS server: 114.114.114.114 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 API Usage Instructions API (Application Programming Interface), also known as Application Programming Interface functions, are predefined functions. When using the following function interfaces, please import our API library at the beginning by entering the following code, otherwise it will not run successfully: Note: Before use, please make sure that the MyCobot Pro 450 server is turned on and the PC and the robot are in the same network segment. # Example from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() !=1: mc.power_on() print(mc.get_angles()) 1. System Status get_system_version() function： get system version Return value： system version get_modified_version() function： Read the revision number, for internal use only Return value： Correction version number get_robot_type() function： Detection robot model Return value： Definition Rule: Actual machine model. For example, the MyCobot Pro 450 model is 4503 get_atom_version() function： Get the end version number Return value： End parameters(float) get_tool_modify_version() function： Read end correction version number Return value： end correction version 2. Overall Status power_on() Function: Starts the robot (power on) Return value: 1 - Power on successfully. 2 - Power on failed 0 - Power not on power_off() Function: Shuts down the robot (power off) Return value: 1 - Command received successfully. is_power_on() Function: Checks whether the robot is powered on Return value: 1: Power on successfully 0: Power not on 2: Power on failed is_init_calibration() function: Check if the robot is initialized for calibration Return value: bool: True if the robot is initialized for calibration, False otherwise get_fresh_mode() function: Query sports mode Return value: 0: Interpolation mode 1: Refresh mode set_fresh_mode() function: Set command refresh mode Parameters: 1: Always execute the latest command first. 0: Execute instructions sequentially in the form of a queue. get_debug_state() Function: Get the current robot's debug logging mode. Return value: int: Current debug logging state. 0: No debug logs 1: General debug log only (_debug.log) 2: Motion-related log only (_move.log) 3: General and motion-related logs (_debug.log + _move.log) 4: Motor read/control frequency log only (_clock_rate_debug.log) 5: General and motor frequency logs (_debug.log + _clock_rate_debug.log) 6: Motion and motor frequency logs (_move.log + _clock_rate_debug.log) 7: All logs set_debug_state(log_state) Function: Set the debug logging mode for the current robot. Parameters: log_state: int, debug log state (0 to 7) 0: Do not log any debug logs 1: General debug log only (_debug.log) 2: Motion-related log only (_move.log) 3: General and motion-related logs (_debug.log + _move.log) 4: Motor read/control frequency log only (_clock_rate_debug.log) 5: General and motor frequency logs (_debug.log + _clock_rate_debug.log) 6: Motion and motor frequency logs (_move.log + _clock_rate_debug.log) 7: Log all logs Return value: int 1 - Success 0 - Failure 1 - Error set_communication_mode(protocol_mode) Function: Sets the current robot Modbus communication mode. Parameters: protocol_mode: int 0 or 1 0: close Modbus protocol 1: open Modbus protocol Return value: int 1 - Success 0 - Failure 1 - Error get_communication_mode() Function: Gets the current robot communication mode. Return value: communication_mode: int 0 - Socket communication mode 1 - 485 communication mode protocol_mode: int 0: Custom protocol 1: Modbus protocol get_free_move_mode() Function: Reads the free movement mode Return Value: 0: Disables free movement mode 1: Enables free movement mode set_free_move_mode(mode) Function: Sets the free movement mode (only when free movement is enabled can the joint be released by holding down the end button) Parameters: 1: Enables free movement mode. 0: Disables free movement mode. 3.Robot Abnormal Control get_robot_status() Function: Read robot error and safety status Return Value: 0 - Normal. For example, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], Other - Robot abnormal [Joint collision, whether in motion, whether J1 exceeds limits, whether J2 exceeds limits, whether J3 exceeds limits, whether J4 exceeds limits, whether J5 exceeds limits, whether J6 exceeds limits, whether J1 has a motor hardware error, whether J2 has a motor hardware error, whether J3 has a motor hardware error, whether J4 has a motor hardware error, whether J5 has a motor hardware error, whether J6 has a motor hardware error, whether J1 has a software communication error, whether J2 has a software communication error, whether J3 has a software communication error, whether J4 has a software communication error, whether J5 has a software communication error, whether J6 has a software communication error] servo_restore(joint_id) function：Clear joint abnormalities Parameters： joint_id: int. joint id 1 - 6, 254-All joints restored. get_comm_error_counts(joint_id) function：Read the number of communication exceptions Parameters： joint_id: int. joint id 1 - 6 Return value: list A list of length 4, such as [0, 0, 0, 0], represents: [0]: Number of joint sending exceptions [1]: Number of joint reading exceptions [2]: Number of end-point sending exceptions [3]: Number of end-point sending exceptions get_error_information() Function: Read robot error information Return value: int 0: No error information 1-6: The corresponding joint exceeds the limit position. 32-36: Coordinate motion error. 32: No coordinate solution. Please check if the arm span is near the limit. 33: No adjacent solution for linear motion. 34: Velocity fusion error. 35: No adjacent solution for null space motion. 36: No solution for singular position. Please use joint control to leave the singular point. 81~86: Collision triggered at joints J1 to J6. Please use the resume interface to recover. clear_error_information() Function: Clear robot error information over_limit_return_zero() Function: Return to zero for a joint exceeding the limit get_motors_run_err() Function: Read motor error information during robot motion Return value: list, a list of 6, all zeros, indicating normal operation 4.MDI Mode And Operation set_control_mode(mode) Function: Set the robot motion mode Parameter: mode: int, 0 to 1, default 0 0: Position mode 1: Torque mode get_control_mode() Function: Get the robot motion mode Return value: 0: Position mode 1: Torque mode get_angles() function: get the degree of all joints Return value: list a float list of all degree get_angle() function: Get single joint angle Parameters： joint_id (int): 1 ~ 6 Return value: float, single joint angle send_angle(id, degree, speed) function: send one degree of joint to robot arm Parameters: id: Joint id(genre.Angle), range int 1-6 degree: degree value(float) | Joint Id | range | | ---- | ---- | | 1 | -162 ~ 162 | | 2 | -125 ~ 125 | | 3 | -154 ~ 154 | | 4 | -162 ~ 162 | | 5 | -162 ~ 162 | | 6 | -165 ~ 165 | speed：the speed and range of the robotic arm's movement 1~100 send_angles(angles, speed) function： Send all angles to all joints of the robotic arm Parameters: angles: a list of degree value(List[float]), length 6 speed: (int) 1 ~ 100 get_coords() function: Obtain robot arm coordinates from a base based coordinate system Return value: a float list of coord:[x, y, z, rx, ry, rz] send_coord(id, coord, speed) function: send one coord to robot arm Parameters: id:send one coord to robot arm, 1-6 corresponds to [x, y, z, rx, ry, rz] coord: coord value(float) | Coord Id | range | | ---- | ---- | | x | -474 ~ 474 | | y | -474 ~ 474 | | z | -180 ~ 677 | | rx | -180 ~ 180 | | ry | -180 ~ 180 | | rz | -180 ~ 180 | speed: (int) 1-100 send_coords(coords, speed, mode) function:: Send overall coordinates and posture to move the head of the robotic arm from its original point to your specified point Parameters: coords: ： a list of coords value [x,y,z,rx,ry,rz],length6 speed(int): 1 ~ 100 pause(deceleration=0) Function: Controls the core and stops all motion commands. Parameters: deceleration: Whether to decelerate and stop. The default value is 0. 1 indicates a deceleration. Return Value: 1 - stopped 0 - not stopped -1 - error is_paused() Function: Checks whether the program has paused a motion command. Return Value: 1 - paused 0 - not paused -1 - error resume() Function: Resume robot motion and complete the previous command. stop(deceleration=0) Function: Stops robot motion. Parameters: deceleration: Whether to decelerate and stop. Defaults to 0. 1 indicates a slow stop. Return Value: 1 - Stopped 0 - Not stopped -1 - Error is_in_position(data, flag) function : judge whether in the position. Parameters: data: Provide a set of data that can be angles or coordinate values. If the input angle length range is 7, and if the input coordinate value length range is 6 flag: data type (value range 0 or 1) 0: angle 1: coord Return value: 1 - true 0 - false -1 - error is_moving() function: judge whether the robot is moving Return value: 1 moving 0 not moving -1 error 5. JOG Mode And Operation jog_angle(joint_id, direction, speed) function: jog control angle Parameters: joint_id: Represents the joints of the robotic arm, represented by joint IDs ranging from 1 to 6 direction(int): To control the direction of movement of the robotic arm, input 0 as negative value movement and input 1 as positive value movement speed: 1 ~ 100 jog_coord(coord_id, direction, speed) function: jog control coord. Parameters: coord_id: (int) Coordinate range of the robotic arm: 1~6 direction:(int) To control the direction of machine arm movement, 0 - negative value movement, 1 - positive value movement speed: 1 ~ 100 jog_increment_angle(joint_id, increment, speed) function: Single joint angle increment control Parameters: joint_id: 1-6 increment: Incremental movement based on the current position angle speed: 1 ~ 100 jog_increment_coord(coord_id, increment, speed) function: Single joint angle increment control Parameters: joint_id: axis id 1 - 6. increment: Incremental movement based on the current position coord speed: 1 ~ 100 6. Speed/Acceleration Parameters get_max_speed(mode) Function: Get the maximum speed Parameters: mode : int 0: Angular speed 1: Coordinate speed Return value: Angular speed range: 1-150°/s, coordinate speed range: 1-200mm/s set_max_speed(mode, max_speed) Function: Set the maximum speed Parameters: mode : int 0: Angular speed 1: Coordinate speed max_speed: Angular speed range: 1-150°/s, coordinate speed range: 1-200mm/s get_max_acc(mode) Function: Get the maximum acceleration Parameters: mode : int 0: Angular acceleration 1: Coordinate acceleration Return value: Angular acceleration range 1 to 150°/s, coordinate acceleration range 1 to 400 mm/s set_max_acc(mode, max_acc) Function: Set maximum motion acceleration Parameters: mode : int 0: Angular acceleration 1: Coordinate acceleration max_acc: Angular acceleration range 1 to 150°/s, coordinate acceleration range 1 to 400 mm/s 7. Joint Software Limit Operation get_joint_min_angle(joint_id) function: Read the minimum joint angle Parameters: joint_id : Enter joint ID (range 1-6) Return value：float Angle value get_joint_max_angle(joint_id) function: Read the maximum joint angle Parameters: joint_id : Enter joint ID (range 1-6) Return value: float Angle value set_joint_min_angle(id, angle) function: Set minimum joint angle limit Parameters: id : Enter joint ID (range 1-6) angle: Refer to the limit information of the corresponding joint in the send_angle() interface, which must not be less than the minimum value set_joint_max_angle(id, angle) function: Set minimum joint angle limit Parameters: id : Enter joint ID (range 1-6) angle: Refer to the limit information of the corresponding joint in the send_angle() interface, which must not be greater than the maximum value 8. Joint Motor Auxiliary Control get_servo_encoders() function：Read the full joint encoder value Return value： A list of length 6 set_servo_calibration(servo_id) function: The current position of the calibration joint actuator is the angle zero point Parameters: servo_id: 1 - 6 set_break（joint_id, value） function: Set break point Parameters： joint_id: int. joint id 1 - 6 value: int. 0 - disable, 1 - enable Return value: 0 : faile; 1 : success set_motor_enabled(joint_id, state function: Set the robot torque state.(Release joint interface) Parameters： joint_id: int. joint id 1 - 6, 254-all joints state: int. 0 - disable, 1 - enable 9. Drag Teach drag_teach_save() Function: Start recording and dragging the teach point. Note: For optimal motion performance, the recording time should not exceed 120 seconds. drag_teach_pause() Function: Pause drag teaching drag_teach_execute() Function: Start dragging the teach point. Execute only once. drag_teach_clean() Function: Clear the sampling point. 10. Dynamics get_collision_mode() Function: Query the collision detection mode Return value: 0: Off 1: On set_collision_mode(mode) Function: Set the joint collision detection mode Parameter: int mode: 0: Off 1: On set_collision_threshold(joint_id, threshold_value=100) Function: Sets joint collision detection Parameters: mode: int Joint ID, range 1 ~ 6 threshold_value: int Collision threshold, range 50 ~ 250, default value is 100. The smaller the value, the easier it is to trigger a collision. get_collision_threshold() Function: Get the joint collision threshold Return value: A list of all joint collision thresholds set_torque_comp(joint_id, damping, comp_value=0) Function: Set the torque compensation coefficient Parameter: joint_id int: Joint ID, range 1 to 6 damping int: Range 0 ~ 1. 1 - On, 0 - Off comp_value: Compensation value, range 0-250, default 100. Smaller values ​​result in more difficult joint dragging. get_torque_comp() Function: Get torque compensation coefficients Return value: A list of torque compensation coefficients for all joints fourier_trajectories(trajectory) Function: Execute dynamic identification trajectory Parameter: trajectory: int, range 0-1 parameter_identify() Function: Kinetic parameter identification 11. Circular Motion write_move_c(transpoint, endpoint, speed) Function: Circular arc motion (specify transit points) Parameter: transpoint(list): Arc transit points endpoint(list): Arc endpoint speed(int): 1 to 100 12. Run Auxiliary Information get_zero_pos() function: Read the zero encoder value Return value: listThe value of the zero encoder for seven joints get_servo_speeds() function：Get the movement speed of all joints Return value： unit step/s get_servo_currents() function：Get the movement current of all joints Return value： 0 ~ 5000 mA get_servo_status() function：Get the movement status of all joints Return value： a value of 0 means no error 13. Robotic Arm End IO Control set_digital_output(pin_no, pin_signal) Function: Set terminal IO status Parameters pin_no (int): Pin number, range 1 to 2 pin_signal (int): 0 / 1, 0 - low level, 1 - high level Return Value: 1: Completed get_digital_input(pin_no) Function: Get terminal IO status Parameters: pin_no (int), range 1 to 2 Return Value: int 0 / 1, 0 - low level, 1 - high level get_digital_inputs() Function: Reads the status of all pins at the end, including: IN1, IN2, Button 1 (right side), and Button 2 (Button 2 is closer to the emergency stop button, located on the left side). Return Value: list[int] 0 / 1, 0 - low level, 1 - high level. e.g., [0, 0, 1, 0] represents button 1 being pressed. 14. End Light Panel Function set_color(r, g, b) Function: Set the color of the end light of the robot arm Parameter: r (int): 0 to 255 g (int): 0 to 255 b (int): 0 to 255 15. Bottom IO Control set_base_io_output(pin_no, pin_signal) function：Set Base IO Output Parameters： pin_no (int) Pin port number, range 1 ~ 12 pin_signal (int): 0 - low. 1 - high get_base_io_output(pin_no) function: Read base IO input Parameters: pin_no (int) pin number, range 1 ~ 12 Return value: 0 - low. 1 - high set_base_external_config(communicate_mode, baud_rate, timeout) Function: Set the bottom external device configuration Parameter: communicate_mode (int) Range: 1 to 2 1: 485 2: can baud_rate (int): Baud rate timeout: (int) Timeout period, in milliseconds get_base_external_config() Function: Read the bottom external device configuration Return value: list returns a list: [communication mode, baud rate, timeout] base_external_can_control(can_id, can_data) Function: Controls CAN devices on the bottom Parameters: can_id (int) Range: 1 to 4 can_data (list) List contents are in hexadecimal format, with a maximum length of 64 characters. base_external_485_control(data) Function: Controls 485 devices on the bottom Parameters: data (list) List contents are in hexadecimal format, with a maximum length of 64 characters. 16. Set Up 485 Communication At The End Of The Robotic Arm tool_serial_write_data(command) function: End 485 sends data， Data length range is 1 ~ 45 bytes Parameters： command (list): Data instructions in modbus format Return value: Modbus data list flash_tool_firmware(main_version, modified_version=0) Function: Flash the terminal firmware Parameters: main_version (str): Major and minor version numbers, e.g. 1.1 modified_version (int): Modified version number, range 0 to 255, default is 0 set_tool_serial_baud_rate(baud_rate=115200) Function: Sets the terminal 485 baud rate, default 115200 Parameter: baud_rate (int): Standard baud rate, only supports 115200 and 1000000 Return Value: 1 set_tool_serial_timeout(timeout=10000) Function: Sets the terminal 485 timeout, default 10 seconds Parameter: timeout (int): Timeout duration, in milliseconds, range 1 ~ 10000 Return Value: 1 get_tool_config() Function: Retrieves the terminal 485 baud rate and timeout duration Return Value: (list) A list containing baud rates and timeout durations, e.g., [baud rate, timeout duration] 17. Tool Coordinate System Operations set_tool_reference(coords) Function: Set the tool coordinate system Parameters: coords: (list) [x, y, z, rx, ry, rz]. | Coord Id | range | | ---- | ---- | | x | -1000 ~ 1000 | | y | -1000 ~ 1000 | | z | -1000 ~ 1000 | | rx | -180 ~ 180 | | ry | -180 ~ 180 | | rz | -180 ~ 180 | get_tool_reference(coords) Function: Get the tool coordinate system Return value: (list) [x, y, z, rx, ry, rz] set_world_reference(coords) Function: Set the world coordinate system Parameters: coords: (list) [x, y, z, rx, ry, rz]. | Coord Id | range | | ---- | ---- | | x | -1000 ~ 1000 | | y | -1000 ~ 1000 | | z | -1000 ~ 1000 | | rx | -180 ~ 180 | | ry | -180 ~ 180 | | rz | -180 ~ 180 | get_world_reference() Function: Get the world coordinate system. Return value: list [x, y, z, rx, ry, rz]. set_reference_frame(rftype) Function: Set the base coordinate system Parameters: rftype: 0 - Base coordinates (default), 1 - World coordinates. get_reference_frame() Function: Get the base coordinate system Return value: (list`) [x, y, z, rx, ry, rz]. set_movement_type(move_type) Function: Set the movement type Parameters: move_type: 1 - moveL, 0 - moveJ. get_movement_type() Function: Get the movement type Return value: 1 - moveL 0 - moveJ set_end_type(end) Function: Set the end coordinate system Parameters: end (int): 0 - Flange (default), 1 - Tool get_end_type() Function: Get the end coordinate system Return value: 0 - Flange (default) 1 - Tool 18. Algorithm Parameters get_model_direction() Function: Get the joint model direction Return value: Model direction of joints 1-6 1 - Same direction as the motor 0 - Opposite direction from the motor set_model_direction(joint_id, direction) Function: Set the joint model direction Parameters: joint_id (int): 1 to 6 direction (int): 1 - Same direction as the motor. 0 - Opposite direction from the motor get_filter_len(rank) Function: Get filter parameters Parameters: rank: int 1: Drag teach sampling filter 2: Drag teach execution filter 3: Joint velocity fusion filter 4: Coordinate velocity fusion filter 5: Drag teach sampling period Return value: int 1 to 255 set_filter_len(rank, value) Function: Set filter parameters Parameters: rank (int): 1 to 5 1: Drag teach sampling filter 2: Drag teach execution filter 3: Joint velocity fusion filter 4: Coordinate velocity fusion filter 5: Drag teach sampling period value (int): 1 to 255 get_fusion_parameters(rank_mode) Function: Get velocity fusion planning parameters Parameters: rank_mode: 1 to 4 1: Fusion joint velocity 2: Fusion joint acceleration 3: Fusion coordinate velocity 4: Fusion coordinate acceleration Return value: (int): 0 to 1000 set_fusion_parameters(rank_mode, value) Function: Set velocity fusion planning parameters Parameters: rank_mode (int): 1 to 4 value (int): 0 to 1000 19. Kinematics Algorithm Interface solve_inv_kinematics(target_coords, current_angles) Function: Convert coordinates to angles. Parameters target_coords: list A list of floating-point values ​​for all coordinates. current_angles: list A list of floating-point values ​​for all angles, indicating the current angles of the robot arm. Return Value: list A list of floating-point values ​​for all angles. 20. Pro Force-controlled Gripper get_pro_gripper_firmware_version( gripper_id=14) Function: Read the major and minor versions of the Pro Force Control Gripper firmware. Parameter: gripper_id (int): Gripper ID, default is 14, value range is 1 to 254. Return value: (float) Version number, x.x get_pro_gripper_firmware_modified_version(gripper_id=14) Function: Read the modified version of the Pro Force Control Gripper firmware. Parameter: gripper_id (int): Gripper ID, default is 14, value range is 1 to 254. Return value: (int) Correction version number set_pro_gripper_id(target_id, gripper_id=14) Function: Set the force-controlled gripper ID. Parameter: target_id (int): Range: 1 to 254. gripper_id (int): Gripper ID, default: 14, range: 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_id(gripper_id=14) Function: Read the force-controlled gripper ID. Parameter: gripper_id (int): Gripper ID, default: 14, range: 1 to 254. Return value: int Range: 1 to 254. set_pro_gripper_angle(gripper_angle，gripper_id=14) Function: Set the force-controlled gripper angle. Parameter: gripper_angle (int): Gripper angle, value range 0 ~ 100. gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_angle(gripper_id=14) Function: Read the angle of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: int 0 ~ 100 set_pro_gripper_open(gripper_id=14) Function: Open the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success set_pro_gripper_close(gripper_id=14) Function: Close the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success set_pro_gripper_calibration(gripper_id=14) Function: Set the zero position of the force-controlled gripper. (The zero position needs to be set first when using it for the first time) Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_status(gripper_id=14) Function: Read the gripping status of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Moving. 1 - Stopped moving, no object was detected. 2 - Stopped moving, object was detected. 3 - After the object was detected, it fell. set_pro_gripper_enabled(state, gripper_id=14) Function: Sets the force-controlled gripper enable state. Parameter: state (bool): 0 or 1, 0 - disable, 1 - enable gripper_id (int): Gripper ID, default 14, range 1 to 254. Return Value: 0 - Failure 1 - Success set_pro_gripper_torque(torque_value，gripper_id=14) Function: Set the torque of the force-controlled gripper. Parameter: torque_value (int): Torque value, value range 0 ~ 100. gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_torque(gripper_id=14) Function: Read the torque of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: (int) 0 ~ 100 set_pro_gripper_speed(speed，gripper_id=14) Function: Set the force-controlled gripper speed. Parameter: speed (int): Gripper movement speed, value range 1 ~ 100. gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success get_pro_gripper_speed(speed，gripper_id=14) Function: Read the speed of the force-controlled gripper. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return value: Gripper default movement speed, range 1 ~ 100. set_pro_gripper_abs_angle(gripper_angle，gripper_id=14) Function: Set the absolute angle of the force-controlled gripper. Parameter: gripper_angle (int): Gripper angle, value range 0 ~ 100. gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failed 1 - Success set_pro_gripper_io_open_angle(gripper_angle, gripper_id=14) Function: Sets the force-controlled gripper I/O opening angle. Parameter: gripper_angle (int): Gripper angle, value range 0 to 100. gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return Value: 0 - Failure 1 - Success get_pro_gripper_io_open_angle(gripper_id=14) Function: Reads the force-controlled gripper I/O opening angle. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return value: int 0 to 100 set_pro_gripper_io_close_angle(gripper_angle, gripper_id=14) Function: Sets the force-controlled gripper IO closing angle. Parameter: gripper_angle (int): Gripper angle, value range 0 to 100. gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_io_close_angle(gripper_id=14) Function: Read the force-controlled gripper IO closing angle. Parameter: gripper_id (int): Gripper ID, default 14, value range 1 to 254. Return value: int 0 to 100 set_pro_gripper_mini_pressure(pressure_value, gripper_id=14) Function: Set the minimum actuation force of the force-controlled gripper Parameter: pressure_value (int): Actuation force value, range 0 to 254. gripper_id (int): Gripper ID, default 14, range 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_mini_pressure(gripper_id=14) Function: Read the minimum actuation force of the force-controlled gripper Parameter: gripper_id (int): Gripper ID, default 14, range 1 to 254. Return value: (int) Starting force value, range 0 to 254. set_pro_gripper_protection_current(current_value, gripper_id=14) Function: Set the gripping current of the force-controlled gripper Parameter: current_value (int): Gripping current value, range 100 to 300. gripper_id (int) Gripper ID, default 14, range 1 to 254. Return value: 0 - Failure 1 - Success get_pro_gripper_protection_current(gripper_id=14) Function: Read the gripping current of the force-controlled gripper Parameter: gripper_id (int) Gripper ID, default 14, range 1 to 254. Return value: (int) Clamping current value, range 100 ~ 300. set_pro_gripper_baud(baud_rate=0, gripper_id=14) Function: Sets the baud rate of the force control gripper Parameters: baud_rate (int): Baud rate index, range 0 ~ 1, default 0 - 115200 0 - 115200 1 - 1000000 gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return Value: 0 - Failure 1 - Success get_pro_gripper_baud(gripper_id=14) Function: Reads the baud rate of the force control gripper Parameters: gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return Value: (int) Baud rate index, default 0 - 115200 0 - 115200 1 - 1000000 set_pro_gripper_modbus(state, custom_mode=False, gripper_id=14) Function: Sets the force control gripper's Modbus communication mode Parameters: state (int): Range 0 ~ 1. 0: Disables Modbus communication mode, enables custom communication mode 1: Enables Modbus communication mode, disables custom communication mode custom_mode (bool): Custom communication mode identifier, default False (currently in Modbus mode). If the current communication mode is custom, to enable Modbus communication mode, you need to change custom_mode to True. For example: set_pro_gripper_modbus(1, True) gripper_id (int) Gripper ID, default 14, value range 1 ~ 254. Return value: 0 - Failure 1 - Success set_pro_gripper_init(gripper_id=14) Function: Initializes the gripper, restoring it to Modbus mode at 115200 baud rate. Parameters: gripper_id (int): Gripper ID, default 14, value range 1 ~ 254. Return Value: (bool) True - Success False - Failure "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/3_angle.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/3_angle.html","title":"6.1.3 JointControl","keywords":"","body":"Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). For detailed configuration instructions, please refer to the section on Static IP Configuration. Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 DNS server: 114.114.114.114 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 Joint Control For serial multi-joint robots, the control of joint space is to control the variables of each joint of the robot, and the goal is to make each joint of the robot reach the target position at a certain speed. Note: When setting the angle, the limit of different series of robot arms is different. For details, please refer to the parameter introduction of the corresponding model. Example Use import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication if pro450.is_power_on() !=1: pro450.power_on() # Power on print(pro450.get_angles()) # Read all joint angle information pro450.send_angles([0, 0, 0, 0, 0, 0], 50) # Send all joint angles, speed is 50, so that all joints of the robot arm move to zero position time.sleep(3) pro450.send_angle(1, 90, 50) # Send single joint angle, speed is 50, so that J1 joint moves to 90 degrees time.sleep(2) pro450.send_angles([0, -10, -123, 45, 0, 90], 50) # Send all joint angles, speed 50 time.sleep(3) ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/4_coord.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/4_coord.html","title":"6.1.4 CoordinateControl","keywords":"","body":"Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). For detailed configuration instructions, please refer to the section on Static IP Configuration. Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 DNS server: 114.114.114.114 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 Coordinate Control It is mainly used to realize intelligent route planning to let the robot arm move from one position to another specified position. It is divided into [x, y, z, rx, ry, rz], where [x, y, z] represents the position of the robot head in space (the coordinate system is the rectangular coordinate system), and [rx, ry, rz] represents the posture of the robot head at this point (the coordinate system is the Euler coordinate system). The implementation of the algorithm and the representation of Euler coordinates require certain academic knowledge. We will not explain it too much here. As long as we understand the rectangular coordinate system, we can use this function well. Note: When setting coordinates, different series of robot arm joint structures are different. For the same set of coordinates, different series of robot arms will show different postures. Example Use import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication if pro450.is_power_on() !=1: pro450.power_on() # Power on print(pro450.get_coords()) # Read coordinate attitude information pro450.send_angles([0, -10, -123, 45, 0, 0], 50) # Send angular motion to a certain attitude for coordinate control, speed is 50 time.sleep(3) pro450.send_coord(1, 200, 50) # Send single coordinate control, speed is 50, so that the X axis moves to the position of 200mm time.sleep(2) pro450.send_coords([300, 86.8, 256.9, -178.0, 0.0, -90.0], 50) # Send multi-coordinate control, speed is 50 time.sleep(3) ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/5_IO.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/5_IO.html","title":"6.1.5 IOControl","keywords":"","body":"Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). For detailed configuration instructions, please refer to the section on Static IP Configuration. Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 DNS server: 114.114.114.114 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 IO Control IO stands for data input and output. Our robot arm's Basic and Atom pins have multiple pins. This section mainly explains how to use the end-point IO to control the gripper. Example Use import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection and communication if pro450.is_power_on() !=1: pro450.power_on() # Power on # Open the gripper def open_gripper(): pro450.set_digital_output(1, 0) # Set pin 1 to a low level pro450.set_digital_output(2, 1) # Set pin 2 to a high level time.sleep(0.05) # Close the gripper def close_gripper(): pro450.set_digital_output(1, 1) # Set pin 1 to a high level pro450.set_digital_output(2, 0) # Set pin 2 to a low level time.sleep(0.05) # Repeat the gripper opening and closing twice for i in range(2): open_gripper() time.sleep(3) close_gripper() ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/6_gripper.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/6_gripper.html","title":"6.1.6 GripperControl","keywords":"","body":"Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). For detailed configuration instructions, please refer to the section on Static IP Configuration. Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 DNS server: 114.114.114.114 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 Gripper Control Before using Python to control the gripper, you must first install and connect the gripper to the robotic arm. Different grippers are compatible with different robotic arms. Here, we use the myGripper F100 Pro force-controlled gripper. Note: Before use, ensure that the communication mode on the gripper's small screen is set to Modbus mode; otherwise, the gripper will not function properly. Refer to Gripper Screen Control Example Use import time from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) # Client connection communication if pro450.is_power_on() !=1: pro450.power_on() # Power on print(pro450.get_pro_gripper_firmware_version()) # Read the major and minor version numbers of the gripper time.sleep(1) print(pro450.get_pro_gripper_angle()) # Read the gripper angle information time.sleep(1) pro450.set_pro_gripper_angle(50) # Set the gripper angle to 50 time.sleep(2) pro450.set_pro_gripper_speed(70) # Set the gripper speed to 70 time.sleep(1) pro450.set_pro_gripper_open() # Set the gripper to fully open time.sleep(2) pro450.set_pro_gripper_close() # Set the gripper to fully close time.sleep(2) ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.1-python/7_exception_description.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.1-python/7_exception_description.html","title":"6.1.7 RobotExceptionHandling","keywords":"","body":"Checking And Handling Robot Arm Exceptions When the robot arm fails to execute a motion command, you can query the corresponding exception information in the Python terminal, for example. Reading Robot Status Status Feedback Analysis Under normal circumstances, this interface returns all 0s. Reading the robot status is as follows: from pymycobot import Pro450Client # The default IP address is \"192.168.0.232\" and the default port number is 4500 pro450 = Pro450Client('192.168.0.232', 4500) if pro450.is_power_on() !=1: pro450.power_on() # Power on pro450.get_robot_status() # Reading Robot Status Return: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] Indicates the robot is not moving, no joints are exceeding limits, no joint hardware errors, and no joint software errors. A complete explanation of each value is as follows: [joint collision, Whether Moving, Whether J1 Exceeds Limits, Whether J2 Exceeds Limits, Whether J3 Exceeds Limits, Whether J4 Exceeds Limits, Whether J5 Exceeds Limits, Whether J6 Exceeds Limits, Whether J1 Motor Hardware Error, Whether J2 Motor Hardware Error, Whether J3 Motor Hardware Error, Whether J4 Motor Hardware Error, Whether J5 Motor Hardware Error, Whether J6 Motor Hardware Error, Whether J1 Software Communication Error, Whether J2 Software Communication Error, Whether J3 Software Communication Error, Whether J4 Software Communication Error, Whether J5 Software Communication Error, Whether J6 Software Communication Error] The following example is as follows: [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0] This indicates that the robot reported an error during movement, with J4 reporting a control error. [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] This indicates that robot J2 exceeded the limit. [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0] Indicates that the robot's J5 line is abnormal - receiving an error Exception Resolution Joint Out Of Limit When a joint exceeds the limit, use one of the following solutions: Execute the over-limit return to zero interface: pro450.over_limit_return_zero() #The robot will return to the origin at a slower speed Execute joint relaxation and manually move the joint to within the limit pro450.set_motor_enable(254, 0) Joint Hardware Error Most hardware errors can be recovered using exception recovery. pro450.servo_restore(joint_id) If this problem persists after using exception recovery or restarting the robot, please contact our engineers. Detailed information about the hardware errors for each joint is shown: Bit (2 bytes) Error Status 0 CAN bus error. Exception recovery possible. If recovery is not possible, check the communication line, repair it, and then power on again. 1 Short circuit. Exception recovery possible. 2 Invalid setting data 3 Control error. Exception recovery possible. 4 CAN communication error. Exception recovery possible. If recovery is not possible, check the communication line, repair it, and then power on again. 5 Feedback error. Exception recovery possible. 6 Positive limit switch active. 7 Negative limit switch active. 8 Negative limit switch active. 9 Overcurrent. Exception recovery possible. 10 12t protection. Exception recovery possible. Overtemperature. Exception recovery possible. 11 Driver board overtemperature. Exception recovery possible. 12 Overvoltage. Exception recovery possible. 13 Undervoltage, exception recovery possible 14 Command error 15 Enable inactive Joint Software Errors Software error feedback mainly includes: circuit abnormalities, CAN module abnormalities, encoder abnormalities, and enable failure. If the enable failure occurs, use pro450.set_motor_enable(254, 1) to enable motion again. For other abnormalities, please contact our engineers. Detailed joint software error information is shown: Bit (1 byte) Error Status 1 - Abnormal 0 - Normal 0 CAN initialization error. Check the main control board. After repairing the control board error, power cycle. Symptoms: The machine cannot be enabled or controlled. 1 Motor initialization error. Check the motor communication circuit. After repairing the error, power cycle. Symptoms: The machine cannot properly feedback joint information or control. 2 Motor transmission error. Check the motor communication circuit. Symptoms: Machine position feedback error. Can be cleared using error recovery. 3 Motor reception error. Check the motor communication circuit. Symptoms: Machine position feedback error. Can be cleared using error recovery. This feedback allows normal machine control and does not require user notification. It is mainly used for troubleshooting. 4 Position error. Check the motor encoder. Symptoms: The machine is disabled and motion control is impossible. Can be cleared using error recovery. 5 Terminal transmission error. Check the terminal communication line, etc. Symptom: Terminal interface feedback error. Can be cleared using error recovery. 6 Terminal reception error. Check the terminal communication line, etc. Symptom: Terminal interface feedback error. Can be cleared using error recovery. This feedback allows normal machine control without prompting the user and is primarily used for troubleshooting. 7 Motor encoder error. When the encoder reports an error, movement is disabled. Clear the encoder error. Older motor driver boards do not report errors—even if an encoder error is reported, the software does not report the error. How to distinguish newer boards: The board with the battery is a new driver board. 8 Feedback will be generated when the enable is turned off. The machine must be enabled before movement. The robot is in motion and cannot move. The robot is in motion and does not respond when you send a motion point. Please stop the robot by executing pro450.stop() and pro450.resume(). If the robot still cannot move, please contact our engineers. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/","title":"6.2 ROS1","keywords":"","body":"ROS ROS is an open-source, post-operating system (ROS), or secondary operating system, for robotic control. It provides operating system-like functionality, including hardware abstraction, low-level driver management, execution of shared functions, inter-program messaging, and package management. It also provides tools and libraries for acquiring, building, writing, and running multi-machine integrated programs. The ROS runtime \"graph\" is a network of loosely coupled peer-to-peer processes based on the ROS communication infrastructure. ROS implements several different communication methods, including a service mechanism for synchronous RPC-style communication, a topic mechanism for asynchronous streaming data, and a parameter server for data storage. ROS is not a real-time framework, but it can be embedded in real-time programs. Willow Garage's PR2 robot uses a system called pr2_etherCAT to send and receive ROS messages in real time. ROS also integrates seamlessly with the Orocos Real-Time Toolkit. ROS Logo: 1 Design Goals And Features Of ROS Many people ask, \"What's the difference between ROS and other robotics software platforms?\" This question is difficult to answer. ROS isn't a framework that integrates most functions or features. In fact, its primary goal is to support code reuse in robotics development. ROS is a framework for distributed processes (i.e., nodes), which are encapsulated in programs and function packages and can be easily shared and distributed. ROS also supports a federated system similar to a code repository, which facilitates collaboration and distribution of projects. This design allows for complete independence in project development and implementation, from file systems to user interfaces (ROS has no limitations). Furthermore, all projects can be integrated with ROS's basic tools. To support its primary goals of sharing and collaboration, the ROS framework also has several other features: Streamlined: ROS is designed to be as streamlined as possible, which makes it easier for ROS to The code written can be used with other robotics software frameworks. Consequently, ROS can be easily integrated into other robotics software platforms: ROS has already been integrated with OpenRAVE, Orocos, and Player. ROS-independent libraries: The preferred development model for ROS is to write concise library functions that do not depend on ROS. Language independence: The ROS framework can be easily implemented in any modern programming language. ROS has been implemented in Python, C++, and Lisp. Experimental libraries are also available in Java and Lua. Loose coupling: Functional modules in ROS are encapsulated in independent packages or metapackages, making them easy to share. Modules in a package run on a per-node basis. Using ROS standard IO as an interface, developers do not need to worry about the internal implementation of modules. As long as they understand the interface rules, they can reuse modules and achieve point-to-point loose coupling. Convenient testing: ROS has a built-in unit/integration testing framework called rostest, which makes it easy to install and uninstall test modules. Extensible: ROS Suitable for large-scale operating systems and development processes. Free and open source: It has many developers and feature packages. 2 Why use ROS? ROS allows us to simulate and control a robotic arm in a virtual environment. We will use rviz to visualize the robotic arm, manipulate it in various ways, and MoveIt to plan and execute its motion paths, achieving free control of the robotic arm. In the following chapters, we will learn how to control our product using the ROS platform. MoveIt MoveIt is currently the most advanced robotic arm motion manipulation software, used in over 100 robots. It integrates the latest advances in motion planning, control, 3D perception, motion control, control, and navigation, providing an easy-to-use platform for developing advanced robotic applications and an integrated software platform for the design, integration, and evaluation of new robotics products in industry, commerce, R&D, and other fields. MoveIt Logo : 1 Description MoveIt is a ROS integrated development platform consisting of various functional packages for manipulating robotic arms, including motion planning, manipulation, control, inverse kinematics, 3D perception, collision detection, and more. The following figure shows the high-level structure of the main node move_group provided by MoveIt. It acts as a combiner: it brings together all the individual components to provide users with a range of operations and services. 2 User Interface Users can access the operations and services provided by move_group in three ways: In C++, using the move_group_interface package makes it easy to use move_group. In Python, using the moveit_commander package. Through a graphical user interface: using Rviz (a ROS visualization tool) with Motion-commander. move_group can be configured through the ROS parameter server and can also retrieve the robot's URDF and SRDF from the server. 3 Configuration move_group is a ROS node. It uses the ROS parameter server to obtain three types of information: URDF - move_group looks for the robot_description parameter in the ROS parameter server to obtain the robot's URDF. SRDF - move_group looks for the robot_description_semantic parameter in the ROS parameter server to obtain the robot's SRDF. The SRDF is typically created by the user using the MoveIt Setup Assistant. MoveIt configuration - move_group will look for additional MoveIt-specific configuration in the ROS parameter server, including information about joint constraints, kinematics, motion planning, perception, and more. Configuration files for these components are automatically generated by the MoveIt Setup Assistant and stored in the configuration directory of the robot's corresponding MoveIt configuration package. For more information on using the setup assistant, see: MoveIt Setup Assistant ← Previous Chapter | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.1-Environment_Setup.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.1-Environment_Setup.html","title":"6.2.1 EnvironmentSetup","keywords":"","body":"ROS1 Environment Setup This tutorial provides two methods for setting up an Ubuntu 20.04 + ROS1 development environment: Method 1: Importing a Virtual Machine Image (Recommended) → Quickest way to get started, with a complete built-in environment Method 2: Customizing the Installation Environment → Building from scratch, suitable for users who require flexible customization Method 1: Importing A Virtual Machine Image Recommended: This is the quickest method and suitable for beginners. Note: To simplify environment setup, we will provide a Linux system image (Ubuntu 20.04), the Virtual Box installation package, and its extensions. The following instructions will show you how to install Virtual Box and import the Linux system image (the default user is u202, and the default password is 123). Built-in Environment: ROS1 + Moveit + Git + pymycobot + mycobot_ros 1 Install Virtual Machine Go to official website to download virtual machine Virtual Box VirtualBox installation package: Windows hosts VirtualBox expansion package: VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack For instructions on installing VirtualBox extension packs, please refer to: Extension Pack Installation Tutorial Of course, if you already have your virtual machine, you can skip this step. We chose to download Virtual box because it is free. 2 Download Linux System Image Click to download: Linux ubuntu20.04 3 Import Linux System Image In the Virtual Box interface, click Management -> Import Virtual Computer -> Select Virtual Image -> Select the installation path and import it, and then install it as follows. Just wait for the image to be imported. The installation is successful as shown below. Then start the system, the user name is u202, the default password is 123 4 Update Pymycobot To use the latest robotics driver library, open a terminal and execute the following command: pip3 install pymycobot --upgrade 5 Update Mycobot_ros To ensure users have the latest official packages, navigate to the /home/u202/catkin_ws/src folder through a file manager, open a console terminal (shortcut Ctrl+Alt+T), and enter the following command to update: # Clone the code from GitHub cd ~/catkin_ws/src # Delete the original mycobot_ros package sudo rm -rf mycobot_ros git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros.git cd .. # Return to the workspace catkin_make # Build the code in the workspace source devel/setup.bash # Add environment variables Method 2: Customize The Installation Environment 1 Virtual Machine Installation Go to the official website to download the virtual machine Virtual Box VirtualBox installation package: Windows hosts VirtualBox expansion package: VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack For instructions on installing VirtualBox extension packs, please refer to: Extension Pack Installation Tutorial Of course, if you already have your virtual machine, you can skip this step. We chose to download Virtual box because it is free. 2 Create A Virtual Machine Select New in the control Enter the virtual machine name and the location where the virtual machine is stored, select the virtual machine type as Linux, select Ubuntu 64-bit version, and proceed to the next step. Configure the memory size according to your needs and proceed to the next step. Select Create a virtual hard disk now and create it. Select the VDI type for the virtual hard disk type and proceed to the next step. Allocate the size of the virtual hard disk. Since you need to install the Ubuntu system and will also operate in the system, it is recommended that the size should not be less than 20G. 3 Download Ubuntu System. Please choose the Ubuntu version to install according to your needs, the default version is Ubuntu 20.04. Note: ROS2 needs to download 20.04 version. 20.04 version The installation method and process of each version are the same. Here we use the 18.04 version as an example After downloading, there is a file as shown in the figure: 4 Import Ubuntu Into The Virtual Machine Find the previously installed virtual machine in Virtual Box, enter Settings, and assign the CD to the controller in Storage: Then open the virtual machine to install Ubuntu and click Start. 5 Ubuntu Installation Wait for the system to start, enter the Welcome interface, select \"English\", and click the \"Install Ubuntu\" button; Click the \"Continue\" button; Select the \"Erase the entire disk and install Ubuntu\" option, and click the \"Install Now\" button; Click the \"Continue\" button in the pop-up dialog box; Set the geographic location and click the \"Continue\" button; Set the user name and password and click the \"Continue\" button; Enter the system installation interface, please wait patiently; After the installation is complete, in the pop-up dialog box, click the \"Restart Now\" button to complete the installation. 6 ROS Installation The basic development environment setup requires the installation of the robot operating system ROS, MoveIt, and git version manager. The following describes their installation methods and processes. For myCobot Pro 450 devices, please refer to the installation methods and processes described below. Here we choose Ubuntu 20.04, and the corresponding ROS version is ROS Melodic NOTE: We currently do not provide any reference for installing ROS on Windows. If necessary, please refer to https://www.ros.org/install/ 6.1 Start Installation 1 Add Source There is no ROS software source in the software source list of Ubuntu itself, so you need to configure the ROS software source to the software list warehouse before you can download ROS. Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command: Official source: sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' If the download speed is slow, it is recommended to select a mirror source nearby to replace the above command. For example, Tsinghua University is: sudo sh -c '. /etc/lsb-release && echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main\" > /etc/apt/sources.list.d/ros-latest.list' You will be asked to enter the user password here. Just enter the user password you set when installing Ubuntu. 2 Set Up The Secret Key Configure the public network secret key. This step is to let the system confirm that our path is safe, so that there is no problem downloading the file, otherwise it will be deleted immediately after downloading: sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 The execution results are shown below:： 3 Installation After adding a new software source, you need to update the software source list, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command: sudo apt-get update Execute Install ROS, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command according to your Ubuntu version: # Ubuntu 20.04 sudo apt install ros-noetic-desktop-full It is recommended to install the complete ROS to prevent missing libraries and dependencies. The installation process takes a long time, please be patient If the following error message appears in the console terminal during the installation, you need to change the software source list in /etc/apt/sources.list. Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command: sudo gedit /etc/apt/sources.list Replace all official software sources in sources.list with the following Alibaba Cloud software sources: Ubuntu 20.04： deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse After the configuration is complete, the contents of the sources.list file are as follows. Click Save and Exit. Update the software source list and enter in the console terminal: sudo apt-get update Enter the command to install ROS in the console terminal: # Ubuntu 20.04 sudo apt install ros-noetic-desktop-full The installation process takes a long time, please wait patiently 4 Configure ROS Environment To The System rosdep allows you to easily install the source code you want to compile or the system dependencies required by some ROS core components. Execute the following commands in the terminal in sequence to open a console terminal (shortcut key Ctrl+Alt+T). If rosdep is not installed on your system, please use the command sudo apt install python-rosdep to install it. If your installed Ubuntu system is version 20.04, please use the command sudo apt install python3-rosdep to install it, and execute the rosdep initialization command after completion. --> Initialize rosdep: sudo rosdep init If the error message shown below appears: Solution: Modify the hosts file and enter the following command in the console terminal: sudo gedit /etc/hosts At the end of the file content, add the IP addresses of the following two websites to access: 199.232.28.133 raw.githubusercontent.com 151.101.228.133 raw.github.com After the modification is completed, execute in the console terminal: sudo rosdep init rosdep update After initialization is completed, in order to avoid the need to re-validate the ROS function path every time the terminal window is closed, we can configure the path to the environment variable, so that the ROS function path can be automatically validated every time a new terminal is opened. Execute the following commands in the terminal in sequence to open a console terminal (shortcut key Ctrl+Alt+T): 6.2 Set Up The Ros Environment Execute the following command: # Ubuntu 20.04 echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrc source ~/.bashrc 6.3 Install ROS Additional Dependencies Enter the following command in the terminal to install ROS additional dependencies and open a console terminal (shortcut key Ctrl+Alt+T): sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential # Ubuntu 20.04 sudo apt install ros-noetic-joint-state-publisher-gui 6.4 Verify The Installation The startup of the ROS system requires a ROS Master, i.e., a node manager. We can start the ROS Master by entering the roscore command in the terminal. To verify whether ROS is successfully installed, open a console terminal (shortcut key Ctrl+Alt+T), and execute the following command in the terminal: roscore When the following interface is displayed, it means that ROS is installed successfully The roscore command starts a node manager, which is used for node management. In a ros system, there is only one node manager, which is the prerequisite for the operation of the ros node. Therefore, before starting the ros node, the first step is to execute roscore. For more detailed installation instructions, please refer to the official installation guide at: http://wiki.ros.org/ROS/Installation 7 MoveIt Installation MoveIt is a functional package of a series of mobile operations in ROS, mainly including motion planning, collision detection, kinematics, 3D perception, operation control and other functions. 7.1 Update The Software Source List Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt-get update 7.2 Install MoveIt Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window to execute MoveIt installation: # Ubuntu20.04 sudo apt-get install ros-noetic-moveit 8 Git Installation 8.1 Add Software Source Add the software source installed by git to the software source list of Ubuntu, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window: sudo add-apt-repository ppa:git-core/ppa 8.2 Update The Software Source List Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt-get update 8.3 Install Git Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window, execute git installation: sudo apt-get install git 8.4 Verify Installation Read the git version, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window: git --version The git version number can be displayed in the terminal, as shown below, indicating a successful installation 8.5 Usage You will need to use git to download the ros package later. For details on how to use git, please refer to the following link: https://git-scm.com/book/zh/v2 https://www.runoob.com/git/git-tutorial.html 9 Mycobot_ros Installation mycobot_ros is a ROS package launched by ElephantRobotics, which is compatible with its desktop six-axis robot arm mycobot series. 项目地址：http://github.com/elephantrobotics/mycobot_ros 9.1 Prerequisites Before installing the package, please ensure that you have a ros workspace. Here we give a sample command for creating a workspace, the default is catkin_ws, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the command line: mkdir -p ~/catkin_ws/src # Create a folder cd ~/catkin_ws/src # Enter the folder catkin_init_workspace # Initialize the current directory as a ROS workspace cd .. # Return to the parent directory catkin_make # Build the code in the workspace. Add workspace environment The official default ROS1 workspace is catkin_ws. # Ubuntu 20.04 echo \"source ~/catkin_ws/devel/setup.bash\" >> ~/.bashrc source ~/.bashrc 9.2 Installation NOTE: This package depends on ROS and MoveIT. Please make sure that ROS and MoveIT are installed successfully before use. The interaction between this package and the real robot arm depends on PythonApi - pymycobot The Api project is: https://github.com/elephantrobotics/pymycobot Quick installation: pip install pymycobot --upgrade When executing the pip install pymycobot --upgrade command, if the following error message appears: Enter the following command to install pip according to the prompt sudo apt install python3-pip After pip is installed, execute it again in the terminal pip3 install pymycobot --upgrade The installation method depends on Git, please make sure Git is installed on your computer. The official default ROS1 workspace is catkin_ws. cd ~/catkin_ws/src # Enter the src folder of the workspace git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros.git # Clone the code on github cd .. # Return to the workspace catkin_make # Build the code in the workspace source devel/setup.bash # Add environment variables This completes the ROS1 environment setup. For more information on using ROS1, please refer to ROS Basics or ROS Basic Function Examples. ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.2-ROS_Basics.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.2-ROS_Basics.html","title":"6.2.2 ROSBasics","keywords":"","body":"1 ROS Project Structure 1.1 Catkin Workspace Catkin workspace is the directory where catkin software packages are created, modified, and compiled. Catkin's workspace can be intuitively described as a warehouse, which contains various ROS project projects to facilitate system organization, management and calling. Create workspace: mkdir -p ~/catkin_ws/src # Create a folder cd ~/catkin_ws/src # Enter the folder catkin_init_workspace # Initialize the current directory into a ROS workspace cd .. # Return to the parent directory catkin_make # Build the code in the workspace The structure of catkin is very clear. It includes three paths: src, build, and devel. It may also include others under some compilation options. But these three folders are the default for the catkin compilation system. Their specific functions are as follows: src/: ROS catkin software package (source code package) build/: cache information and intermediate files of catkin (CMake) devel/: Generated target files (including header files, dynamic link libraries, static link libraries, executable files, etc.), environment variables A simple workspace looks like this: workspace_folder/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- 'Toplevel' CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n 1.2 ROS Software Package Package is not only a software package on Linux, but also the basic unit of catkin compilation. The object we use catkin_make to compile is each ROS package. +--PACKAGE +-- CMakeLists.txt +-- package.xml +-- src/ +-- include/ +-- scripts/ +-- msg/ +-- srv/ +-- urdf/ +-- launch/ CMakeLists.txt: Defines the package name, dependencies, source files, target files and other compilation rules of the package. It is an essential component of the package. package.xml: Describes the package name, version number, author, dependencies and other information of the package, which is an indispensable component of the package. src/: stores ROS source code, including C++ source code (.cpp) and Python module (.py) include/: stores the header files corresponding to the C++ source code scripts/: stores executable scripts, such as shell scripts (.sh), Python scripts (.py) msg/: stores messages in custom format (.msg) srv/: stores services in custom formats (.srv) urdf/: stores the robot’s model description (.urdf or .xacro) and 3D model files (.sda, .stl, .dae, etc.) launch/: stores launch files (.launch or .xml) Create your own package: Command format: The catkin_create_pkg command will ask you to enter package_name. If necessary, you can also add some other dependent software packages later: catkin_create_pkg [depend1] [depend2] [depend3] For example: catkin_create_pkg beginner_tutorials std_msgs rospy roscpp 2 ROS Communication Architecture 2.1 Master And Node 1 Master Node manager. Each node must register with the master before starting and manage the communication between nodes. 2 Roscore Starting the master will also start rosout (log management) and parameter server (parameter manager) 3 Nodes ROS processes and instances of running executable files in pkg. $rosrun [pkg_name] [node_name] #Start $rosnode list #List currently running node information $rosnode info [node_name] #Display detailed information of a node $rosnode kill [node_name] #End a node 4 Launch Start the master and multiple nodes. $roslaunch [pkg_name] [file_name.launch] 2.2 Service And Topic We provide some services and topics for interacting with mycobot. 1 Service Enter in the command line: source ~/catkin_ws/devel/setup.bash # Add environment variables roslaunch mycobot_pro450_communication communication_service.launch Support parameters: port：concatenate serial string baud：baud rate Open a new command line: # Display active service information rosservice list #/get_joint_angles #/get_joint_coords #/set_joint_angles #/set_joint_coords #/switch_gripper_status #/switch_pump_status Related commands and instructions: command Detailed description rosservice list Display active service information rosservice info [service name] Display information about the specified service rosservice type [service name] Show service type rosservice find [service name] Find a service for a specified service type rosservice uri [service name] show ROSRPC URI service rosservice args [service name] show service parameters rosservice call [service name] [parameters] Request service with input parameters 2 Topic Enter in the command line: source ~/catkin_ws/devel/setup.bash roslaunch mycobot_pro450_communication communication_topic.launch Support parameters: port：concatenate serial string baud：baud rate Open a new command line: # Display active service information rostopic list #/mycobot/angles_goal #/mycobot/coords_goal #/mycobot/angles_real #/mycobot/coords_real #/mycobot/pump_status #/mycobot/gripper_status Related commands and instructions: Command Detailed description rostopic list Display active topic list rostopic echo [topic name] Display the message content of the specified topic in real time rostopic find [type name] Display threads with messages of the specified type rostopic type [topic name] Displays the message type of the specified topic rostopic bw [topic name] Display the message bandwidth of the specified topic（bandwidth） rostopic hz [topic name] Display the message data publishing cycle of the specified topic rostopic info [topic name Display information about the specified topic rostopic pub [topic name] [message type] [parameters] Post a message with the specified topic name The difference between service and topic: service topic Synchronization Asynchronous Synchronous communication model pub/sub server/client underlying protocol ROSTCP/ROSUDP ROSTCP/ROSUDP Feedback Mechanism No Yes buffer Yes No Real-time Weak Strong Node Relationship Many-to-Many One-to-Many Applicable Scenarios Data Transmission Logical Processing you can go to service and topic learn more about the use of these two features 2.3 Introduction To Msg And Srv msg：The msg file is a simple text file describing the fields of a ROS message. They are used to generate source code for messages in different languages (c++ or python, etc.). srv：srv files are used to describe services. It consists of two parts: the request (request) and the response (response). msg files are stored in the msg directory of the package, and srv files are stored in the srv directory. 1 Rosmsg rosmsg is a command line tool for displaying information about ROS message types. rosmsg demo: rosmsg show # Show message description rosmsg info # Display message information rosmsg list # list all messages rosmsg md5 # Display md5 encrypted message rosmsg package # Display all messages under a feature pack rosmsg packages # List feature packs that contain messages rosmsg list will list all msgs in the current ROS rosmsg packages List all packages containing messages rosmsg package List all msgs under a package //rosmsg package # Package names rosmsg package turtlesim rosmsg show Show message description //rosmsg show # message name rosmsg show turtlesim/Pose # result: float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity rosmsg info Works the same as rosmsg show rosmsg md5 A check algorithm to ensure the consistency of data transmission 2 rossrv rossrv is a command-line tool for displaying information about ROS service types, and uses a syntax that is highly similar to rosmsg. rossrv show # Display service message details rossrv info # Display information about service messages rossrv list # List all service information rossrv md5 # Display md5 encrypted service messages rossrv package # Display all service messages under a package rossrv packages # Show all packages that contain service messages rossrv list Will list all srv messages in the current ROS rossrv packages List all packages that contain service messages rossrv package List all msgs under a package //rossrv package # Package names rossrv package turtlesim rossrv show Show message description //rossrv show # message name rossrv show turtlesim/Spawn # result: float32 x float32 y float32 theta string name --- string name rossrv info The effect is the same as rossrv show rossrv md5 Use md5 checksum (encryption) for service data 3 Introduction To URDF Unified Robot Description Format，Unified Robot Description Format, abbreviated as URDF. The urdf package in ROS contains a C++ parser for URDF, and URDF files describe robot models in XML format. *URDF cannot be used alone, it needs to be combined with Rviz or Gazebo. URDF is just a file that needs to be rendered into a graphical robot model in Rviz or Gazebo. 3.1 Urdf File Description Code example: Only part of the code is intercepted here for display: It can be seen that the urdf file is not complicated, it is mainly composed of two parts, link and joint, which are repeated continuously. 3.2 Link Section The link element describes a rigid body with inertial, visual features, and collision properties 3.2.1 Attributes name： The name used to describe the link itself 3.2.2 Element (optional) Inertia properties of connecting rods (optional，defaults to identity if not specified) Defines the reference coordinate of the inertial reference system relative to the connecting rod coordinate system. The coordinate must be defined at the center of gravity of the connecting rod, and its coordinate axis may not be parallel to the main axis of inertia. xyz (optional, defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy(optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Mass properties of connecting rods 3×3 rotational inertia matrix, consisting of six independent quantities: ixx, ixy, ixz, iyy, iyz, izz。 (optional) Visual properties of the connecting rod. It is used to specify the shape of the link display (rectangle, cylinder, etc.). There can be multiple visual elements in the same link, and the shape of the link is formed by two elements. In general, the model is more complex and can be drawn through soildwork to generate stl calls, and simple shapes such as adding end effectors can be directly written. At the same time, the position of the geometry can be adjusted according to the gap between the theoretical model and the actual model. (optional) The name of the connecting rod geometry. (optional，defaults to identity if not specified) The geometry coordinate system relative to the coordinate system of the connecting rod. xyz (optional: defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. （required） The shape of the visualization, which can be one of the following: A rectangle with elements including length, width, and height. The origin is in the center. Cylinder, elements include radius and length. center of origin. Sphere, element containing the radius. The origin is in the center. The grid, as determined by the file, also provides a scale to define its boundaries. Collada .dae files are recommended, .stl files are also supported, but must be a local file. (optional) Visualize the component's material. It can be defined outside the link tag, but it must be inside the robot tag. When defining outside the link tag, the name of the link must be quoted. (optional) Color, consisting of red/green/blue/alpha, in the range [0,1]. (optional) Material properties, defined by the file. (optional) Collision properties of the link. Collision properties differ from visual properties of connecting rods, and simple collision models are often used to simplify calculations. The same link can have multiple collision attribute labels, and the collision attribute representation of the link is composed of the set of geometric shapes defined by it. (optional) Specifies the name of the connecting rod geometry (optional，defaults to identity if not specified) The reference coordinate system of the collision component is relative to the reference coordinate system of the link coordinate system. xyz (optional, default zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional, defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Same as the geometry element description above Detailed elements and the role of each element can go to official documentation to view 3.3 Joint Part The joint section describes the kinematics and dynamics of the joint and specifies safety limits for the joint. 3.3.1 Properties Of Joint: name： Specifies a unique name for the joint type： Specifies the type of joint, where type can be one of the following: revolute - A hinged joint that rotates along an axis, the range of which is specified by the upper and lower bounds. Continuous - A continuous hinged joint that rotates around an axis with no upper and lower bounds. Prismatic - A sliding joint that slides along an axis, the range of which is specified by upper and lower limits. +Fixed - this is not really a joint because it cannot move. All degrees of freedom are locked. This type of joint does not require axes, calibration, dynamics, limits or safety_controller。 Floating - This joint allows motion in all 6 degrees of freedom. Plane - This joint allows movement in a plane perpendicular to the axis. 3.3.2 Elements Of Joint (optional，defaults to identity if not specified) In the transformation from parent link to child link, the joint is located at the origin of the child link. Modifying this parameter can adjust the position of the connecting rod. It can be used to adjust the error between the actual model and the theoretical model, but it is not recommended to modify it greatly, because this parameter affects the connecting rod stl The position of , easily affects the collision detection effect. xyz (optional: default to zero vector) Represents the offset in the x , y , z x,y,zx,y,z axis directions, in meters. rpy (optional: default to zero vector) Represents the angle of rotation around a fixed axis: roll is around the x-axis, pitch is around the y-axis, and yaw is around the z-axis, expressed in radians. (required) The name of the parent link is a mandatory attribute. link The name of the parent link is the name of the link in the robot structure tree. (required) The name of the child link is a mandatory attribute. link The name of the child link is the name of the link in the robot structure tree. (optional: defaults to (1,0,0)) The joint's axis is in the joint's coordinate system. This is the axis of rotation (revolute joint), the axis of movement of the prismatic joint, and the standard plane of the planar joint. This axis is specified in the joint coordinate system. Modifying this parameter can adjust the axis around which the joint rotates. It is often used to adjust the rotation direction. If the model rotation is opposite to the actual one, just multiply by -1. Fixed and floating joints do not need this element. xyz(required) x , y , z x, y, zx, y, z components representing axis vectors, as normalized vectors. (optional) The reference point of the joint, used to correct the absolute position of the joint. rising (optional) When the joint is moving forward, the reference point triggers a rising edge. falling (optional) When the joint is moving forward, the reference point triggers a falling edge. (optional) This element is used to specify the physical properties of the joint. Its value is used to describe the modeling performance of the joint, especially during simulation. (Required when the joint is a rotation or translation joint) This element is a joint kinematics constraint. lower (optional, default to 0) Specify the attribute of the lower bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is meters). This attribute is ignored for continuous joints. upper (optional, defaults to 0) Specify the attribute of the upper bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is the meter). This attribute is ignored for continuous joints. effort (required) This property specifies the maximum force at which the joint will run. velocity (required) This property specifies the maximum speed of the joint runtime. (optional) This tag is used to specify a defined joint to mimic an existing joint. The value of this joint can be calculated using the following formula: value = multiplier * other_joint_value + offset joint(required) The name of the joint to mimic. multiplier(optional) Specify the multiplier factor in the above formula. offset(optional) Specify the offset term in the above formula. Default value is 0 (optional) This element is a security control limit. The data under this element will be read into move_group, but it is invalid in practice. Move_group will skip this limit and directly read the parameter content under limit. At the same time, setting this element may cause planning failure. soft_lower_limit (optional, defaults to 0) This attribute specifies the lower bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be greater than the lower value in the above limit. soft_upper_limit (optional, defaults to 0) This attribute specifies the upper bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be less than the upper value in the above limit. k_position(optional, defaults to 0) This attribute is used to describe the relationship between position and velocity. k_velocity(required) This property is used to describe the relationship between force and velocity. Detailed elements and the role of each element can go to http://wiki.ros.org/urdf/XML/joint to view. 4 Commonly Used Command Tools In ROS, there are many commonly used command line tools, which can help you develop, debug, manage ROS nodes, etc. The following are some commonly used ROS command line tools: 4.1 Compile Workspace caktin_make 4.2 Roscore Start the ROS master node. Before running a ROS node, you usually need to start roscore first roscore 4.3 Rosrun Run the specified ROS node. rosrun package_name node_name 4.4 Roslaunch Use the Launch file to start one or more ROS nodes. roslaunch package_name launch_file.launch 4.5 Rosnode View running ROS node information. rosnode list rosnode info node_name 4.6 Rostopic View information about running ROS topics. rostopic list rostopic echo topic_name 4.7 Rosservice View and call ROS services. rosservice list rosservice call service_name 4.8 Rosparam Get and set ROS parameters. rosparam get parameter_name rosparam set parameter_name value 4.9 Rosmsg View ROS message types. rosmsg show message_type 4.10 Rosdep Install dependencies of ROS packages. rosdep install package_name 4.11 Environment Variables View the ROS_PACKAGE_PATH environment variable echo $ROS_PACKAGE_PATH ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.3-RVIZ_Introduction.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.3-RVIZ_Introduction.html","title":"6.2.3 RivzUse","keywords":"","body":"Brief Introduction And Use Of Rviz rviz is a 3D visualization platform in ROS. On one hand, it can realize the graphical display of external information, and on the other hand, it can also release control information to an object through rviz, realizing the monitoring and control of a robot. 1 Installation Of Rviz And The Introduction To Its Interface When installing ros, if you perform a complete installation, rviz is already installed, and you may try to run it directly; if it is not fully installed, you may install rviz separately: # Ubuntu20.04 sudo apt-get install ros-noetic-rviz After the installation is complete, open a new terminal (shortcut key: Ctrl+Alt+T) and enter the following command: roscore Then open a new terminal (shortcut key: Ctrl+Alt+T) and input the following command to open rviz. rosrun rviz rviz # or rviz Open rviz, and the following interface will be displayed: Introduction of all areas There is a list of monitors on the left. The monitor is a device that draws something in a 3D world and may have some options available in the display list. On the top is a toolbar, which allows the user to use various function buttons to select tools with multiple functions. The middle part is the 3D view: It is a main screen where various data can be viewed in three dimensions. The background color, fixed frame, grid, etc. of the 3D view can be set in detail in the Global Options and Grid items displayed on the left. Below is the time display area, including system time and ROS time. The right side is the observation angle setting area where different observation angles can be set. We only give a rough introduction in this part. If you want to know more details, go to User Guide. 2 Simple Use Start Using Launch File This example is built on what you have already done Environment building and you have successfully copied the company's code from GitHub to your virtual machine. Open a new terminal (shortcut key: Ctrl+Alt+T) Input the command to configure the ROS environment. cd ~/catkin_ws/ source devel/setup.bash Input again: roslaunch mycobot_pro_450 test.launch Open rviz, and then you will obtain the following result: If you want to know more information about rviz, go to Official documents. ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.4-Basic_Functions.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.4-Basic_Functions.html","title":"6.2.4 BasicFunctionCases","keywords":"","body":"Robot Arm Control Note: The pymycobot driver library version must be greater than 4.0.0 Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). For detailed configuration instructions, please refer to the section on Static IP Configuration. Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 DNS server: 114.114.114.114 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 ROS Environment Setup Before using this example, ensure you have completed the ROS environment setup and ROS code update. 1 Slider Control Open a command line and run: roslaunch mycobot_pro_450 slider_control.launch # If the end effector is equipped with a myGripper F100 force-controlled gripper, run: roslaunch mycobot_pro_450 slider_control_force_gripper.launch Open rviz and a slider component, and you will see the following interface: If the myGripper F100 force-controlled gripper is attached to the end, you will see the following interface: You can then control the model in rviz and move it by dragging the slider. If you want the actual mold robot to move along with the model, open another command line and run the following command: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. rosrun mycobot_pro_450 slider_control.py # If the end effector is equipped with a myGripper F100 force-controlled gripper, run the following command: rosrun mycobot_pro_450 slider_control_force_gripper.py Note: Since the robot arm will move to the model's current position when you enter the command, please ensure that the model in rviz does not clip before using the command. Avoid dragging the slider quickly after connecting the robot arm to prevent damage. 2 Model Following In addition to the above controls, we can also make the model follow the movement of the actual robot arm. Open a command line and start the ROS node: roscore Then open a new command line and run: rosrun mycobot_pro_450 follow_display.py After running successfully, you need to simultaneously hold down the button at the end of the machine to drag the joint. The terminal output is as follows: Trying to connect to real MyCobot Pro450... IP: 192.168.0.232, port: 4500 Please press the button at the end of the machine to drag the joint. 请按下机器末端按钮进行关节拖拽运动 Publishing... Finally, open another command line and run: roslaunch mycobot_pro_450 follow_display.launch This will open rviz and display the model following effect. At this point, dragging the real robot arm joints will cause the simulation model to follow the real robot arm's movements. 3 GUI Control Building on the above, this package also provides a simple graphical user interface (GUI). Connect to mycobot. Open the command line: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. roslaunch mycobot_pro_450 simple_gui.launch # If the end device is equipped with a myGripper F100 force-controlled gripper, run: roslaunch mycobot_pro_450 simple_gui_force_gripper.launch If the myGripper F100 force-controlled gripper is installed at the end, the following interface will be displayed: After successful execution, the terminal output is as follows: SUMMARY ======== PARAMETERS * /mycobot_services/ip: 192.168.0.232 * /mycobot_services/port: 4500 * /robot_description: Then, enter the relevant angles and coordinates in the GUI and click the corresponding buttons to synchronize the motion of the real machine with the simulation model. Note: Before using the gripper switch button, ensure that the adaptive gripper is connected to the end-of-arm robot. 4 Keyboard Control Keyboard control functionality has been added to the mycobot_pro_450 package, allowing real-time synchronization within rviz. This functionality relies on the Python API, so ensure that the robot arm is connected. Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. roslaunch mycobot_pro_450 teleop_keyboard.launch # If the end-user is equipped with a myGripper F100 force-controlled gripper, run: roslaunch mycobot_pro_450 teleop_keyboard_force_gripper.launch The following is the output: If the myGripper F100 force-controlled gripper is installed on the end effector, the following interface will appear: The following information about mycobot will be output in the command line: SUMMARY ======== PARAMETERS * /mycobot_services/ip: 192.168.0.232 * /mycobot_services/port: 4500 * /robot_description: Then open another command line and run: rosrun mycobot_pro_450 teleop_keyboard.py # If the end-user is equipped with a myGripper F100 force-controlled gripper, run: rosrun mycobot_pro_450 teleop_keyboard_force_gripper.py You will see the following command line output: Mycobot Pro450 Teleop Keyboard Controller (ROS1 - Topic Version) --------------------------------------------------------- Movement (Cartesian): w (x+) a (y+) s (x-) d (y-) z (z-) x (z+) Rotation (Euler angles): u (rx+) i (ry+) o (rz+) j (rx-) k (ry-) l (rz-) Movement Step: + : Increase movement step size - : Decrease movement step size Gripper: g - open h - close Other: 1 - Go to init pose 2 - Go to home pose 3 - Save current pose as home q - Quit currently: speed: 50 change percent: 5 In this terminal, you can control the robot's state and move it using command-line keys. Note: After entering 2 to return the robot to the starting point, the following prompt will appear in the terminal before performing other coordinate control operations: [WARN] [1758001794.385321]: Coordinate control disabled. Please press '2' first. [INFO] [1758001804.552778]: Home pose reached. Coordinate control enabled. [INFO] [1758001817.069637]: Home pose reached. Coordinate control enabled. [WARN] [1758001836.301070]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001848.830702]: Coordinate control disabled. Please press '2' first. [INFO] [1758001863.383565]: Home pose reached. Coordinate control enabled. [WARN] [1758001933.596504]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001942.051899]: Coordinate control disabled. Please press '2' first. This script supports the following parameters: _speed: Robot's movement speed _change_percent: Movement distance percentage 5 Moveit Usage mycobot_ros integrates the MoveIt component. Open a command line and run: roslaunch mycobot_pro450_moveit demo.launch The result is as follows: The terminal will output the following information, indicating that moveit has been successfully started: [ INFO] [1757321505.678763337]: Loading robot model 'firefighter'... [ INFO] [1757321505.782983258]: Set joints of group 'arm_group' to pose 'init_pose'. [ INFO] [1757321505.783324504]: Fake controller 'fake_arm_group_controller' with joints [ joint1 joint2 joint3 joint4 joint5 joint6 ] [ INFO] [1757321505.783798265]: Returned 1 controllers in list [ INFO] [1757321505.792047465]: Trajectory execution is managing controllers [ INFO] [1757321505.792117958]: MoveGroup debug mode is ON Loading 'move_group/ApplyPlanningSceneService'... Loading 'move_group/ClearOctomapService'... Loading 'move_group/MoveGroupCartesianPathService'... Loading 'move_group/MoveGroupExecuteTrajectoryAction'... Loading 'move_group/MoveGroupGetPlanningSceneService'... Loading 'move_group/MoveGroupKinematicsService'... Loading 'move_group/MoveGroupMoveAction'... Loading 'move_group/MoveGroupPickPlaceAction'... Loading 'move_group/MoveGroupPlanService'... Loading 'move_group/MoveGroupQueryPlannersService'... Loading 'move_group/MoveGroupStateValidationService'... Loading 'pilz_industrial_motion_planner/MoveGroupSequenceAction'... [ INFO] [1757321505.848190702]: initialize move group sequence action [ INFO] [1757321505.853932419]: Reading limits from namespace /robot_description_planning Loading 'pilz_industrial_motion_planner/MoveGroupSequenceService'... [ INFO] [1757321505.867558584]: Reading limits from namespace /robot_description_planning [ INFO] [1757321505.884930897]: ******************************************************** * MoveGroup using: * - ApplyPlanningSceneService * - ClearOctomapService * - CartesianPathService * - ExecuteTrajectoryAction * - GetPlanningSceneService * - KinematicsService * - MoveAction * - PickPlaceAction * - MotionPlanService * - QueryPlannersService * - StateValidationService * - SequenceAction * - SequenceService ******************************************************** [ INFO] [1757321505.885485766]: MoveGroup context using planning plugin ompl_interface/OMPLPlanner [ INFO] [1757321505.885536833]: MoveGroup context initialization complete You can start planning now! [ INFO] [1757321508.935642298]: Loading robot model 'firefighter'... [ INFO] [1757321509.253483659]: Starting planning scene monitor [ INFO] [1757321509.257223628]: Listening to '/move_group/monitored_planning_scene' [ INFO] [1757321509.375270577]: Constructing new MoveGroup connection for group 'arm_group' in namespace '' [ INFO] [1757321510.628737935]: Ready to take commands for planning group arm_group. The basic path planning operation is as follows: If you want the actual robot arm to execute the plan synchronously, you need to open another command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. rosrun mycobot_pro450_moveit sync_plan.py Modifying Movement Speed To prevent joint shaking during actual robot arm movement, reduce the joint movement speed. In the sync_plan.py file, modify the speed parameter of the robot arm's Python API. Here, change it to 25。 ... def callback(data: JointState): \"\"\"Callback function for ROS JointState subscription. This function converts incoming joint positions (radians) to angles in degrees and sends them to the Pro450 robotic arm. Args: data (JointState): Joint state message containing joint positions. \"\"\" data_list = [] for index, value in enumerate(data.position): radians_to_angles = round(math.degrees(value), 2) data_list.append(radians_to_angles) rospy.loginfo(data_list) mc.send_angles(data_list, 25) ... In the Moveit RViz interface, modify the velocity and acceleration scaling. In this case, change it to 0.1 and save the current configuration. ← Previous Page | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.5-Troubleshooting.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.2-ROS1/6.2.5-Troubleshooting.html","title":"6.2.5 CommonProblemsAndSolutions","keywords":"","body":"ROS1 Common Problems and Solutions When using ROS1 to control the MyCobot Pro 450, you may encounter some common problems. Below is a list of common errors and their corresponding solutions for quick troubleshooting. 1 Environment-Related Issues Issue 1: Running roslaunch results in the error package 'mycobot_pro_450' not found Cause: The ROS workspace was not compiled correctly or the environment variables were not loaded Solution:cd ~/catkin_ws catkin_make source devel/setup.bash 2 Network Communication Issues Issue 1: Error: \"Trying to connect to real MyCobot Pro450... Timeout\" Cause: The PC and robot are not on the same network segment, or the IP address is incorrectly set Solution: Confirm that the robot's default IP address is 192.168.0.232 Set the PC network card to the same network segment, for example, 192.168.0.100 Test connectivity: ping 192.168.0.232 3 Python API/Library Issues Issue 1: Runtime Error ModuleNotFoundError: No module named 'pymycobot' Cause: pymycobot is not installed in the Python environment Solution: pip3 install pymycobot Issue 2: Runtime Error ImportError: cannot import name 'Pro450Client' from 'pymycobot' Cause: pymycobot version is too low Solution: pip install -U pymycobot Issue 3: Runtime Error RuntimeError: The version of the pymycobot library must be greater than 3.9.9 or higher. The current version is 3.9.7. Please upgrade the library version. Cause: Pymycobot version is too low Solution: pip install -U pymycobot Note: Version must be greater than 4.0.0 4 ROS Node Operation Issues Problem 1: Model not displayed after opening in rviz Cause 1: robot_description not loaded correctly Solution: Check that the roslaunch command is complete In the terminal, enter: rosparam list | grep robot_description If you see the /robot_description parameter, the model has been loaded. Please check that the joint_state_publisher and robot_state_publisher are running properly. Use the rostopic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Problem 2: After opening rviz, the model is incomplete, and the terminal continuously outputs a warning message similar to: Warning [Invalid frame ID \"base\" passed to canTransform argument target frame frame does not exist rviz] rviz at line 133 in /tmp/binarydeb/ros-foxy-tf2-0.13.13/src/buffer core.cpp Cause 1: Robot communication is abnormal and angle coordinates cannot be read normally. Solution: Is joint_states being published (a message will be printed)? In the terminal, enter: rostopic echo -n 5 /joint_states If /joint_states does not output anything, it is likely that the robot communication or the mycobot service is not receiving data. Please check that joint_state_publisher and robot_state_publisher are running properly. - Use the rostopic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Check the robot's communication status. For details, see Python Exception Handling Check whether the robot can read angles and coordinates normally. from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() != 1: mc.power_on() print(mc.get_angles(), mc.get_coords()) Problem 3: Error message: [WARN]: Coordinate control disabled. Please press '2' first. Solution: First enter 2 on the keyboard control interface to return the robot to its starting point, then resume coordinate control "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/","title":"6.3 ROS2","keywords":"","body":"ROS2 Introduction The predecessor of ROS2 is ROS, and ROS is the Robot Operating System (Robot Operating System). But ROS itself is not an operating system, but a software library and toolset. The emergence of Ros solved the communication problem of each component of the robot. Later, more and more robot algorithms were integrated into ROS. ROS2 inherited ROS, which is more powerful and better than ROS. 1 Design Goals And Features Of ROS2 ROS2 has the historical mission of changing the era of intelligent robots. At the beginning of the design, it was considered to meet the needs of various robot applications. Multi-Robot Systems: In the future, robots will not be independent individuals, and communication and collaboration between robots are also required. ROS2 provides standard methods and communication mechanisms for the application of multi-robot systems. Cross-platform: Robot application scenarios are different, and the control platforms used will also be very different. In order to allow all robots to run ROS2, ROS2 can run on Linux, Windows, MacOS, and RTOS across platforms. Real time: Robot motion control and many behavior strategies require the robot to be real-time. For example, the robot must reliably detect pedestrians in front of it within 100ms, or complete kinematics and dynamics calculations within 1ms. ROS2 is a real-time like this Basic requirements are provided. Productization: A large number of robots have entered our lives, and there will be more and more in the future，ROS2 can not only be used in the robot research and development stage, but also can be directly installed in the product and go to the consumer market. This also poses a huge challenge to the stability and robustness of ROS2. Project management: Robot development is a complex system engineering. The project management tools and mechanisms for the whole process of design, development, debugging, testing, and deployment will also be reflected in ROS2, making it easier for us to develop a robot. 2 Release Version The release version and maintenance cycle corresponding to ROS2 and Ubuntu. ROS2 version release date Maintenance deadline Ubuntu version Dashing 2019.5 2021.5 Ubuntu 18.04 (Bionic Beaver) Eloquent 2019.11 2020.11 Ubuntu 18.04 (Bionic Beaver) Foxy 2020.6 2023.5 Ubuntu 20.04(Focal Fossa) Galactic 2021.5 2022.11 Ubuntu 20.04(Focal Fossa) Humble 2022.5 2027.5 Ubuntu 22.04(Jammy Jellyfish) 3 Comparison Of ROS And ROS2 ROS2 redesigned the system architecture. The architecture changes between the two generations of ROS are as follows: OS Layer: In ROS2, it can be built on linux or other systems, even bare metal without an operating system. Middleware Layer: The communication system of ROS1 is based on TCPROS/UDPROS, while the communication system of ROS2 is based on DDS. DDS is a standard solution for data publishing/subscribing in distributed real-time systems. Application Layer: ROS1 relies on ROS Master, while in ROS2, a discovery mechanism called \"Discovery\" is used between nodes to help establish connections with each other. ROS has designed a complete set of communication mechanisms (topics, services, parameters, actions) to simplify robot development. Through this mechanism, the various components of the robot can be connected. This mechanism has designed a node called Ros Master, and the communication of all other components must go through the master node. Once the master node hangs up, it will cause the communication of the entire robot system to collapse! Therefore, the instability of Ros cannot be used to make some high-risk robots such as automatic driving. In addition, there are the following disadvantages: Communication based on TCP has poor real-time performance and high system overhead Unfriendly to python3 support Messaging mechanism is not compatible No encryption mechanism, low security ROS2 first removes the master node that exists in ROS. After removing the master node, each node can discover each other through the DDS node, each node is equal, and can realize one-to-one, one-to-many, and many-to-many communication. After using DDS for communication, reliability and stability have been enhanced. Compared with ROS that only supports Linux systems, ROS2 also supports windows, mac, and even RTOS platforms 4 Moveit2 MoveIt2 Introduction MoveIt2 is an integrated development platform within ROS2. It consists of multiple functional packages for manipulating robotic arms, including motion planning, manipulation, control, inverse kinematics, 3D perception, and collision detection. Core Features Motion Planning MoveIt 2 provides motion planning capabilities based on the Open Motion Planning Library (OMPL) and other third-party libraries, supporting a variety of planning algorithms and constraints. Inverse Kinematics (IK) MoveIt 2 uses a plugin mechanism to support different IK solvers, enabling rapid calculation of the target pose of the robotic arm. Collision Detection & Avoidance MoveIt 2 includes powerful built-in collision detection capabilities to ensure that the robot avoids collisions with its surroundings when planning and executing motions. Dynamic Scene Awareness MoveIt 2 supports dynamic updates of its environment model, enabling real-time perception of obstacle changes. Control & Execution MoveIt 2 provides a motion control interface that tightly integrates with the robot hardware, ensuring accurate execution of planned paths. Visualization Tools Integrated with RViz 2, it supports intuitive interaction and debugging, displaying the motion planning and execution process in real time. Advantages Of MoveIt 2 Real-time Support Based on ROS 2 ROS 2's DDS communication architecture empowers MoveIt 2, significantly improving real-time performance and reliability. Modular Design MoveIt 2 utilizes a modular architecture, allowing users to load or replace modules as needed, providing tremendous flexibility. Cross-Platform Support MoveIt 2 supports running on a variety of operating systems (such as Ubuntu and Windows) and hardware platforms. Active Community Support MoveIt 2 has a global developer community that continuously provides updates, feature extensions, and technical support. Configuration URDF - Universal Robot Description Format. SRDF - Contains the robot's joint groups, virtual and passive joints, robot pose, and self-collision, typically created by the user using the MoveIt2 Setup Assistant. MoveIt2 Configuration - Contains joint limits, kinematics, motion planning, perception, and other information. Configuration files for these components are automatically generated by the MoveIt2 Setup Assistant (MoveIt2 Configuration Assistant) and stored in the configuration directory of the robot's corresponding MoveIt2 configuration package. ← Previous Chapter | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.1-Environment_Setup.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.1-Environment_Setup.html","title":"6.3.1 EnvironmentSetup","keywords":"","body":"ROS2 Environment Setup This tutorial provides two methods for setting up an Ubuntu 20.04/22.04 + ROS1 development environment: Method 1: Importing a Virtual Machine Image (Recommended) → Quickest to get started, with a complete built-in environment Method 2: Customizing the Installation Environment → Building from scratch, suitable for users who require flexible customization Method 1: Importing A Virtual Machine Image Applicable Use Case: Using ROS2 or MoveIt2 Note: To simplify environment setup, we will provide a Linux system image (Ubuntu 22.04), the Virtual Box installation package, and its extensions. The following instructions will show you how to install Virtual Box and import the Linux system image (the default password is 123). Built-in Environment: ROS2 humble + MoveIt2 + Git + pymycobot + mycobot_ros2 1 Virtual Machine Installation Go to the official website to download the virtual machine Virtual Box VirtualBox installation package: Windows hosts VirtualBox Extension Pack: VirtualBox 7.0.10 Oracle VM VirtualBox Extension Pack For instructions on installing VirtualBox extension packs, please refer to: Extension Pack Installation Tutorial Of course, if you already have your virtual machine, you can skip this step. We chose to download Virtual box because it is free. 2 Download Linux System Image Click to download:Linux ubuntu22.04 3 Import Linux System Image Note: For the import method, please refer to the import method of Ubuntu 20.04 system In the Virtual Box interface, click Management -> Import Virtual Computer -> Select Virtual Image -> Select the installation path and import, and then install it as follows. Just wait for the image to be imported. The installation is successful as shown below. Then start the system, the default password is 123 4 Update Pymycobot To use the latest robotic arm driver library, open a terminal and execute the following command: pip3 install pymycobot --upgrade 5 Update Mycobot_ros2 To ensure users have the latest official packages, navigate to the /home/u22/catkin_ws/src folder through a file manager, open a console terminal (shortcut Ctrl+Alt+T), and enter the following command to update: # Clone the code from GitHub cd ~/colcon_ws/src # Delete the original mycobot_ros2 package sudo rm -rf mycobot_ros2 git clone --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git cd # Return to the workspace colcon build # Build the code in the workspace source install/setup.bash # Add environment variables To reduce compilation time, you can compile individual packages. package_name is the specific package name; please modify it accordingly. cd ~/colcon_ws colcon build --packages-select package_name source install/setup.bash Method 2: Customizing The Installation Environment 1 Virtual Machine Installation Note: When installing the virtual machine system, please install the Ubuntu 20.04 version of the system. The installation method is the same as Ubuntu 18.04. If you want to use the moveIt2 function, you need to install Ubuntu 22.04 version system. To install different versions of Ubuntu systems in Linux, please refer to 6.2 ROS1 Environment Setup section. 2 ROS2 Installation The basic development environment construction requires the installation of the robot operating system ROS2 and the git version manager. The following describes their installation methods and processes respectively. 2.1 Version Selection ROS2 has a one-to-one correspondence with Ubuntu. Different versions of Ubuntu correspond to different versions of ROS2. For reference, see the following website: http://docs.ros.org/en/foxy/Releases.html Here are the ROS2 versions supported by Ubuntu: ROS2 version Release date Maintenance deadline Ubuntu version Foxy June 5, 2020 May 2023 Ubuntu 20.04(Focal Fossa) Galactic May 23, 2021 November 2022 Ubuntu 20.04(Focal Fossa) Humble May 23, 2022 May 2027 Ubuntu 22.04(Jammy Jellyfish) Please install the corresponding ROS2 version according to the Ubuntu version you installed, moveIt2 only supports the humble version If the versions are different, the download will fail. Here we choose Ubuntu 20.04 (recommended), and the corresponding ROS2 version is ROS2 Foxy NOTE: Currently we do not provide any reference for installing ROS2 on Windows. If necessary, please refer to http://docs.ros.org/en/foxy/Installation/Alternatives/Windows-Development-Setup.html 2.2 Start Installation 1 Add Source There is no ROS2 in the software source list of Ubuntu itself Software source, so you need to first configure the ROS2 software source to the software list warehouse before you can download ROS2. Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command: Official source: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null If the download speed is slow, it is recommended to select a mirror source nearby to replace the above command. For example, Huawei Cloud is: echo \"deb [arch=$(dpkg --print-architecture)] https://repo.huaweicloud.com/ros2/ubuntu/ $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null 2 Set The key Configure the public network key, this step is to let the system confirm that our path is safe, so that there is no problem downloading the file, otherwise it will be deleted immediately after downloading: sudo apt install curl gnupg2 -y curl -s https://gitee.com/ohhuo/rosdistro/raw/master/ros.asc | sudo apt-key add - 3 Installation After adding the new software source, you need to update the software source list, open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command: sudo apt-get update Execute install ROS2, open a console terminal (shortcut key Ctrl+Alt+T), please enter the following command according to your Ubuntu version: # Ubuntu 20.04 foxy version sudo apt install ros-foxy-desktop # Ubuntu 20.04 galactic version sudo apt install ros-galactic-desktop # Ubuntu 22.04 humble version sudo apt install ros-humble-desktop The installation process takes a long time, please wait patiently After the installation is complete, refresh the environment variables: source /opt/ros/foxy/setup.bash 2.3 Set Up The Ros2 Environment In order to avoid the need to re-validate the ROS2 function path every time the terminal window is closed, we can configure the path to the environment variable, so that the ROS2 function path can be automatically validated every time a new terminal is opened. Execute the following commands in the terminal in sequence, open a console terminal (shortcut key Ctrl+Alt+T) and execute the following commands: # Ubuntu 20.04 foxy version # Add the ros environment to the environment variables of the current console echo \"source /opt/ros/foxy/setup.bash\" >> ~/.bashrc # Ubuntu 20.04 galactic version echo \"source /opt/ros/galactic/setup.bash\" >> ~/.bashrc # Ubuntu 22.04 humble version echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc source ~/.bashrc 2.4 Install ROS2 Additional Dependencies Enter the following command in the terminal Install ROS2 additional dependencies, open a console terminal (shortcut Ctrl+Alt+T): sudo apt install python3-argcomplete -y sudo apt install ros-foxy-xacro sudo apt-get install python3-colcon-common-extensions # Ubuntu 20.04 foxy version sudo apt install ros-foxy-joint-state-publisher-gui # Ubuntu 20.04 galactic version sudo apt install ros-galactic-joint-state-publisher-gui # Ubuntu 22.04 humble version sudo apt install ros-humble-joint-state-publisher-gui sudo apt install ros-humble-xacro 2.5 Verify Installation To verify ROS2 To check whether the installation is successful, open a console terminal (shortcut key Ctrl+Alt+T), and execute the following command in the terminal: ros2 When the following interface is displayed, it means that ROS2 is installed successfully 3 MoveIt2 Installation Note: Only the installation method for Ubuntu 22.04 is provided here MoveIt2 is a functional package of a series of mobile operations in ros2, mainly including motion planning, collision detection, kinematics, 3D perception, operation control and other functions. 3.1 Update The Software Source List Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt update 3.2 Install MoveIt2 sudo apt-get install ros-humble-moveit sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-joint-trajectory-controller ros-humble-joint-state-broadcaster 4 Git Installation 4.1 Update The Software Source List Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the terminal window to update the software source list: sudo apt-get update 4.2 Installation Git Open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window, execute git installation: sudo apt-get install git 4.3 Verify Installation Read git version, open a console terminal (shortcut key Ctrl+Alt+T), enter the following command in the terminal window: git --version The git version number can be displayed in the terminal, as shown below, which means the installation is successful. 5 Mycobot_ros2 Installation mycobot_ros2 is a ROS2 package launched by ElephantRobotics, which is compatible with its desktop six-axis robot arm mycobot series. Project address: http://github.com/elephantrobotics/mycobot_ros2 5.1 Prerequisites Before installing the package, please ensure that you have a ros2 workspace. Here we give sample commands for creating a workspace. Open a console terminal (shortcut key Ctrl+Alt+T), and enter the following command in the command line: mkdir -p ~/colcon_ws/src # Create a folder Add workspace environment The official default ROS2 workspace is colcon_ws. echo \"source ~/colcon_ws/install/setup.bash\" >> ~/.bashrc source ~/.bashrc 5.2 Installation NOTE: This package depends on ROS2 and MoveIT2. Make sure to install ROS2 and MoveIT2 successfully before using it. The interaction between this package and the real robot arm depends on PythonApi - pymycobot The Api project is: https://github.com/elephantrobotics/pymycobot Quick installation: pip install pymycobot --upgrade When executing the pip install pymycobot --upgrade command, if the following error message appears: Enter the following command to install pip according to the prompt sudo apt install python3-pip After pip is installed, execute it again in the terminal pip install pymycobot --upgrade The installation method depends on Git, please make sure Git is installed on your computer. Please download the code from different branches depending on your ROS2 version: Ubuntu 20.04 / ROS2 Foxy - branch foxy Ubuntu 20.04 / ROS2 Galactic - branch galactic Ubuntu 22.04 / ROS2 Humble - branch humble The official default ROS2 workspace is colcon_ws. cd colcon_ws/src # Enter the src folder in the workspace # For the humble branch git clone -b humble --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git # For the foxy branch git clone -b foxy --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git # For the galactic branch git clone -b galactic --depth 1 https://github.com/elephantrobotics/mycobot_ros2.git cd .. # Return to the workspace colcon build --symlink-install # Build the code in the workspace. --symlink-install: Avoids recompiling every time you modify the Python script. source install/setup.bash # Add environment variables To reduce compilation time, you can compile a certain package separately, where package_name is the name of the specific package. Please modify it according to your actual situation. cd ~/colcon_ws colcon build --packages-select package_name source install/setup.bash This completes the ROS2 environment setup. For more information on using ROS2, please refer to ROS2 Basics or ROS2 Basic Functions. ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.2-ROS2_Basics.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.2-ROS2_Basics.html","title":"6.3.2 ROS2Basics","keywords":"","body":"1 ROS2 Project Structure 1.1 Colcon Workspace The colocn workspace is the directory where software packages are created, modified, and compiled. Colcon's workspace can be intuitively described as a warehouse, which contains various ROS project projects to facilitate system organization, management and calling. Create workspace: mkdir -p ~/colcon_ws/src # Create folder cd ~/colcon_ws/ # Enter the folder colcon build # Build the code in the workspace. Note: colcon supports option --symlink-install. This allows for faster iteration by changing installed files by changing files in the source space (such as Python files or other uncompiled resources). Avoid the need to recompile every time you modify your python script. colcon build --symlink-install A ROS workspace is a directory with a particular structure. Commonly there is a src subdirectory. Inside that subdirectory is where the source code of ROS packages will be located. Typically the directory starts otherwise empty. colcon does out of source builds. By default it will create the following directories as peers of the src directory: src/: colcon package for ROS2 (source code package) build/: The location where intermediate files are stored. For each package, a subfolder is created in which CMake is called, for example. install/: The installation location of each package. By default, each package will be installed into a separate subdirectory. log/: Contains various logging information about each colcon call. The directory structure of a ROS2 workspace is as follows: WorkSpace --- Customized workspace. |--- build: The directory where intermediate files are stored. A separate subdirectory will be created for each function package in this directory. |--- install: Installation directory, a separate subdirectory will be created for each function package in this directory. |--- log: Log directory, used to store log files. |--- src: Directory used to store function package source code. |-- C++ function package |-- package.xml: package information, such as: package name, version, author, dependencies. |-- CMakeLists.txt: Configure compilation rules, such as source files, dependencies, and target files. |-- src: C++ source file directory. |-- include: header file directory. |-- msg: message interface file directory. |-- srv: Service interface file directory. |-- action: action interface file directory. |-- Python function package |-- package.xml: package information, such as: package name, version, author, dependencies. |-- setup.py: similar to CMakeLists.txt of C++ function package. |-- setup.cfg: Function package basic configuration file. |-- resource: resource directory. |-- test: stores test-related files. |-- Directory with the same name of the function package: Python source file directory. 1.2 ROS2 Package Package is not only a software package on Linux, but also the basic unit of colcon compilation. The object we use colcon build to compile is each ROS2 package. Create your own package: The command syntax for creating a software package using Python is: ros2 pkg create --build-type ament_python For example: ros2 pkg create --build-type ament_python --node-name my_node my_package 2 Basic Tool Commands In this chapter, you will learn about the common command tools of ROS2. 2.1 Topics ROS 2 breaks complex systems down into many modular nodes. Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages. Topics are one of the main ways in which data is moved between nodes and therefore between different parts of the system. Specific reference: Official Tutorials topics help ros2 topics -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Node Relationship Diagram rqt_graph Learn about topic-related commands ros2 topics -h topics list ros2 topic list ros2 topic list -t # Display the corresponding message type View topic content ros2 topic echo ros2 topic echo /turtle1/cmd_vel Display topic-related information, type ros2 topic info # Output /turtle1/cmd_vel topic related information ros2 topic info /turtle1/cmd_vel Display interface related information ros2 interface show # Output geometry_msgs/msg/Twist interface related information ros2 interface show geometry_msgs/msg/Twist Issue an order ros2 topic pub '' # Issue speed command ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" # Issue speed commands at a certain frequency ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" See how often topics are posted ros2 topic hz # Output /turtle1/cmd_vel publish frequency ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" 2.2 Nodes Each node in ROS should be responsible for a single, module purpose (e.g. one node for controlling wheel motors, one node for controlling a laser range-finder, etc). Each node can send and receive data to other nodes via topics, services, actions, or parameters. A full robotic system is comprised of many nodes working in concert. In ROS 2, a single executable (C++ program, Python program, etc.) can contain one or more nodes. Specific reference: Official Tutorials nodes help ros2 nodes -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key View the node list ros2 node list View Node Relationship Diagram rqt_graph Remapping ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle ros2 node list View node information ros2 node info ros2 node info /my_turtle 2.3 Services Services are another method of communication for nodes in the ROS graph. Services are based on a call-and-response model, versus topics’ publisher-subscriber model. While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client. Specific reference: Official Tutorials services help ros2 service -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key View the service list ros2 service list # Display service list and message type ros2 service list -t View the message types received by the service ros2 service type ros2 service type /clear Find services that use a certain message type ros2 service find ros2 service find std_srvs/srv/Empty View Service Message Type Definitions ros2 interface show .srv ros2 interface show std_srvs/srv/Empty.srv Call the service command to clear the walking track ros2 service call ros2 service call /clear std_srvs/srv/Empty Spawn a new turtle ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: 'turtle2'}\" 2.4 Parameters A parameter is a configuration value of a node. You can think of parameters as node settings. A node can store parameters as integers, floats, booleans, strings, and lists. In ROS 2, each node maintains its own parameters. For more background on parameters, please see the concept document. Specific reference: Official Tutorials parameters help ros2 param -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key View service list ros2 param list Get the parameter value ros2 param get ros2 param get /turtlesim background_g Set parameter values ros2 param set ros2 param set /turtlesim background_r 150 Export parameter values ros2 param dump ros2 param dump /turtlesim Import parameters independently ros2 param load ros2 param load /turtlesim ./turtlesim.yaml Start the node and import parameters at the same time ros2 run --ros-args --params-file ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml 2.5 Actions Actions are one of the communication types in ROS 2 and are intended for long running tasks. They consist of three parts: a goal, feedback, and a result. Actions are built on topics and services. Their functionality is similar to services, except actions are preemptable (you can cancel them while executing). They also provide steady feedback, as opposed to services which return a single response. Actions use a client-server model, similar to the publisher-subscriber model (described in the topics tutorial). An “action client” node sends a goal to an “action server” node that acknowledges the goal and returns a stream of feedback and a result. Specific reference: Official Tutorials action help ros2 action -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Press G|B|V|C|D|E|R|T to achieve rotation, press F to cancel View the server and client of the node action ros2 node info /turtlesim View action list ros2 action list ros2 action list -t # show action type view action info ros2 action info ros2 action info /turtle1/rotate_absolute View action message content ros2 interface show turtlesim/action/RotateAbsolute Send action target information ros2 action send_goal ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 1.57}\" # With feedback information ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 0}\" --feedback 2.6 RQt RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins. One can run all the existing GUI tools as dockable windows within RQt! The tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout. Specific reference: Official Tutorials You can run any RQt tools/plugins easily by: rqt rqt help rqt -h Start turtlesim and keyboard control ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Action Type Browser: / Plugins -> Actions ->Action Type Browser parameter reconfiguration: / Plugins -> configuration ->Parameter Reconfigure Node grap: /Node Graph control steering: /Plugins -> Robot Tools -> Robot Steering service invocation: /Plugins -> Services -> Service Caller Service Type Browser: Plugins -> Services -> Service Type Browser message release: Plugins -> Topics -> Message Publisher Message Type Browser: Plugins -> Topics -> Message Type Browser topic list: Plugins -> Topics -> Topic Monitor draw a graph: Plugins -> Visualization -> Plot View logs: rqt_console ros2 run rqt_console rqt_console ros2 run turtlesim turtlesim_node ros2 topic pub -r 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}\" 2.7 TF2 tf2 is the transform library, which lets the user keep track of multiple coordinate frames over time. tf2 maintains the relationship between coordinate frames in a tree structure buffered in time and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time. Specific reference: Official Tutorials Let’s start by installing the demo package and its dependencies. sudo apt-get install ros-foxy-turtle-tf2-py ros-foxy-tf2-tools ros-foxy-tf-transformations follow launch starts 2 little turtles, the first little turtle automatically follows the second one ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py Control the movement of the first little turtle through the keyboard ros2 run turtlesim turtle_teleop_key View TF tree ros2 run tf2_tools view_frames.py evince frames.pdf View the relationship between two coordinate systems ros2 run tf2_ros tf2_echo [reference_frame] [target_frame] ros2 run tf2_ros tf2_echo turtle2 turtle1 View TF relationships on rviz ros2 run rviz2 rviz2 -d $(ros2 pkg prefix --share turtle_tf2_py)/rviz/turtle_rviz.rviz 2.8 URDF URDF is the Unified Robot Description Format for specifying robot geometry and organization in ROS. Specific reference: Official Tutorials 部分代码示例 It can be seen that the urdf file is not complicated, it is mainly composed of two parts, link and joint, which are repeated continuously. link section The link element describes a rigid body with inertial, visual features, and collision properties, the name is used to describe the name of the link itself, as follows: (optional) Inertia properties of connecting rods (optional，defaults to identity if not specified) Defines the reference coordinate of the inertial reference system relative to the connecting rod coordinate system. The coordinate must be defined at the center of gravity of the connecting rod, and its coordinate axis may not be parallel to the main axis of inertia. xyz (optional, defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy(optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Mass properties of connecting rods 3×3 rotational inertia matrix, consisting of six independent quantities: ixx, ixy, ixz, iyy, iyz, izz。 (optional) Visual properties of the connecting rod. It is used to specify the shape of the link display (rectangle, cylinder, etc.). There can be multiple visual elements in the same link, and the shape of the link is formed by two elements. In general, the model is more complex and can be drawn through soildwork to generate stl calls, and simple shapes such as adding end effectors can be directly written. At the same time, the position of the geometry can be adjusted according to the gap between the theoretical model and the actual model. (optional) The name of the connecting rod geometry. (optional，defaults to identity if not specified) The geometry coordinate system relative to the coordinate system of the connecting rod. xyz (optional: defaults to zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional: defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. （required） The shape of the visualization, which can be one of the following: A rectangle with elements including length, width, and height. The origin is in the center. Cylinder, elements include radius and length. center of origin. Sphere, element containing the radius. The origin is in the center. The grid, as determined by the file, also provides a scale to define its boundaries. Collada .dae files are recommended, .stl files are also supported, but must be a local file. (optional) Visualize the component's material. It can be defined outside the link tag, but it must be inside the robot tag. When defining outside the link tag, the name of the link must be quoted. (optional) Color, consisting of red/green/blue/alpha, in the range [0,1]. (optional) Material properties, defined by the file. (optional) Collision properties of the link. Collision properties differ from visual properties of connecting rods, and simple collision models are often used to simplify calculations. The same link can have multiple collision attribute labels, and the collision attribute representation of the link is composed of the set of geometric shapes defined by it. (optional) Specifies the name of the connecting rod geometry (optional，defaults to identity if not specified) The reference coordinate system of the collision component is relative to the reference coordinate system of the link coordinate system. xyz (optional, default zero vector) Represents the offset in the x , y , z x,y,zx,y,z directions, in meters. rpy (optional, defaults to identity if not specified) Indicates the rotation of the coordinate axis in the RPY direction, in radians. Same as the geometry element description above Detailed elements and the role of each element can go to official documentation to view joint part The joint section describes the kinematics and dynamics of the joint and specifies safety limits for the joint.Name is a unique name for the specified joint type： Specifies the type of joint, where type can be one of the following: revolute - A hinged joint that rotates along an axis, the range of which is specified by the upper and lower bounds. Continuous - A continuous hinged joint that rotates around an axis with no upper and lower bounds. Prismatic - A sliding joint that slides along an axis, the range of which is specified by upper and lower limits. +Fixed - this is not really a joint because it cannot move. All degrees of freedom are locked. This type of joint does not require axes, calibration, dynamics, limits or safety_controller。 Floating - This joint allows motion in all 6 degrees of freedom. Plane - This joint allows movement in a plane perpendicular to the axis. elements of joint: (optional，defaults to identity if not specified) In the transformation from parent link to child link, the joint is located at the origin of the child link. Modifying this parameter can adjust the position of the connecting rod. It can be used to adjust the error between the actual model and the theoretical model, but it is not recommended to modify it greatly, because this parameter affects the connecting rod stl The position of , easily affects the collision detection effect. xyz (optional: default to zero vector) Represents the offset in the x , y , z x,y,zx,y,z axis directions, in meters. rpy (optional: default to zero vector) Represents the angle of rotation around a fixed axis: roll is around the x-axis, pitch is around the y-axis, and yaw is around the z-axis, expressed in radians. (required) The name of the parent link is a mandatory attribute. link The name of the parent link is the name of the link in the robot structure tree. (required) The name of the child link is a mandatory attribute. link The name of the child link is the name of the link in the robot structure tree. (optional: defaults to (1,0,0)) The joint's axis is in the joint's coordinate system. This is the axis of rotation (revolute joint), the axis of movement of the prismatic joint, and the standard plane of the planar joint. This axis is specified in the joint coordinate system. Modifying this parameter can adjust the axis around which the joint rotates. It is often used to adjust the rotation direction. If the model rotation is opposite to the actual one, just multiply by -1. Fixed and floating joints do not need this element. xyz(required) x , y , z x, y, zx, y, z components representing axis vectors, as normalized vectors. (optional) The reference point of the joint, used to correct the absolute position of the joint. rising (optional) When the joint is moving forward, the reference point triggers a rising edge. falling (optional) When the joint is moving forward, the reference point triggers a falling edge. (optional) This element is used to specify the physical properties of the joint. Its value is used to describe the modeling performance of the joint, especially during simulation. (Required when the joint is a rotation or translation joint) This element is a joint kinematics constraint. lower (optional, default to 0) Specify the attribute of the lower bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is meters). This attribute is ignored for continuous joints. upper (optional, defaults to 0) Specify the attribute of the upper bound of the joint's motion range (the unit of the revolute joint is radians, and the unit of the prismatic joint is the meter). This attribute is ignored for continuous joints. effort (required) This property specifies the maximum force at which the joint will run. velocity (required) This property specifies the maximum speed of the joint runtime. (optional) This tag is used to specify a defined joint to mimic an existing joint. The value of this joint can be calculated using the following formula: value = multiplier * other_joint_value + offset joint(required) The name of the joint to mimic. multiplier(optional) Specify the multiplier factor in the above formula. offset(optional) Specify the offset term in the above formula. Default value is 0 (optional) This element is a security control limit. The data under this element will be read into move_group, but it is invalid in practice. Move_group will skip this limit and directly read the parameter content under limit. At the same time, setting this element may cause planning failure. soft_lower_limit (optional, defaults to 0) This attribute specifies the lower bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be greater than the lower value in the above limit. soft_upper_limit (optional, defaults to 0) This attribute specifies the upper bound of the joint security control boundary, which is the starting limit point of the joint security control. This value needs to be less than the upper value in the above limit. k_position(optional, defaults to 0) This attribute is used to describe the relationship between position and velocity. k_velocity(required) This property is used to describe the relationship between force and velocity. Detailed elements and the role of each element can go to http://wiki.ros.org/urdf/XML/joint to view. Install dependent libraries sudo apt install ros-foxy-joint-state-publisher-gui ros-foxy-joint-state-publisher sudo apt install ros-foxy-xacro Download the source code cd ~/dev_ws git clone -b ros2 https://github.com/ros/urdf_tutorial.git src/urdf_tutorial Compiling the source code colcon build --packages-select urdf_tutorial Running the example ros2 launch urdf_tutorial display.launch.py model:=urdf/01-myfirst.urdf 2.9 Launch The launch system in ROS 2 is responsible for helping the user describe the configuration of their system and then execute it as described. The configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS-specific conventions which make it easy to reuse components throughout the system by giving them each a different configuration. It is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes. Launch files written in Python, XML, or YAML can start and stop different nodes as well as trigger and act on various events. Specific reference: Official Tutorials Setup Create a new directory to store your launch files: mkdir launch Writer the launch file Let’s put together a ROS 2 launch file using the turtlesim package and its executables. As mentioned above. Copy and paste the complete code into the launch/turtlesim_mimic_launch.py file: from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description(): return LaunchDescription([ Node( package='turtlesim', namespace='turtlesim1', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', namespace='turtlesim2', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', executable='mimic', name='mimic', remappings=[ ('/input/pose', '/turtlesim1/turtle1/pose'), ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'), ] ) ]) Run the ros2 launch file To run the launch file created above, enter into the directory you created earlier and run the following command: The syntax format is: ros2 launch cd launch ros2 launch turtlesim_mimic_launch.py launch help ros2 launch -h running node ros2 launch turtlesim multisim.launch.py Check the parameters of the launc file ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py -s ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py --show-arguments ros2 launch turtlebot3_bringup robot.launch.launch.py -s Run the launch file with parameters ros2 launch turtlebot3_bringup robot.launch.launch.py usb_port:=/dev/opencr Run the node and debug ros2 launch turtlesim turtlesim_node.launch.py -d Only output node description ros2 launch turtlesim turtlesim_node.launch.py -p running components ros2 launch composition composition_demo.launch.py 2.10 Run run is used to run a single node, component program run help ros2 run -h running node ros2 run turtlesim turtlesim_node Run node with parameters ros2 run turtlesim turtlesim_node --ros-args -r __node:=turtle2 -r __ns:=/ns2 Run component container ros2 run rclcpp_components component_container running components ros2 run composition manual_composition 2.11 Package A package can be considered a container for your ROS 2 code. If you want to be able to install your code or share it with others, then you’ll need it organized in a package. With packages, you can release your ROS 2 work and allow others to build and use it easily. Package creation in ROS 2 uses ament as its build system and colcon as its build tool. You can create a package using either CMake or Python, which are officially supported, though other build types do exist. Specific reference: Official Tutorials Creating a workspace Create a new directory for every new workspace. The name doesn’t matter, but it is helpful to have it indicate the purpose of the workspace. Let’s choose the directory name ros2_ws, for “development workspace”: mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src pkg help ros2 pkg -h List Feature Packs ros2 pkg executable turtlesim Output a function package executable program ros2 pkg executable turtlesim Create a Python package Make sure you are in the src folder before running the package creation command. cd ~/ros2_ws/src The command syntax for creating a new package in ROS 2 is: ros2 pkg create --build-type ament_python # you will use the optional argument --node-name which creates a simple Hello World type executable in the package. ros2 pkg create --build-type ament_python --node-name my_node my_package Build a package Putting packages in a workspace is especially valuable because you can build many packages at once by running colcon build in the workspace root. Otherwise, you would have to build each package individually. # Return to the root of your workspace: cd ~/ros2_ws # Now you can build your packages: colcon build Source the setup file To use your new package and executable, first open a new terminal and source your main ROS 2 installation. Then, from inside the ros2_ws directory, run the following command to source your workspace: source install/setup.bash Now that your workspace has been added to your path, you will be able to use your new package’s executables. Use the package To run the executable you created using the --node-name argument during package creation, enter the command: ros2 run my_package my_node ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.3-RVIZ2_Introduction.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.3-RVIZ2_Introduction.html","title":"6.3.3 Rivz2Use","keywords":"","body":"Brief Introduction And Use Of Rviz2 Rviz2 is a visualization tool for displaying messages in the robot environment, providing a 3D perspective to view the robot's status and activities. It can help developers better understand the current status and activities of the robot, as well as other visual messages. Rviz2 provides a series of visualization tools that can help developers better understand the status and activities of robots, such as visual coordinate systems, laser scanning messages, point cloud messages, robot models, etc. Using Rviz2, robotic systems can be easily viewed and debugged to better achieve robotic goals. 1 Introduction To Rviz2 The successful installation of ros2 indicates that rviz2 is also successfully installed together, because the installation of ros2 includes rviz2. Open a new terminal (shortcutCtrl+Alt+T)enter the command to open rviz2 ros2 run rviz2 rviz2 # 或 rviz2 Open rviz2 and display the following interface: Introduction of each area On the left is the list of monitors, a monitor is something that draws something in the 3D world and may have some options available in the display list. Including functions such as adding, deleting, copying, renaming plug-ins, displaying plug-ins, and setting plug-in properties. Above is the toolbar, which allows users to use various function buttons to select tools with multiple functions The middle part is the 3D view: it is the main screen where various data can be viewed in 3D. The background color, fixed frame, grid, etc. of the 3D view can be set in detail in the Global Options and Grid items displayed on the left. Below is the time display area, including system time and ROS time. The right side is the observation angle setting area, and different observation angles can be set. We only give a rough introduction in this part. If you want to know more detailed content, you can go to the user guide to view it. 2 Simple Use Launch through launch file This example is based on the fact that you have completed Environment Setup and successfully copied the company's code from GitHub. Open a console terminal (shortcut key Ctrl+Alt+T) Enter the following command to configure ROS2 environment. cd ~/colcon_ws/ colcon build --symlink-install source install/setup.bash Enter again: ros2 launch mycobot_pro_450 test.launch.py Open rviz2 and get the following result: If you want to know more information about rviz, you can go to the official documentation to view it. ← Previous Page | Next Page→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.4-Basic_Functions.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.4-Basic_Functions.html","title":"6.3.4 BasicFunctionCases","keywords":"","body":"Controlling The Robotic Arm Note: The pymycobot driver library version must be greater than 4.0.0. Moveit2 only supports the ROS2 Humble version. Please use the code from the corresponding branch. Pre-use Preparation Before using the sample functions, please ensure that the following hardware and environment are complete: Hardware MyCobot Pro 450 robot arm Network cable (for connecting the robot arm to the computer) Power adapter Emergency stop switch (for safe operation) Software and Environment Python 3.6 or later installed The pymycobot library installed (using the pip install pymycobot terminal command) Ensure that the MyCobot Pro 450 is properly powered on and in standby mode. Note: The Pro 450 server automatically starts upon powering on; no manual operation is required. Network Configuration MyCobot Pro 450 default IP address: 192.168.0.232 Default port number: 4500 Note: PC The local network card IP address must be set to the same network segment as the robot (e.g., 192.168.0.xxx, where xxx is a number between 2 and 254 and must not conflict with the robot). For detailed configuration instructions, please refer to the section on Static IP Configuration. Example: Robot IP: 192.168.0.232 PC IP: 192.168.0.100 Subnet mask: 255.255.255.0 DNS server: 114.114.114.114 Verification: After completing the network configuration, execute the following command on the PC terminal. If data packets are successfully returned, the network connection is normal: ping 192.168.0.232 ROS2 Environment Setup Before using this example, please ensure that you have completed the ROS2 environment setup and ROS2 code update. 1 Slider Control Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 slider_control.launch.py # If the end-user is equipped with a myGripper F100 force-controlled gripper, run: ros2 launch mycobot_pro_450 slider_control_force_gripper.launch.py This will open rviz2 and a slider component, and you will see something like the following: If the end-user is equipped with a myGripper F100 force-controlled gripper, you will see the following interface: You can then control the model's movement in rviz2 by dragging the slider. The real mycobot will also move accordingly. Note: Since the robot arm will move to the model's current position as you enter commands, please ensure that the model in rviz does not clip before using these commands. Avoid dragging the slider quickly after connecting the robot arm to prevent damage to the arm. 2 Model Following In addition to the above controls, we can also make the model follow the movements of the real robot arm. Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 mycobot_follow.launch.py After running successfully, all joints of the robot arm are released. It will also open rviz to display the model following effect. Now, drag the real robot arm joints, and the simulation model will follow the real robot arm's movements. After running successfully, you need to simultaneously hold down the button at the end of the machine to drag the joint. The terminal output is as follows: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [12048] [INFO] [follow_display-2]: process started with pid [12050] [INFO] [rviz2-3]: process started with pid [12052] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link link1 had 1 children [robot_state_publisher-1] Link link2 had 1 children [robot_state_publisher-1] Link link3 had 1 children [robot_state_publisher-1] Link link4 had 1 children [robot_state_publisher-1] Link link5 had 1 children [robot_state_publisher-1] Link link6 had 0 children [robot_state_publisher-1] [INFO] [1757408024.256520696] [robot_state_publisher]: got segment base [robot_state_publisher-1] [INFO] [1757408024.256679159] [robot_state_publisher]: got segment link1 [robot_state_publisher-1] [INFO] [1757408024.256692374] [robot_state_publisher]: got segment link2 [robot_state_publisher-1] [INFO] [1757408024.256697373] [robot_state_publisher]: got segment link3 [robot_state_publisher-1] [INFO] [1757408024.256701681] [robot_state_publisher]: got segment link4 [robot_state_publisher-1] [INFO] [1757408024.256705999] [robot_state_publisher]: got segment link5 [robot_state_publisher-1] [INFO] [1757408024.256710327] [robot_state_publisher]: got segment link6 [rviz2-3] [INFO] [1757408024.565241287] [rviz2]: Stereo is NOT SUPPORTED [rviz2-3] [INFO] [1757408024.565493504] [rviz2]: OpenGl version: 3.1 (GLSL 1.4) [rviz2-3] [INFO] [1757408024.647227371] [rviz2]: Stereo is NOT SUPPORTED [follow_display-2] [INFO] [1757408024.783281010] [follow_display]: ip:192.168.0.232, port:4500 [rviz2-3] Parsing robot urdf xml string. [follow_display-2] [INFO] [1757408024.905252117] [follow_display]: Please press the button at the end of the machine to drag the joint. [follow_display-2] [INFO] [1757408024.905252117] [follow_display]:请按下机器末端按钮进行关节拖拽运动 [follow_display-2] [INFO] [1757408024.937815658] [follow_display]: Publishing ... 3 GUI Control Building on the previous functionality, this package also provides a simple graphical user interface. This approach requires that the actual robotic arm be connected to each other; please connect to mycobot. Open a command line: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 simple_gui.launch.py # If the end-device is equipped with a myGripper F100 force-controlled gripper, run: ros2 launch mycobot_pro_450 simple_gui_force_gripper.launch.py If the end-device is equipped with a myGripper F100 force-controlled gripper, you will see the following interface: After successful execution, the terminal output is as follows: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [17196] [INFO] [rviz2-2]: process started with pid [17198] [INFO] [listen_real_service-3]: process started with pid [17200] [INFO] [simple_gui-4]: process started with pid [17202] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link link1 had 1 children [robot_state_publisher-1] Link link2 had 1 children [robot_state_publisher-1] Link link3 had 1 children [robot_state_publisher-1] Link link4 had 1 children [robot_state_publisher-1] Link link5 had 1 children [robot_state_publisher-1] Link link6 had 0 children [robot_state_publisher-1] [INFO] [1757414162.529535554] [robot_state_publisher]: got segment base [robot_state_publisher-1] [INFO] [1757414162.530006477] [robot_state_publisher]: got segment link1 [robot_state_publisher-1] [INFO] [1757414162.530445098] [robot_state_publisher]: got segment link2 [robot_state_publisher-1] [INFO] [1757414162.530788098] [robot_state_publisher]: got segment link3 [robot_state_publisher-1] [INFO] [1757414162.531159021] [robot_state_publisher]: got segment link4 [robot_state_publisher-1] [INFO] [1757414162.531476222] [robot_state_publisher]: got segment link5 [robot_state_publisher-1] [INFO] [1757414162.531788353] [robot_state_publisher]: got segment link6 [listen_real_service-3] [INFO] [1757414163.139592125] [listen_real_service]: ip:192.168.0.232, port:4500 [rviz2-2] [INFO] [1757414163.306409248] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] [INFO] [1757414163.306709577] [rviz2]: OpenGl version: 3.1 (GLSL 1.4) [rviz2-2] [INFO] [1757414163.372621603] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] Parsing robot urdf xml string. Then, enter the relevant angles and coordinates in the GUI and click the corresponding buttons to synchronize the motion of the real machine with the simulation model. Note: Before using the gripper switch button, ensure that the adaptive gripper is connected to the end-of-arm robot. 4 Keyboard Control Keyboard control functionality has been added to the mycobot_pro_450 package, and is synchronized in real time within rviz2. This functionality relies on the Python API, so ensure that it is connected to the real robot arm. Open a command line and run: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 launch mycobot_pro_450 teleop_keyboard.launch.py # If the end-device is equipped with a myGripper F100 force-controlled gripper, run: ros2 launch mycobot_pro_450 teleop_keyboard_force_gripper.launch.py The following display appears: If the end-device is equipped with a myGripper F100 force-controlled gripper, the following interface appears: The command line will output the following information about mycobot: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [robot_state_publisher-1]: process started with pid [13684] [INFO] [rviz2-2]: process started with pid [13686] [INFO] [listen_real_service-3]: process started with pid [13688] [robot_state_publisher-1] Parsing robot urdf xml string. [robot_state_publisher-1] Link link1 had 1 children [robot_state_publisher-1] Link link2 had 1 children [robot_state_publisher-1] Link link3 had 1 children [robot_state_publisher-1] Link link4 had 1 children [robot_state_publisher-1] Link link5 had 1 children [robot_state_publisher-1] Link link6 had 0 children [robot_state_publisher-1] [INFO] [1757409378.488848950] [robot_state_publisher]: got segment base [robot_state_publisher-1] [INFO] [1757409378.489029099] [robot_state_publisher]: got segment link1 [robot_state_publisher-1] [INFO] [1757409378.489038676] [robot_state_publisher]: got segment link2 [robot_state_publisher-1] [INFO] [1757409378.489043355] [robot_state_publisher]: got segment link3 [robot_state_publisher-1] [INFO] [1757409378.489047552] [robot_state_publisher]: got segment link4 [robot_state_publisher-1] [INFO] [1757409378.489051760] [robot_state_publisher]: got segment link5 [robot_state_publisher-1] [INFO] [1757409378.489055988] [robot_state_publisher]: got segment link6 [rviz2-2] [INFO] [1757409378.801155196] [rviz2]: Stereo is NOT SUPPORTED [rviz2-2] [INFO] [1757409378.801390966] [rviz2]: OpenGl version: 3.1 (GLSL 1.4) [rviz2-2] [INFO] [1757409378.860460962] [rviz2]: Stereo is NOT SUPPORTED [listen_real_service-3] [INFO] [1757409379.155013599] [listen_real_service]: ip:192.168.0.232, port:4500 [rviz2-2] Parsing robot urdf xml string. Next, open another command line: ros2 run mycobot_pro_450 teleop_keyboard # If the end-device is equipped with a myGripper F100 force-controlled gripper, run: ros2 run mycobot_pro_450 teleop_keyboard_force_gripper You will see the following output in the terminal: Mycobot Teleop Keyboard Controller --------------------------- Movimg options(control coordinations [x,y,z,rx,ry,rz]): w(x+) a(y-) s(x-) d(y+) z(z-) x(z+) u(rx+) i(ry+) o(rz+) j(rx-) k(ry-) l(rz-) +/- : Increase/decrease movement step size Force Gripper control: g - open h - close Other: 1 - Go to init pose 2 - Go to home pose 3 - Resave home pose q - Quit currently: speed: 50 change percent: 5 In this terminal, you can control the robot arm's state and move it using command-line keys. Note: After entering 2 to return the robot to the starting point, the following prompt will appear in the terminal before performing other coordinate control operations: [WARN] [1758001794.385321]: Coordinate control disabled. Please press '2' first. [INFO] [1758001804.552778]: Home pose reached. Coordinate control enabled. [INFO] [1758001817.069637]: Home pose reached. Coordinate control enabled. [WARN] [1758001836.301070]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001848.830702]: Coordinate control disabled. Please press '2' first. [INFO] [1758001863.383565]: Home pose reached. Coordinate control enabled. [WARN] [1758001933.596504]: Returned to zero. Press '2' to enable coordinate control. [WARN] [1758001942.051899]: Coordinate control disabled. Please press '2' first. 5 Moveit2 Use Note: Moveit2 only supports the ROS2 Humble version. Please use the corresponding branch to run the code. mycobot_ros2 integrates the MoveIt component. Open a command line and run: ros2 launch pro450_moveit2 demo.launch.py The result is as follows: The terminal will output the following message, indicating that Moveit has been successfully launched: [move_group-3] You can start planning now! [move_group-3] [ros2_control_node-5] [INFO] [1757486383.454753341] [controller_manager]: Loading controller 'joint_state_broadcaster' [rviz2-4] [INFO] [1757486383.456108372] [rviz2]: Stereo is NOT SUPPORTED [spawner-7] [INFO] [1757486383.502228729] [spawner_joint_state_broadcaster]: Loaded joint_state_broadcaster [spawner-6] [INFO] [1757486383.564310311] [spawner_arm_group_controller]: Configured and activated arm_group_controller [rviz2-4] Warning: class_loader.impl: SEVERE WARNING!!! A namespace collision has occurred with plugin factory for class rviz_default_plugins::displays::InteractiveMarkerDisplay. New factory will OVERWRITE existing one. This situation occurs when libraries containing plugins are directly linked against an executable (the one running right now generating this message). Please separate plugins out into their own library or just don't link against the library and use either class_loader::ClassLoader/MultiLibraryClassLoader to open. [rviz2-4] at line 253 in /opt/ros/humble/include/class_loader/class_loader/class_loader_core.hpp [ros2_control_node-5] [INFO] [1757486383.610227041] [controller_manager]: Configuring controller 'joint_state_broadcaster' [ros2_control_node-5] [INFO] [1757486383.610628892] [joint_state_broadcaster]: 'joints' or 'interfaces' parameter is empty. All available state interfaces will be published [spawner-7] [INFO] [1757486383.736878229] [spawner_joint_state_broadcaster]: Configured and activated joint_state_broadcaster [INFO] [spawner-6]: process has finished cleanly [pid 100700] [INFO] [spawner-7]: process has finished cleanly [pid 100703] [rviz2-4] [ERROR] [1757486386.668318057] [moveit_ros_visualization.motion_planning_frame]: Action server: /recognize_objects not available [rviz2-4] [INFO] [1757486386.684028956] [moveit_ros_visualization.motion_planning_frame]: MoveGroup namespace changed: / -> . Reloading params. [rviz2-4] [INFO] [1757486386.975209646] [moveit_rdf_loader.rdf_loader]: Loaded robot model in 0.105952 seconds [rviz2-4] [INFO] [1757486386.975348906] [moveit_robot_model.robot_model]: Loading robot model 'firefighter'... [rviz2-4] [INFO] [1757486387.253639370] [moveit_ros.planning_scene_monitor.planning_scene_monitor]: Starting planning scene monitor [rviz2-4] [INFO] [1757486387.255326862] [moveit_ros.planning_scene_monitor.planning_scene_monitor]: Listening to '/monitored_planning_scene' [rviz2-4] [INFO] [1757486387.353487213] [interactive_marker_display_104041531794736]: Connected on namespace: /rviz_moveit_motion_planning_display/robot_interaction_interactive_marker_topic [rviz2-4] [INFO] [1757486387.358813947] [moveit_ros_visualization.motion_planning_frame]: group arm_group [rviz2-4] [INFO] [1757486387.358844123] [moveit_ros_visualization.motion_planning_frame]: Constructing new MoveGroup connection for group 'arm_group' in namespace '' [rviz2-4] [INFO] [1757486387.372219842] [move_group_interface]: Ready to take commands for planning group arm_group. [rviz2-4] [INFO] [1757486387.404744042] [interactive_marker_display_104041531794736]: Sending request for interactive markers [rviz2-4] [INFO] [1757486387.463143847] [interactive_marker_display_104041531794736]: Service response received for initialization Basic path planning operations are as follows: If you want to synchronize the plan with the actual robot arm, you need to open another command line and run the following command: # The default IP address of the Pro450 is \"192.168.0.232\" and the port number is 4500. ros2 run pro450_moveit2_control sync_plan Modifying the Movement Speed To prevent joints from shaking during actual robot arm movement, you need to reduce the joint movement speed. In the sync_plan.py file, modify the speed parameter of the robotic arm Python API to 25. Note: After changing the speed, you need to recompile for it to take effect: cd ~/colcon_ws source install/setup.bash ... def listener_callback(self, msg): \"\"\"Callback to process received joint states. Converts joint positions from radians to degrees, rearranges them according to the RViz order, and sends them to the robot. Args: msg (JointState): The message containing joint names and positions. \"\"\" # Create a mapping of joint names to their position values joint_state_dict = {name: msg.position[i] for i, name in enumerate(msg.name)} # Rearrange joint angles according to RViz order data_list = [] for joint in self.rviz_order: if joint in joint_state_dict: radians_to_angles = round( math.degrees(joint_state_dict[joint]), 2) data_list.append(radians_to_angles) self.get_logger().info(f'joint_angles: {data_list}') self.mycobot_450.send_angles(data_list, 25) ... In the Moveit RViz interface, modify the velocity and acceleration scaling. Here, change it to 0.1 and save the current configuration. ← Previous Page | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.5-Troubleshooting.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.3-ROS2/6.3.5-Troubleshooting.html","title":"6.3.5 CommonProblemsAndSolutions","keywords":"","body":"ROS1 Common Problems and Solutions When using ROS1 to control the MyCobot Pro 450, you may encounter some common problems. Below is a list of common errors and their corresponding solutions for quick troubleshooting. 1 Environment-Related Issues Issue 1: Running ros2 launch results in the error package 'mycobot_pro_450' not found Cause: The ROS workspace was not compiled correctly or the environment variables were not loaded Solution:cd ~/colcon_ws colcon build source install/setup.bash 2 Network Communication Issues Issue 1: Error: \"Trying to connect to real MyCobot Pro450... Timeout\" Cause: The PC and robot are not on the same network segment, or the IP address is incorrectly set Solution: Confirm that the robot's default IP address is 192.168.0.232 Set the PC network card to the same network segment, for example, 192.168.0.100 Test connectivity: ping 192.168.0.232 3 Python API/Library Issues Issue 1: Runtime Error ModuleNotFoundError: No module named 'pymycobot' Cause: pymycobot is not installed in the Python environment Solution: pip3 install pymycobot Issue 2: Runtime Error ImportError: cannot import name 'Pro450Client' from 'pymycobot' Cause: pymycobot version is too low Solution: pip install -U pymycobot Issue 3: Runtime Error RuntimeError: The version of the pymycobot library must be greater than 3.9.9 or higher. The current version is 3.9.7. Please upgrade the library version. Cause: Pymycobot version is too low Solution: pip install -U pymycobot Note: Version must be greater than 4.0.0 4 ROS Node Operation Issues Problem 1: Model not displayed after opening in rviz Cause 1: robot_description not loaded correctly Solution: Check that the ros2 launch command is complete In the terminal, enter: ros2 param list | grep robot_description If you see the /robot_description parameter, the model has been loaded. Please check that the joint_state_publisher and robot_state_publisher are running properly. Use the ros2 topic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Problem 2: After opening rviz, the model is incomplete, and the terminal continuously outputs a warning message similar to: Warning [Invalid frame ID \"base\" passed to canTransform argument target frame frame does not exist rviz2-2] rviz2-2 at line 133 in /tmp/binarydeb/ros-foxy-tf2-0.13.13/src/buffer core.cpp Cause 1: Robot communication is abnormal and angle coordinates cannot be read normally. Solution: Is joint_states being published (a message will be printed)? In the terminal, enter: rostopic echo -n 5 /joint_states If /joint_states does not output anything, it is likely that the robot communication or the mycobot service is not receiving data. Please check that joint_state_publisher and robot_state_publisher are running properly. - Use the ros2 topic list command to confirm the existence of /joint_states, /tf, and /tf_static. These are necessary topics for model display and motion. Check the robot's communication status. For details, see Python Exception Handling Check whether the robot can read angles and coordinates normally. from pymycobot import Pro450Client mc = Pro450Client('192.168.0.232', 4500) if mc.is_power_on() != 1: mc.power_on() print(mc.get_angles(), mc.get_coords()) Problem 3: Error message: [WARN]: Coordinate control disabled. Please press '2' first. Solution: First enter 2 on the keyboard control interface to return the robot to its starting point, then resume coordinate control "},"3-FunctionsAndApplications/6.developmentGuide/6.4-Cplus/README1.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.4-Cplus/README1.html","title":"6.4 C++","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/6.developmentGuide/6.5-CommunicationProtocolPackage/6.5-communication.html":{"url":"3-FunctionsAndApplications/6.developmentGuide/6.5-CommunicationProtocolPackage/6.5-communication.html","title":"6.5 SerialCommunicationProtocol","keywords":"","body":"Development and Use Based on Communication Protocol Packets Communication Settings Ethernet TCP/IP Bus Interface: Gigabit Ethernet Port IP: Static IP: 192.168.0.232; For Wi-Fi or Dynamic IP, please refer to the Connection interface on the screen. Port: 4500485 Modbus Bus Interface: Bottom 485 Baud Rate: 115200 Data Bits: 8 Parity: None Stop Bits: 1 Robotic arm motion and speed parameter table Joints minimum angle(°) maximum angle(°) maximum speed(°/s) maximum acceleration(°/s²) J1 -162 162 150 200 J2 -125 125 150 200 J3 -154 154 150 200 J4 -162 162 150 200 J5 -162 162 150 200 J6 -165 165 150 200 Coords minimum coord(mm) maximum coord(mm) maximum speed(mm/s) maximum acceleration(mm/s²) x -466 466 200 400 y -466 466 200 400 z -150 677 200 400 rx/ry/rz -180° 180° 40°/s 66°/s² Introduction to TCP/IP Commands for Network Interfaces Send and Receive Format Both sending and receiving are represented in hexadecimal. Each command contains 5 parts, as shown below: [Frame Header][Frame Header][Length][Function Code][Data][Checksum - High Byte][Checksum - Low Byte] Frame Header (2 bytes): 0xFE 0XFE Valid Length (1 byte): 3-N, length starts from the function code and ends with the checksum. Function Code (1 byte): 1-255 Data Bits: 0-N, high byte first. Frame Trailer: crc16-modbus, high byte first. All commands have first-level receive feedback; position mode control has position feedback. Basic Control Read Master Control Version Number Function Code: 02 Send Data Bits: None Feedback Data Bits: Version Number - 1 byte, requires /10.0 Send Command: FE FE 03 02 0D D1 Feedback Command Example: FE FE 04 02 0A 51 7D, where the version number is V1.0 Read End Version Number Function Code: 09 Send Data Bits: None Feedback Data Bits: Byte 1: Version Number, requires /10.0 Start Robot Function Code: 0x10 Send Data Bits: None Feedback Data Bits: Byte 1: Startup Status, 0-2; 0 - Startup Failed, 1 - Startup Successful, 2 - Emergency Stop Triggered Shut down the robot Function code: 0x11 Send data bits: None Feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Feedback command: FE FE 05 11 FF 01 E8 EC Read robot startup status Function code: 0x12 Send data bits: None Feedback data bits: Byte 1: Startup status, 0-2; 0-Startup failed 1-Startup successful 2-Emergency stop triggered Read zero-position calibration status Function code: 0x5A Send data bits: None Feedback data bits: Byte 1: 0/1; Overall zero-position calibration status Bytes 2-7: 1X6 joint zero-position calibration status Switch Modbus communication Function code: 0x6A Send data bits: Byte 1: 0/1 1 - On, 0 - Off. Default is Off.Modbus Send Command: FE FE 04 6A 01 9D 92 Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Read Modbus Communication Status Function Code: 0x6B Send Data Bits: None Feedback Data Bits: Byte 1: Status 0/1 1 - On, 0 - Off Motion Control Motion control speed range: 1-100, please refer to the above table of robotic arm motion and speed parameters for actual speed percentage. Motion modes: Position interpolation, refresh interruption, torque; only position interpolation provides motion positioning feedback. Position positioning feedback data: FE FE 04 5B Status CRC-High CRC-Low; Normal motion command: FE FE 04 5B 00 CD 46; Abnormal motion command - J6 over-limit: FE FE 04 5B 06 CF C6 Full joint angle control Function code: 0x22 Send data bits: Bytes 1-12: 2X6 joint angle (angle * 100.0) Byte 13: Speed [90, 10, -90, 45, 80, -100], running speed 50%, send command: FE FE 10 22 23 28 03 E8 DC D8 11 94 1F 40 27 10 32 E3 57 First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Second-level position feedback: Only available in interpolation motion mode,FE FE 04 5B 00 CD 46` Single joint angle control Function code: 0x21 Send data bits: Byte 1: Joint; Bytes 2-3: Angle (angle * 100.0) Byte 4: SpeedJ1 moves to 50°, running speed 10%, send command: FE FE 07 21 01 13 88 0A 82 7A First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Read All Joint Angles Function Code: 0x20Send Data Bits: None Feedback Data Bits: Bytes 1-12: 2x6 Joint Angles (Angle/100.0) [90, 10, -90, 45, 80, -100] Feedback Command: FE FE 10 20 23 28 03 E8 DC D8 11 94 1F 40 27 10 32 21 54 Full Coordinate Control Function Code: 0x25 Send Data Bits: Bytes 1-12: 2x6 Coordinates (XYZ10.0, RXRYRZ100.0) Byte 13: Speed First Layer Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Single coordinate control Function code: 0x24 Send data bits: Byte 1: Coordinate axis; Bytes 2-3: Coordinate (XYZ10.0, RXRYRZ100.0) Byte 4: Velocity First layer feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Read full coordinates Function code: 0x23 Send data bits: None Feedback data bits: Bytes 1-12: 2X6 coordinate (XYZ/10.0, RXRYRZ/100.0) Read robot motion status Function code: 0x2BSend data bits: None Feedback data bits: Byte 1: Motion status 0/1, 0 - not moving; 1 - moving Detecting if the robot has reached the designated point Code: 0x2A, Error accuracy within 1° angle, within 2mm coordinates Send Data Bits: Bytes 1-12: 26 joint angles/coordinates (angle 100.0, coordinates XYZ 10.0, RXRYRZ 100.0); Byte 13: Mode 1/2 1-Angle 2-Coordinate Feedback Data Bits: Byte 1: Position Status 0/1 0-Not in position, 1-In position Motion Pause Function Code: 0x26 Send Data Bits: None Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Motion Resumption Function Code: 0x28 Send Data Bits: None Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Movement End Function Code: 0x29 Send Data Bits: None Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Detect Movement Pause Function Code: 0x27 Send Data Bits: NoneFeedback Data Bits: Byte 1: Pause Status 0/1, 0 - Not Manually Paused; 1 - Paused Continuous Joint Movement Function Code: 0x30 Send Data Bits: Byte 1: Joint; Byte 2: Direction 0/1 0 - Reverse Rotation 1 - Forward Rotation Byte 3: Speed First Layer Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Continuous Coordinate Movement Function Code: 0x32 Send Data Bits: Byte 1: Coordinate Axis; Byte 2: Direction 0/1 0 - Reverse Rotation 1-Forward Rotation Byte 3: Speed First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01 RPY Rotation Function Code: 0xF5 Send Data Bits: Byte 1: Mode 1-3 1-Roll Angle 2-Pitch Angle 3-Yaw Angle; Byte 2: Direction 0/1 0-Reverse Rotation 1-Forward Rotation Byte 3: Speed First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Joint Stepping Control Function Code: 0x33 Send Data Bits: Byte 1: Joint; Bytes 2-3: Step Value * 100.0 Byte 3: Speed First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Coordinate Stepping Control Function Code: 0x34 Send Data Bits: Byte 1: Coordinate Axis; Bytes 2-3: Step Value (XYZ10.0, RXRYRZ100.0) Byte 4: Velocity First Layer Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Calculate Inverse Kinematics Function Code: 0x8D Send Data Bits: Bytes 1-12: Current Angle of 2x6 Joint Bytes 13-26: Target Coordinate Value of 2x6 Joint Feedback Data Bits: Bytes 1-24: Angle of 4x6 Joint (/100.0) Start Drag Teaching Function Code: 0x70 Send Data Bits: None Feedback Data Bits: 0xFF 0x01 Pause Sampling Function Code: 0x72 Send Data Bits: None Feedback Data Bits: 0xFF 0x01 Execute Teaching Point Function Code: 0x71 Send Data Bits: None Feedback Data Bits: 0xFF 0x01 Clear Sampling Point Function Code: 0x73 Send Data Bits: None Feedback Data Bits: 0xFF 0x01 Query Collision Detection Mode Function Code: 0xFD Send Data Bits: None Feedback Data Bits: Byte 1: 0/1, 1-open 0-close Set Collision Detection Mode Function Code: 0x74 Send Data Bits: 1-open 0-close After enabling collision detection, the robotic arm will automatically stop if a collision lasting longer than 200ms and exceeding the collision threshold occurs during movement. Feedback Data Bits: 0xFF 0x01 Set Collision Threshold Function Code: 0x75 Send Data Bits: Byte 1: joint range:(1-6) Byte 2: radio range:(50-250)% You can set the collision threshold for the joints. The default value is 100%. The smaller the value, the easier it is to trigger a collision. Feedback Data Bits: 0xFF 0x01 Get Collision Threshold Function Code: 0x76 Send Data Bits: None Feedback Data Bits: Bytes 1-6: Collision threshold for all joints Set Torque Compensation Coefficient Function Code: 0x77 Send Data Bits: Byte 1: joint range:(1-6) Byte 2: radio range:(0-250)% Friction compensation coefficient for the torque ring. The default value is 0. The larger the coefficient, the easier it is to drag. Byte 3: Damping: 0-close 1-open Impedance switch, default is off. Turning it on increases damping; higher damping makes it harder to drive. Feedback data bits: 0xFF 0x01 Obtain Torque Compensation Coefficient Function Code: 0x78 Send Data Bits: None Feedback Data Bits: Bytes 1-6: Full-Joint Torque Compensation Coefficient Bytes 7-12: Full-Joint Impedance Switch Execute Dynamic Trajectory Identification Function Code: 0xF8 Send Data Bits: Byte 1: rank (0-1), 0: Identify Trajectory, 1: Low-Speed ​​Identify Trajectory Feedback Data Bits: 0xFF 0x01 Execute the trajectory identification, which takes 24 seconds. The movement is relatively large, so please pay attention to safety. Before use, you need to execute the low-speed trajectory using fourier_trajectories(1) to confirm the safe range. After the low-speed execution is completed, execute the normal speed fourier_trajectories(0). Dynamic parameter identification Function code: 0x97 Send data bits: None Feedback data bits: 0xFF 0x01 One-click identification requires first executing the dynamic trajectory identification to generate the identify_data.log file. The identification takes five minutes. After the identification is completed, the identification accuracy will be automatically calculated. If the accuracy meets the standard, it will be automatically written to the dynamic_paremeters.log file. Circular Trajectory Motion Function Code: 0x8C Send Data Bits: Circular Trajectory Points (transpoint) Circular End Points (endpoint) Bytes 1-2: transpoint.x (10) Bytes 13-14: endpoint.x (10) Byte 25: speed (1-100) Bytes 3-4: transpoint.y Bytes 15-16: endpoint.y Bytes 5-6: transpoint.z Bytes 17-18: endpoint.z Bytes 7-8: transpoint.rx (100) Bytes 19-20: endpoint.rx (100) Bytes 9-10: transpoint.ry Bytes 21-22: endpoint.ry Bytes 11-12: transpoint.rz Bytes 23-24: endpoint.rz Feedback data bits: 0xFF 0x01 Based on the current position of the robotic arm (starting point), the given arc transit point (transpoint), and the arc ending point (endpoint), an arc is determined by these three points, causing the robotic arm to execute the arc trajectory in the order of starting point, transit point, and ending point. Set Motion Mode This interface takes a relatively long time to execute, approximately 4ms. Function code: 0x16 Send data bits: Byte 1: Mode 0/1 0-Position 1-Refresh, the robot intelligently uses refresh mode; default is position mode. Feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Read Motion Mode Function code: 0x17 Send data bits: None Feedback data bits: Byte 1: Mode 0/1 0-Position 1-Refresh Set Motion Control Mode This interface takes a relatively long time to execute, approximately 4ms. Function Code: 0x1E Send Data Bits: Byte 1: Mode 0/1 0-Position 1-Torque, zero-force drag; Default position mode Feedback Data Bits: Byte 1: 0xFF, Byte 2: 0/1 0-Setting failure, incorrect parameters; 1-Parameter correct Read Motion Control Mode Function Code: 0x1F Send Data Bits: None Feedback Data Bits: Byte 1: Mode 0/1 0-Position 1-Torque, zero-force drag Over-limit Return to Zero After exceeding the limit, manual movement back to the limit is not required; currently only supported in position mode, not in refresh mode control. Function Code: 04 Send Data Bits: None Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Auxiliary Functions Configuration Zero position setting is required after system update before movement. Setting Zero Position Function Code: 0x54 Send Data Bits: Byte 1: Joint Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Setting Robot Torque Status Function Code: 0x13 Send Data Bits: Byte 1: Joints 1-6 254-All; Byte 2: Mode 0/1 0-Disabled 1-Enabled; Movement is only possible when enabled Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Setting RGB Color Function Code: 0x0C Send Data Bits: Bytes 1-3: R, G, B Range 0-255, All 0s-Lights off Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Set Maximum Speed Function Code: 0x41 Send Data Bits: Byte 1: Mode 0/1 0-Angle 1-Coordinate Bytes 2-3: Speed, set only within the maximum range Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Set Maximum Acceleration Function Code: 0x43Send Data Bits: Byte 1: Mode 0/1 0-Angle 1-Coordinate Bytes 2-3: Acceleration, set only within the maximum range Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Read Maximum Speed Function Code: 0x40 Send Data Bits: None Feedback Data Bits: Bytes 1-2: Speed Read Maximum Acceleration Function Code: 0x42 Send Data Bits: None Feedback Data Bits: Bytes 1-2: Acceleration Set Joint Minimum Angle Function Code: 0x4c Send Data Bits: Byte 1: Joint Bytes 2-3: Minimum Angle * 10.0; Can only be set within the default range, no error will occur upon power failure Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Read Joint Minimum Angle Function Code: 0x4a Send Data Bits: Byte 1: Joint Feedback Data Bits: Bytes 1-2: Minimum Angle / 10.0 Set Joint Maximum Angle Function Code: 0x4d Send Data Bits: Byte 1: Joint Bytes 2-3: Maximum angle * 10.0; can only be set within the default range, no error will occur upon power failure. Feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Read the maximum angle of the joint Function code: 0x4b Send data bits: Byte 1: Joint Feedback data bits: Bytes 1-2: Maximum angle / 10.0 Set the joint direction Pls move to zero position,then read the current direction first, latest set it Function code: 0x7D Send data bits: Byte 1: Joint Byte 2: Direction 0/1 1-Same direction 0-Opposite direction Feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Read Joint Direction Function Code: 0x7C Send Data Bits: None Feedback Data Bits: Bytes 1-6: 1x6 Joint Direction Read VR ModeFunction Code: 0x79 Send Data Bits: None Feedback Data Bits: Byte: 1-open 0-close Enabling VR mode reduces the motion command buffer length from 80 to 2. Suitable for development scenarios where motion buffer accumulation is undesirable, such as VR control and remote control. Set VR Mode Function Code: 0x7a Send Data Bits: Byte: 1-open 0-close Feedback Data Bits: 0xFF 0x01 Set Free Movement Status Off by default. When enabled, the robotic arm can be manually rotated by pressing and holding the end button for 1 second. Function Code: 0x1A Send Data Bits: Byte 1: 1-open 0-close Feedback Data Bits: 0xFF 0x01 Read Free Movement Status Function Code: 0x1B Send Data Bits: None Feedback Data Bits: Byte 1: 1-open 0-close IO Control Bottom IO Set Base IO Output Function Code: 0xA0 Transmit Data Bits: Byte 1: Pin Number 1-12 Byte 2: Status 0/1 0 - Low 1 - High Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Read Base IO Input Function Code: 0xA1 Transmit Data Bits: Byte 1: Pin Number 1-12 Feedback Data Bits: Byte 1: Status 0/1 0 - Low 1 - High End IO Set End IO Output Function Code: 0x61 Transmit Data Bits: Byte 1: Pin Number 1/2 Byte 2: Status 0/1 0 - Low 1 - High Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Read all pin statuses at the end Function code: 0x7B Transmit data bits: None Feedback data bits: Byte 1: Input 1 status 0/1 0-low level 1-high level; Byte 2: Input 2 status; Byte 3: End button 1 status; Byte 4: End button 2 status External 485/CAN communication device control Bottom external device configuration Function code: 0x65 Transmit data bits: Byte 1: Mode 1/2 1-485 device 2-CAN device; Bytes 2-5: Baud rate; Bytes 6-9: Timeout Feedback fixed data bits: Bytes 1-2: 0xFF 0x01 Read bottom external device configuration Function code: 0x67 Transmit data bits: None Feedback data bits: Byte 1: Mode 1/2 1-485 device; 2-CAN device; Bytes 2-5: Baud rate; Bytes 6-9: Timeout Bottom External Device Control Function Code: 0x66 Send Data Bits: CAN Device: Bytes 1-4: CAN_id; Bytes 5-N: CAN data, maximum 8; 485 Device: 1-N: 485 data, maximum 100 Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 End 485 External Device Control Function Code: 0xB5 Send Data Bits: Bytes 1-N: 485 data, maximum 45 Feedback Data Bits: Bytes 1-N: 485 data returned by the device Set Terminator 485 Baud Rate Default 115200 Function Code: 0xB8 Send Data Bits: Bytes 1-4: Baud Rate Feedback Data Bits: 0xFF 0x01 Set Terminator 485 Timeout Default 10s Function Code: 0xB9 Send Data Bits: Bytes 1-2: Timeout, Unit: ms, Range: 1-10s Feedback Data Bits: 0xFF 0x01 Read Terminator 485 Baud Rate Timeout Function Code: 0xBA Send Data Bits: None Feedback Data Bits: Bytes 1-4: Baud Rate, Bytes 5-6: Timeout Status Query Read Robot Status Function Code: 0xA2 Send Data Bits: None Feedback Data Bits: Byte 1: Collision Detection Status 0/1 1-Collision; Byte 2: Movement Status 0/1 1-In Motion; Bytes 3-8: 1x6 Joint Exceeding Limits 0/1 1-Exceeding Limits; Bytes 9-20: 2x6 Joint Motor Errors 0-Normal >0 Abnormal; Bytes 21-32: 2x6 Joint Motor Software Errors 0-Normal >0 Abnormal; See error messages and position feedback table for details. Read Motion Error Information Function Code: 0x07 Send Data Bits: None Feedback Data Bits: Bytes 1-2: Error Messages, see error messages and position feedback table for details. Read Joint Communication Error Count Function Code: 0xA3 Send Data Bits: Byte 1: Joints 1-6 Feedback Data Bits: Bytes 1-2: Joint Send Error Count 0-32700; Bytes 3-4: Joint Read Error Count 0-32700; Bytes 5-6: Endpoint Send Error Count 0-32700; Bytes 7-8: Endpoint Read Error Count 0-32700 Read Joint Running Speed Function Code: 0xE1 Send Data Bits: None Feedback Data Bits: Bytes 1-12: 2x6 Running Speed ​​/ 100.0 0-30rpm Get Joint Current Function Code: 0xE2 Send Data Bits: None Feedback Data Bits: Bytes 1-12: 2x6 Joint Current Unit: MA Set Coordinate System Set Tool Coordinate System Function Code: 0x81 Send Data Bits: Bytes 1-2: x (±1000) (10xmm) Bytes 3-4: y (±1000) Bytes 5-6: z (±1000) Bytes 7-8: rx (±180) (100xDeg) Bytes 9-10: ry (±180) Bytes 11-12: rz (±180) Feedback Data Bits: 0xFF 0x01 Read Tool Coordinate System Function Code: 0x82 Send Data Bits: None Feedback Data Bits: Bytes 1-2: x (±1000) (10xmm) Bytes 3-4: y(±1000) Bytes 5-6: z (±1000) Bytes 7-8: rx (±180) (100xDeg) Bytes 9-10: ry (±180) Bytes 11-12: rz (±180) Set World Coordinate System Function Code: 0x83 Data Bits Sent: Bytes 1-2: x (±1000) (10xmm) Bytes 3-4: y(±1000) Bytes 5-6: z (±1000) Bytes 7-8: rx (±180) (100xDeg) Bytes 9-10: ry (±180) Bytes 11-12: rz (±180) Feedback Data Bits: 0xFF 0x01 Read World Coordinate System Function Code: 0x84 Send Data Bits: None Feedback Data Bits: Bytes 1-2: x (±1000) (10xmm) Bytes 3-4: y (±1000) Bytes 5-6: z (±1000) Bytes 7-8: rx (±180) (100xDeg) Bytes 9-10: ry (±180) Bytes 11-12: rz (±180) Set Base Coordinate System Function Code: 0x85 Send Data Bits: Byte 1: base type (0-base coordinate system 1-world coordinate system) Feedback Data Bits: 0xFF 0x01 Read Base Coordinate System Function Code: 0x86 Send Data Bits: None Feedback Data Bits: Byte 1: base type (0-Base Coordinate System 1-World Coordinate System) Set End Coordinate System Function Code: 0x89 Send Data Bits: Byte 1: end type (0-Flange 1-Tool) Feedback Data Bits: 0xFF 0x01 Read End Coordinate System Function Code: 0x8A Send Data Bits: None Feedback Data Bits: Byte 1: end type (0-Flange 1-Tool) Error Clearing Clear Motion Errors Clear motion reading errors, such as exceeding limits, coordinates unreachable, etc. Function Code: 08 Send Data Bits: None Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Joint Abnormal Recovery Clear some joint motor errors Function Code: 0xE7 Send Data Bits: Byte 1: Joints 1-6, 254-All Joints Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01 Introduction to 485 Modbus RTU Commands Transmit/Receive Formats Basic Parameters Parameter Value (decimal) Value (hexadecimal) Address 45 0x2D Write Function Code 16 0x10 Read Function Code 03 0x03 Communication Frame Format 1. Write Command (Host → Device) Field Length Hexadecimal Representation Description Address 1 byte 0x2D Device Address: 45 (0x2D) Function Code 1 byte 0x10 Write to multiple registers Starting Register Address 2 bytes HH LL Register Start Address (low byte first) Number of Registers 2 bytes HH LL Number of registers to write N Number of Data Bytes 1 byte 0xMM Number of data bytes = 2×N Data 2×N bytes DD DD ... Actual data (2 bytes per register) Checksum 2 bytes CC CC Modbus CRC16 (low byte first) Format: [Address-45][Function Code-0x10][Start Register Address-2 bytes][Number of Registers-2 bytes][Number of Data Bytes-1 byte][Data-2*N bytes][Checksum-2 bytes modbus_crc16-low byte first] 2. Write Feedback (Device → Host) Fields Length Hexadecimal Representation Description Address 1 byte 0x2D Device Address: 45 (0x2D) Function Code 1 byte 0x10 Write Multiple Registers Starting Register Address 2 bytes HH LL Register Start Address (Low Byte First) Number of Registers 2 bytes HH LL Number of Registers Written Checksum 2 bytes CC CC Modbus CRC16 (Low Byte First) Format: [Address-45][Function Code-0x10][Starting Register Address-2 bytes][Number of Registers-2 bytes][Checksum-2 bytes modbus_crc16-Low Byte First] 3. Read Command (Host → Device) Fields Length Hexadecimal Representation Description Address 1 byte 0x2D Device Address: 45 (0x2D) Function Code 1 byte 0x03 Read Multiple Registers Starting Register Address 2 bytes HH LL Register Start Address (Low Byte First) Number of Registers 2 bytes HH LL Number of Registers to Read N Checksum 2 bytes CC CC Modbus CRC16 (Low Byte First) Format: [Address-45][Function Code-03][Starting Register Address-2 bytes][Number of Registers-2 bytes][Checksum-2 bytes modbus_crc16-Low Byte First] 4. Read Feedback (Device → Host) Field Length Hexadecimal Representation Description Address 1 byte 0x2D Device Address: 45 (0x2D) Function Code 1 byte 0x03 Read multiple registers Number of Data Bytes 1 byte 0xMM Number of Data Bytes = 2×N Data 2×N bytes DD DD ... Data read (2 bytes per register) Checksum 2 bytes CC CC Modbus CRC16 (low byte first) Format: [Address-45][Function Code-03][Number of Data Bytes-1 byte][Data-2*N bytes][Checksum-2 bytes modbus_crc16-low byte first] Case Studies: Read angle in hexadecimal format: 2D 03 00 20 00 01 82 6C Feedback: 2D 03 0C 23 28 00 10 11 94 00 20 03 A8 DC D8 3B 46 Move all joints at 16% speed to [90, 0.16, 45, 0.32, 10, -90]: 2D 10 00 22 00 07 0E 23 28 00 10 11 94 00 20 03 A8 DC D8 00 10 66 60 First-level feedback: 2D 10 00 22 00 07 26 6D Second layer feedback: Normal positioning:2D 10 00 5B 00 07 00 00 46 47, J1 over-limit:2D 10 00 5B 00 07 00 01 87 87` Basic Control Read Main Control Version Number Register Address: 00 02 Number of Registers: 00 01 Feedback Data Bits: 2 bytes, requires /10.0 Send Command (Hexadecimal): 2D 03 00 02 00 01 22 66 Feedback Command Example: 2D 03 02 00 0A A9 85, version number is V1.0 Start Robot Register Address: 00 16 Number of Registers: 00 00 Send Data Bits: None Feedback Data Bits: Bytes 1-2: Startup Status, 0-2; 0 - Startup Failed, 1 - Startup Successful, 2 - Emergency Stop Triggered Shut Down Robot Register Address: 00 17 Number of Registers: 00 00 Send data bits: None Read robot startup status Register address: 00 18 Number of registers: 00 01 Feedback data bits: Bytes 1-2: Startup status, 0-2; 0 - Startup failed, 1 - Startup successful, 2 - Emergency stop detected Motion Control Motion control speed range: 1-100, actual speed percentage can be found in the robotic arm motion and speed parameter table. Position feedback format: [address][function code][register address][number of registers][position status][crc] Position feedback data: Normal position: 2D 10 00 5B 00 07 00 00 46 47, J3 over-limit: 2D 10 00 5B 00 07 00 03 06 46 Full joint angle control Register address: 00 34 Number of registers: 00 07 Send data bits: Bytes 1-12: 2x6 joint angle (angle * 100.0) Bytes 13-14: Speed Single joint angle control Register address: 00 33 Number of registers: 00 03 Transmit data bits: Bytes 1-2: Joint; Bytes 3-4: Angle (angle * 100.0); Bytes 5-6: Speed Read all joint angles Register address: 00 32 Number of registers: 00 01 Feedback data bits: Bytes 1-12: 2x6 joint angle (angle / 100.0) Full coordinate control Register address: 00 37 Number of registers: 00 07 Transmit data bits: Bytes 1-12: 2x6 coordinates (XYZ 10.0, RXRYRZ 100.0); Bytes 13-14: Speed Single coordinate control Register address: 00 36 Number of registers: 00 03 Send data bits: Bytes 1-2: Coordinate axes; Bytes 3-4: Coordinates (XYZ10.0, RXRYRZ100.0); Bytes 5-6: Velocity Read all coordinates Registry address: 00 35 Number of registers: 00 01 Feedback data bits: Bytes 1-12: 2x6 coordinates (XYZ/10.0, RXRYRZ/100.0) Read robot motion status Registry address: 00 43 Number of registers: 00 01 Feedback data bits: Bytes 1-2: Motion status 0/1, 0 - not moving; 1 - moving Pause motion Registry address: 00 38 Number of registers: 00 01 Send data bits: Bytes 1-2: 0/1 1 - Slow pause 0 - Emergency pause Movement recovery Register address: 00 40 Number of registers: 00 00 Send data bits: None Movement end Register address: 00 41 Number of registers: 00 00 Send data bits: None Detect movement pause Register address: 00 39 Number of registers: 00 01 Feedback data bits: Bytes 1-2: Pause status 0/1, 0 - Not manually paused; 1 - Paused Continuous joint movement Register address: 00 48 Number of registers: 00 03 Send data bits: Bytes 1-2: Joint; Bytes 3-4: Direction 0/1 0 - Reverse 1 - Forward Bytes 5-6: Speed Continuous Coordinate Motion Registry Address: 00 50 Number of Registers: 00 03 Send Data Bits: Bytes 1-2: Coordinate Axis; Bytes 3-4: Direction 0/1 0 - Reverse 1 - Forward Bytes 5-6: Speed RPY Rotation Registry Address: 00 245 Number of Registers: 00 03 Send Data Bits: Bytes 1-2: Mode 1-3 1 - Roll Angle 2 - Pitch Angle 3 - Yaw Angle; Bytes 3-4: Direction 0/1 0 - Reverse 1 - Forward Bytes 5-6: Speed Joint Stepping Control Registry Address: 00 51 Number of Registers: 00 03 Send data bits: Bytes 1-2: Joint; Bytes 3-4: Step value * 100.0; Bytes 5-6: Speed Coordinate Stepping Control Register Address: 00 52 Number of Registers: 00 03 Send data bits: Bytes 1-2: Coordinate axis; Bytes 3-4: Step value (XYZ 10.0, RXRYRZ 100.0); Bytes 5-6: Speed Over-limit Return to Zero After exceeding the limit, it is not necessary to manually move back to the limit; currently only supported in position mode, not in refresh mode control Register Address: 00 04 Number of Registers: 00 00 Send data bits: None Auxiliary Functions Configuration Set RGB Color Register Address: 00 12 Number of Registers: 00 03 Send Data Bits: Bytes 1-2: R; Bytes 3-4: G; Bytes 5-6: B Range 0-255, all 0s - light off Set Robot Torque Status Register Address: 00 19 Number of Registers: 00 02 Send Data Bits: Bytes 1-2: Joints 1-6 254 - All; Bytes 3-4: Mode 0/1 0 - Disabled 1 - Enabled; Movement is only possible when enabled IO Control Bottom IO Set Base IO Output Register Address: 00 160 Number of Registers: 00 02 Transmit data bits: Bytes 1-2: Pin numbers 1-12 Bytes 3-4: Status 0/1 0-Low level 1-High level Read dock I/O input Register address: 00 161 Number of registers: 00 01 Feedback data bits: Bytes 1-24: 2*12 pin status 0/1 0-Low level 1-High level Terminal I/O Set terminal I/O output Register address: 00 97 Number of registers: 00 02 Transmit data bits: Bytes 1-2: Pin numbers 1/2 Bytes 3-4: Status 0/1 0-Low level 1-High level Read all terminal pin statuses Register address: 00 123 Number of registers: 00 01 Send data bits: None Feedback data bits: Bytes 1-2: Input 1 status 0/1 0-low level 1-high level; Bytes 3-4: Input 2 status; Bytes 5-6: End button 1 status; Bytes 7-8: End button 2 status Status Query Read robot status Register address: 00 162 Number of registers: 00 01 Feedback data bits: Bytes 1-2: Collision detection status 0/1 1-collision; Bytes 3-4: Movement status 0/1 1-moving; Bytes 5-16: 1x6 joint over-limit status 0/1 1-over-limit; Bytes 17-28: 2x6 joint motor error status 0-normal >0 abnormal; Bytes 29-40: 2x6 joint motor software error 0-normal >0 abnormal; See error information and position feedback table for details Read Motion Error Information Registry Address: 00 07 Number of Registers: 00 01 Feedback Data Bits: Bytes 1-2: Error information, see error information and position feedback table for details Read Joint Running Speed Registry Address: 00 225 Number of Registers: 00 01 Feedback Data Bits: Bytes 1-12: 2x6 running speed / 100.0 +-30rpm Get Joint Current Registry Address: 00 226 Number of Registers: 00 01 Feedback Data Bits: Bytes 1-12: 2x6 joint current, unit: MA Exception Clearing Clear Motion Errors Clear motion reading errors, such as exceeding limits, coordinates not reaching, etc. Registry Address: 00 08 Number of registers: 00 00 Data bits sent: None Joint Abnormal Recovery Clear some joint motor errors Register address: 00 231 Number of registers: 00 01 Data bits sent: Bytes 1-2: Joints 1-6, 254-All joints Common Problems Robotic arm cannot move? Check if the robotic arm is enabled, if there are any errors in the joint motors, and if any joints are out of limits. You can call Read Robot Status. No response to commands Check if the sent commands are correct. All commands have a first-level handshake feedback. Error Messages and Position Feedback Form Position Feedback Form 0-20 Joint Overlimit, Collision, Pause, etc. Hexadecimal (Decimal) Description 0 Movement in Position 1-7 Joint Overlimit 8 End of Movement Mode Setting 10-13 Collision Protection A (10) End of Ease Marker B (11) Command Stop Marker 20-23 (32-35) Coordinate motion anomaly (Check joint limits) Hexadecimal (Decimal) Description 20 (32) No coordinate solution 21 (33) No adjacent solution for linear motion 22 (34) Velocity fusion error 23 (35) No adjacent solution for zero-space motion 24 (36) No solution for singular position 31 (49) Identification accuracy error 41-47 (65-71) Joint Abnormality Hexadecimal (Decimal) Description 41-47 (65-71) 1-7 Joint Position Accuracy Abnormality 51-57 (81-87) 1-7 Joint Collision Detection Abnormality 0x61-67 1-7 Joint CAN Transmission Failure 0x71-77 1-7 Joint CAN Reception Abnormality 0x81-87 1-7 Joint Enabled 0x91-97 1-7 Joint Motor Error (Can be used with 0x9c interface after error) 0xA1-A7 1-7 Joint Motor Encoder Error 0xC1-C7 1-7 Joint Position Out of Tolerance Motion Error Message Table Return Data Format: 0xD0 + xx (e.g., 0xD001 indicates 1 joint exceeds limit) 0-6 Joint Exceeds Limit Status Code (Decimal) Hexadecimal Description 0 0x00 Normal Motion 1 0x01 1 Joint Exceeds Limit 2 0x02 2 Joints Exceeds Limit 3 0x03 3 Joints Exceeds Limit 4 0x04 4 Joints Exceeds Limit 5 0x05 5 Joints Exceeds Limit 6 0x06 6 Joints Exceeds Limit 20-24 (32-36) Coordinate Motion Abnormality Status Code (Decimal) Hexadecimal Explanation 20 (32) 0x14 No solution for coordinates, please check if the arm span is near the limit 21 (33) 0x15 No adjacent solution for linear motion 22 (34) 0x16 Velocity fusion error 23 (35) 0x17 No adjacent solution for zero-space motion 24 (36) 0x18 No solution for singular position, please use joint control to leave the singular point Joint Motor Error Message Table 1. Software Error Alarms Bits (2 bytes) Error Status (1 - Abnormal, 0 - Normal) Description and Handling Suggestions 0 Can Initialization Abnormal Requires checking the main control board. After fixing the control board abnormality, power off and then power on again. Symptoms: The machine cannot be enabled or controlled, etc. 1 Motor Initialization Abnormal Requires checking the motor communication line, etc. After fixing the abnormality, power off and then power on again. Symptoms: The machine cannot properly feedback joint information or control, etc. 2 Motor Sending Abnormal Requires checking the motor communication line, etc. Symptoms: Abnormal machine position feedback, etc.; can be cleared using abnormal recovery. 3 Motor Receiving Abnormal Requires checking the motor communication line, etc. Symptoms: Abnormal machine position feedback, etc.; can be cleared using abnormal recovery. This feedback allows normal machine control and does not require user notification; it is mainly used for troubleshooting. 4 Position Out of Tolerance Requires checking the motor encoder, etc. Symptoms: Machine is disabled and cannot be controlled; can be cleared using exception recovery. 5 End-point transmission anomaly Need to check end-point communication lines, etc.Symptoms: End-point interface feedback anomaly; can be cleared using exception recovery. 6 End-point reception anomaly Need to check end-point communication lines, etc.Symptoms: End-point interface feedback anomaly; can be cleared using exception recovery.This feedback allows normal machine control without user notification; mainly used for troubleshooting anomalies. 7 Motor encoder error When the encoder reports an error, movement is impossible; the encoder error needs to be cleared.Older motor drive boards do not report errors - even if an encoder error is reported, the software cannot provide feedback.How to distinguish between new and old: The board with a battery is the newer drive board. 8 Disabled feedback The machine must be enabled before movement. 2 Motor Built-in Error Alarms Bits (2 bytes) Error Status Handling Method 0 CAN Bus Error Can be recovered using exception recovery. If recovery fails, check the communication line, repair, and then power on to enable. 1 Short Circuit Can be recovered using exception recovery. 2 Invalid Setting Data — 3 Control Error Can be recovered using exception recovery. 4 CAN Communication Error Can be recovered using exception recovery. If recovery fails, check the communication line, repair, and then power on to enable. 5 Feedback Error Can be recovered using exception recovery. 6 Positive Limit Switch Activated — 7 Negative Limit Switch Activated — 8 Overcurrent Can be recovered using exception recovery. 9 I2t Protection Can be recovered using exception recovery. 10 Overtemperature Can be recovered using exception recovery. 11 Driver Board Overtemperature Can be recovered using exception recovery. 12 Overvoltage Can be recovered using exception recovery. 13 Undervoltage Can be recovered using exception recovery. 14 Command Error — 15 Enabled is inactive — ← Previous Chapter | Next Chapter → "},"3-FunctionsAndApplications/7.SuccessfulCase/":{"url":"3-FunctionsAndApplications/7.SuccessfulCase/","title":"7. SuccessfulCases","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/":{"url":"3-FunctionsAndApplications/8.SupportingResources/","title":" 8. SupportingResources","keywords":"","body":"Chapter 8 Supporting Resources This chapter will introduce various supporting resources of the product in detail, aiming to help users fully understand and use our products efficiently. Whether it is product information, drawings, software information and source code, or system information and promotional materials, we provide detailed information and download links to ensure that users can make full use of these resources for product development, operation and promotion Download Product Information The product information includes detailed specifications, technical parameters and instructions for use of the mycobot pro 450 robot arm. This section aims to help users fully understand the performance and functions of the robot arm and ensure the best experience during use Product Drawings The product drawings section provides detailed 3D and 2D drawings of the mycobot pro 450 robot arm. These drawings are particularly important for engineers who need to perform customized designs or maintenance, and can help them better understand the structure of the robot arm. System Information The system information provides the system architecture and working principle of the mycobot pro 450 robot, covering the collaborative working mode of hardware and software. This section helps users to quickly locate and solve problems during integration and debugging to ensure stable operation of the system Promotional Materials The promotional materials section contains the product brochure, demonstration video and customer cases of the mycobot pro 450 robot. These materials not only show the core advantages and application scenarios of the robot, but also provide successful cases in actual applications to help potential customers understand the value of the product more intuitively. ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/8.1-ProductInformation/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.1-ProductInformation/","title":"8.1 ProductInformation","keywords":"","body":"Product Information Download The product information includes detailed specifications, technical parameters and instructions for use of the mycobot pro 450 robot arm. This section is designed to help users fully understand the performance and functions of the robot arm and ensure the best experience during use Download Link You can download all relevant product information through the following link: Product Information Download ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/8.2-ProductDrawings/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.2-ProductDrawings/","title":"8.2 ProductDrawings","keywords":"","body":"Product Drawings The product drawings section provides detailed 3D and 2D drawings of the mycobot pro 450 robot. These drawings are particularly important for engineers who need to make customized designs or perform maintenance, and can help them better understand the structure of the robot. Machine 3D Model Machine 3D Model File mycobot pro 450 Download Machine 2D Drawings Machine Machine 2D Drawings myCobot Pro 450 DH Download myCobot Pro 450 Atom Download myCobot Pro 450 Base Download Accessories 3D Models myCobot Series Accessories 3D Model Files myGripperF100 Download PneumaticGripper Download AdaptiveGripper Download PhoneHolderPro Download ModuleSuctionCup Download CameraModulePro Download PenHolderPro Download ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/8.3-SystemInformation/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.3-SystemInformation/","title":"8.3 SystemInformation","keywords":"","body":"System Information The system information provides the system architecture and working principle of the mycobot pro 450 robot, covering the collaborative working mode of hardware and software. This section helps users to quickly locate and solve problems during integration and debugging to ensure stable operation of the system (Information to be updated) ← Previous Chapter | Next Chapter→ "},"3-FunctionsAndApplications/8.SupportingResources/8.4-PromotionalMaterials/":{"url":"3-FunctionsAndApplications/8.SupportingResources/8.4-PromotionalMaterials/","title":"8.4 PromotionalMaterials","keywords":"","body":"Promotional Materials The promotional materials section includes the product brochure, demonstration video and customer cases of the mycobot pro 450 robot arm. These materials not only show the core advantages and application scenarios of the robot arm, but also provide successful cases in actual applications to help potential customers understand the value of the product more intuitively. Machine Product Brochure mycobot pro 450 Download Product unboxing video !Video in progress Product promotion video !Video in progress User Case !Video in progress ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/9.AboutUs/9.AboutUs.html":{"url":"4-SupportAndService/9.AboutUs/9.AboutUs.html","title":"9. ContactUs","keywords":"","body":"Elephant Robotics 1. Company Introduction Based in Shenzhen, China, Elephant Robotics is a high-tech enterprise focusing on robot R&D, design and automation solutions. We are committed to providing highly flexible collaborative robots, easy-to-learn operating systems and intelligent automation solutions for robot education and scientific research institutions, commercial scenarios and industrial production. Its product quality and smart solutions have been unanimously recognized and praised by several factories from the world's top 500 companies in South Korea, Japan, the United States, Germany, Italy, Greece and other countries. Elephant Robotics adheres to the vision of \"Enjoy Robots World\" and advocates the collaborative work of people and robots, making robots a good helper for human work and life, helping people to be liberated from simple, repetitive and boring work, giving full play to the advantages of human-machine collaboration, thereby improving work efficiency and helping humans create a better new life. In the future, Elephant Robotics hopes to promote the development of the robot industry through a new generation of cutting-edge technology, and work with customers and partners to open a new era of automation and intelligence. 2. Development History 2016.08 -----Elephant Robotics Co., Ltd. was officially established 2016.08 -----Entered HAX incubator and received seed round investment from SOSV 2016.08 -----Started research and development of Elephant S industrial collaborative robot 2017.01 -----Rated as \"Top 10 Most Innovative Companies in China at CES\" 2017.04 -----Attended Hannover Industrial Fair and Korea Automation Exhibition 2017.07 -----Two founders were selected as \"30 Business Elites Under 30\" by Forbes Asia 2017.10 -----The fifth-generation single-arm industrial collaborative robot Elephant S was launched 2018.04 -----Received angel round investment from \"Yun Angel Fund\" 2018.06 -----First public appearance 2018 Hannover World Industrial Fair 2018.06 -----Won the \"Smart Manufacturing Entrepreneurship MBA Award\" from Cheung Kong Graduate School of Business 2018.06 -----Won the \"Entrepreneurship Accelerator X-elerator Award\" from Tsinghua School of Economics and Management 2018.11 -----Won the second place in the Shenzhen Division of the Asian Smart Hardware Competition 2018.11 -----Won the \"Most Investment Enterprise Award\" of the Gaogong Golden Globe Award 2019.03 -----Won the \"Leadership Award\" of the Gaogong Golden Globe Award 2019.04 -----In March 2019, Catbot won the \"Industrial Robot Innovation Award\" 2019.09 -----Attended the Huawei European Ecosystem Conference (HCE) and officially became a member of Huawei's ecological partner 2019.11 -----Elephant Robotics and Harbin Institute of Technology attended the IROS International Intelligent Robots and Systems Conference 2019.12 -----Elephant Robotics-South China University of Technology \"Intelligent Robot Joint Development Laboratory\" was officially unveiled 2019.12 -----Won the \"Innovation Technology Award\" of Gaogong in 2019 2019.12 -----Won the \"Top Ten Fast-Growing Enterprises\" of Gaogong in 2019 2019.12 -----Won the \"New Enterprise Award\" in the Industrial Robot Segment of Shenzhen Equipment Industry 2019.12 -----The world's first bionic robot cat MarsCat was launched 2020.05 -----The founder won the 2019 Shenzhen Robotics Newcomer Award 2020.10 -----The world's lightest and smallest six-axis collaborative robot myCobot was launched 2021.03 -----The smallest collaborative robot for scientific research myCobotPro 320 was launched 2021.05 -----Mars bionic cat MarsCat Received coverage from Xinhua Finance, China Daily, Nanjing Daily, Harbin Daily and other media 2021.07 -----Released the smallest composite robot chassis - Elephant Mobile Robot myAGV 2021.09 -----The world's first fully enclosed four-axis robotic arm - Elephant palletizing robotic arm myPalletizer was launched 3. Related links Purchase link Taobao: https://shop504055678.taobao.com Shopify: https://shop.elephantrobotics.com/ AliExpress: https://elephantrobotics.aliexpress.com/store/1101941423Other information Official website: https://www.elephantrobotics.com Video Bilibili: https://space.bilibili.com/2126215657 Youtube: https://www.youtube.com/c/Elephantrobotics Facebook: https://www.facebook.com/mycobotcreator/ Linkedin: https://www.linkedin.com/company/18319865 X (Twitter): https://twitter.com/CobotMy Discord: https://discord.gg/2MAherp7nt Hackster: https://www.hackster.io/elephant-robotics 4. Contact Us Our working hours are China working days, 10 am to 6 pm Beijing time. If you have any other questions, please contact us via the following methods. E-mail : support@elephantrobotics.com - If you have any purchase intention or any parameter questions, please send an email to this mailbox. [E-mail](sales@elephantrobotics.com) : sales@elephantrobotics.com If you encounter any problems in the use of this product, please read Chapter 9 of the manual first. If the problems listed cannot help you solve them, and you have more after-sales problems, please send an email to this mailbox. E-mail : support@elephantrobotics.com We will respond within 1-2 working days; WeChat: We only provide one-to-one service for users who purchase mycobot products through WeChat. ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/accessories.html":{"url":"4-SupportAndService/Accessories/accessories.html","title":"10. Accessories","keywords":"","body":"Product Accessories In the real world, different accessories can enhance the capabilities of robots in various ways. For example, accessories such as grippers, sensors, and tools can help robots perform various tasks, thereby increasing their versatility and flexibility. Elephant Robotics is committed to making robots and these accessories easy for everyone to use, freeing users from the complexity of choosing the right accessories and enabling them to quickly start using robots. Accessory Types In order to meet the needs of customers in different scenarios, we have designed various types of accessories, including grippers, suction cups, camera modules, and other gripping devices, so that users can directly choose the right end effector Gripper myGripper F100 Pneumatic Gripper Adaptive Gripper Suction Pumps Single Suction Pump Vacuum Suction Cups Holder Pen Holder Phone Holder Other functional accessories Camera Module Pro 3D Camera ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.1-myGripperF100.html":{"url":"4-SupportAndService/Accessories/10.1-myGripperF100.html","title":"10.1 MyGripperF100","keywords":"","body":"myGripper F100 Force-controlled Gripper 1 Product Image 2 Specifications Name myGripper F100 force-controlled gripper Material PC, PBT Dimensions 156X106X61mm Process technology Injection molding Gripping range 0-100 mm (default fingertip) Repeatability 0.5 mm Service life 300,000 openings and closings Drive mode Electric drive Transmission mode Gear + connecting rod Dimensions 158x105x55mm Weight 340 g Rated load 500g Working voltage 24V Fixing method Screw fixing Environment requirements Normal temperature and pressure Control interface RS485/IO control/button control Applicable equipment ER myCobot 320 series, ER Mercury series, ER myCobot Pro 600, ERmyCobot Pro 630, other general robots, ER myCobot Pro 450 3 Working Principle Driven by the motor, the finger surface of the manipulator makes linear reciprocating motion to achieve opening or closing. By setting the clamping torque, the impact of the workpiece is minimized, the positioning point is controllable, and the clamping is controllable. 4 Usage Scenario Experimental operation: In scientific research experiments, complete the grasping and moving of test tubes, utensils, etc. to ensure the safety and accuracy of the experiment. Educational demonstration: As a teaching tool, it helps students understand the principle of robot grasping and cultivate practical ability. Material handling: In simulated production lines or warehouses, materials of various specifications are handled to improve work efficiency. 5 Installation Method Use screws and washers to install the gripper connector to the end flange of the robot arm Then use screws to install the gripper on the connector Finally, use M8 aviation wire to connect the gripper and the robot arm 6 Python Control Method Based On 450 Terminal IO Control The IO control method can only control the gripper to fully open and close from pymycobot import ElephantRobot import time mc=ElephantRobot(\"192.168.1.159\",5001) mc.start_client() def gripper_open(): mc.set_digital_out(16,0) mc.set_digital_out(17,1) def gripper_close(): mc.set_digital_out(16,1) mc.set_digital_out(17,0) if __name__==\"__main__\": gripper_open() time.sleep(2) gripper_close() time.sleep(2) Control Based On USB tTo 485 Module Note: To control the gripper in this way, you need to connect one end of the M8 aviation cable connected to the gripper to the USB to 485 module. That is, one end of the M8 aviation cable with a plug is connected to the gripper, and the other end is connected to the USB to 485 module and the 24V power supply. Wiring instructions: Connect the 24V, GND, 485_A (T/R+, 485+), 485_B (T/R-, 485-) wires at the end of the gripper, a total of 4 wires, the power supply is a 24V DC regulated power supply or the 24V of the IO at the bottom of the 450, insert the USB port of the module into the USB port of the computer 485A connects to the 485 to USB module A+; 485B connects to the 485 to USB module B-; 24V connects to 24V DC regulated power supply positive pole/24V of IO at the bottom of 450; GND connected to 24V DC regulated power supply negative pole/GND of IO at the bottom of 450 Driver library installation Click to download the driver library Serial Port Dependency Library Installation Execute the following command in the computer terminal to install the dependency library pip install pyserial API Description get_firmware_version() Function: Get the main version number of the gripper firmware Parameter: None Return: (int) Firmware main version number get_modified_version() Function: Get the sub-version number of the gripper firmware Parameter: None Return: (int) Firmware sub-version number get_gripper_Id() Function: Get the gripper ID Parameter: None Return: (int) Gripper ID get_gripper_baud() Function: Get the baud rate of the gripper Parameter: None Return:(int) 0-5 0: 115200 1: 1000000 2: 57600 3: 19200 4: 9600 5: 4800 get_gripper_value() Function: Get the current position data of the gripper Parameter: None Return: (int) The current position data of the gripper get_gripper_status() Function: Get the current status of the gripper Parameter: None Return:(int) 0-3 0: Moving 1: Stopped moving, no object was detected 2: Stopped moving, object was detected 3: After detecting that the object is clamped, the object falls get_gripper_speed() Function: Get the current speed of the gripper Parameter: None Return: (int) The current speed of the gripper get_gripper_P() Function: Get the P value of the gripper PID Parameter: None Return: (int) The P value of the gripper PID get_gripper_I() Function: Get the I value of the gripper PID Parameter: None Return: (int) The I value of the gripper PID get_gripper_D() Function: Get the D value of the gripper PID Parameter: None Return: (int) The D value of the gripper PID get_gripper_cw() Function: Get the clockwise runnable error of the gripper Parameter: None Return: (int) Clockwise runnable error of the gripper get_gripper_cww() Function: Get the counterclockwise runnable error of the gripper Parameter: None Return: (int) Counterclockwise runnable error of the gripper get_gripper_mini_pressure() Function: Get the minimum starting force of the gripper Parameter: None Return: (int) Minimum starting force of the gripper get_gripper_io_open_value() Function: Get the opening angle of the gripper Io Parameter: None Return: (int) Opening angle of the gripper Io get_gripper_io_close_value() Function: Get the closing angle of the gripper Io Parameter: None Return: (int) Get the closing angle of the gripper Io get_gripper_queue_count() Function: Get the amount of data in the current queue of the gripper Parameter: None Return: (int) The amount of data in the current queue of the gripper get_gripper_vir_pos() Function: Get the virtual position value of the gripper servo Parameter: None Return: (int) The virtual position value of the gripper servo get_gripper_protection_current() Function: Get the gripper clamping current Parameter: None Return: (int) The gripper clamping current set_gripper_Id(value) Function: Set the gripper ID Parameters: value: (int) Gripper ID, value range 1-254 Return: (int) 0-1 0: Failed 1: Success set_gripper_baud(value) Function: Set the gripper baud rate Parameter: value: (int) Gripper baud rate, value range 0-5 0: 115200 1: 1000000 2: 57600 3: 19200 4: 9600 5: 4800 Return: (int) 0-1 0: Failed 1: Successful set_gripper_enable(value) Function: Set the gripper enable state Parameter: value: (int) Enable state, value range 0-1 0: Disabled 1: Enabled Return:(int) 0-1 0: Failed 1: Success set_gripper_value(value,speed) Function: Set the gripper to rotate to the specified position at the specified speed Parameter: value: (int) Position, value range 0-100 speed: (int) Speed, value range 1-100 Return:(int) 0-1 0: Failed 1: Success set_gripper_calibration() Function: Set the gripper Zero Calibration Parameter: None Return:(int) 0-1 0: Failed 1: Success set_gripper_P(value) Function: Set the P value of the gripper PID Parameters: value: (int) P value, value range 0-254 Return: (int) 0-1 0: Failed 1: Success set_gripper_I(value) Function: Set the I value of the gripper PID Parameters: value: (int) I value, value range 0-254 Return: (int) 0-1 0: Failed 1: Success set_gripper_D(value) Function: Set the D value of the gripper PID Parameters: value: (int) D value, value range 0-254 Return: (int) 0-1 0: Failed 1: Success set_gripper_cw(value) Function: Set the clockwise running error of the gripper Parameter: value: (int) Error, value range 0-16 Return: (int) 0-1 0: Failure 1: Success set_gripper_cww(value) Function: Set the counterclockwise running error of the gripper Parameter: value: (int) Error, value range 0-16 Return: (int) 0-1 0: Failure 1: Success set_gripper_mini_pressure(value) Function: Set the minimum starting force of the gripper Parameter: value: (int) Minimum starting force, value range 0-254 Return:(int) 0-1 0: Failed 1: Success set_gripper_torque(value) Function: Set gripper torque Parameter: value: (int) Torque, value range 0-300 Return:(int) 0-1 0: Failed 1: Success set_gripper_output(value) Function: Set gripper IO Parameter: value: (int) Gripper IO, value range 0-3 0: out1 off,out2 off 1: out1 on,out2 off 2: out1 off,out2 on 3: out1 on,out2 on Return:(int) 0-1 0: Failed 1: Success set_gripper_io_open_value(value) Function: Set the gripper Io open position Parameter: value: (int) position, value range 0-100 Return:(int) 0-1 0: Failed 1: Success set_gripper_io_close_value(value) Function: Set the gripper Io closed position Parameter: value: (int) position, value range 0-100 Return:(int) 0-1 0: Failed 1: Success set_gripper_speed(speed) Function: Set the gripper speed Parameters: speed: (int) speed, value range 1-100 Return: (int) 0-1 0: failed 1: successful set_abs_gripper_value(value,speed) Function: Set the gripper to rotate to the specified absolute position at the specified speed Parameters: value: (int) position, value range 1-100 speed: (int) speed, value range 1-100 Return: (int) 0-1 0: failed 1: successful set_gripper_vir_pos(value) Function: Set the virtual position value of the gripper servo Parameters: value: (int) virtual position, value range 0-100 Return:(int) 0-1 0: Failed 1: Success set_gripper_protection_current(value) Function: Set the gripper gripping current Parameter: value: (int) Virtual position, value range 1-254 Return:(int) 0-1 0: Failed 1: Success set_gripper_pause() Function: Set the gripper to pause motion Remarks: Only valid for set_abs_gripper_value() Parameter: None Return:(int) 0-1 0: Failed 1: Success set_gripper_resume() Function: Set the gripper to resume motion Remarks: Only valid for set_abs_gripper_value() Parameters: None Return: (int) 0-1 0: Failure 1: Success set_gripper_stop() Function: Set the gripper to stop moving and clear the message queue Remarks: Only valid for set_abs_gripper_value() Parameters: None Return: (int) 0-1 0: Failure 1: Success Case Procedure from elegripper import Gripper import time if __name__==\"__main__\": g=Gripper(\"COM27\",baudrate=115200,id=14)##Fill in the actual serial port number, baud rate and gripper ID print(\"The actual ID of the gripper is:\",g.get_gripper_Id()) print(g.set_gripper_value(100,100)) time.sleep(2) print(g.set_gripper_value(0,100)) time.sleep(2) ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.2-PneumaticGripper.html":{"url":"4-SupportAndService/Accessories/10.2-PneumaticGripper.html","title":"10.2 PneumaticGripper","keywords":"","body":"Pneumatic Gripper Compatible models: myCobot 320, myCobot Pro 630, myCobot Pro 600, myCobot Pro 450 Product Images Specifications Name mycobot Pneumatic Gripper Model myCobotPro_Gripper_Air_10 Material Metal + 7500 Nylon Gripping range 0-8mm Clamping force Outer diameter 34N Inner diameter 45N Drive mode Pneumatic Transmission method Piston cylinder Dimensions 67.3×38×23.6mm Weight 180g Fixing method Screw fixing Environment requirements Normal temperature and pressure Control interface Input/output control Applicable equipment myCobot 320 series, myCobot Pro 630, myCobot Pro 600, myCobot Pro 450 Used For Grasping Objects Introduction Pneumatic grippers, also known as pneumatic fingers or pneumatic clamps, are actuators that use compressed air as power to grasp or grip workpieces. They are small in size, light in weight, compact in appearance, and can achieve unidirectional and bidirectional grasping, automatic centering, high repeatability, and automatic control of magnetic switches. The pneumatic gripper kit includes gripper flange, air pump, φ8 air pipe, φ6 air pipe, φ8-6 quick connector, solenoid valve and cable. Its main function is to replace manual grasping work, which can effectively improve production efficiency and work safety. An external suction pump is required. Working principle Single piston: The shaft drives the crank, and the air gripper is driven to open and close by the piston. The two claws are respectively arranged with corresponding crank grooves. In order to reduce friction resistance, the claws and the fuselage are connected by a steel ball slide structure. Double piston: controlled by two pistons, each piston is connected to a pneumatic finger through a roller and a double crank to form a special drive unit. It should be noted that the pneumatic finger always moves toward the center axis, and each pneumatic finger cannot move independently. Parallel clamp cylinder: If the pneumatic finger moves in the opposite direction, the previously compressed piston is in the exhaust state, and the other piston is in the compression state. Applicable objects Volume is smaller than the clamping stroke Weight is smaller than the maximum clamping weight Customized fingertips can expand more uses Installation and use Need to be used with an air compressor: Insert the black plug into the power strip; Insert the matching red hose into the interface on the machine: The red button is a switch. Pull it out to turn it on, and press it back to turn it off: Gripper installation: Connect the other end of the red hose of the air compressor to the interface of the solenoid valve: Unscrew another interface on the other end of the solenoid valve to start the gripper to control the opening and closing: Use two matching transparent hoses, one end of which is connected to the two interfaces of the solenoid valve: The other end of the transparent hose is connected to the two interfaces of the gripper: Use the matching screws to fix the gripper to the end of the robot arm: Electrical connection: Connect the black cable to the GND of the robot base, and the red cable to any one of OUT1~OUT6. Change the pin number of the subsequent program according to the selected interface. Here, use OUT1: 3 Through Python Control The robot system needs to be started before use Confirm the IP address of the robot arm: Enter ifconfig in the terminal to obtain from pymycobot import ElephantRobot import time # Change the ip to the real ip of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_digital_out(0,1) time.sleep(2) elephant_client.set_digital_out(0,0) time.sleep(2) ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.3-AdaptiveGripper.html":{"url":"4-SupportAndService/Accessories/10.3-AdaptiveGripper.html","title":"10.3 AdaptiveGripper","keywords":"","body":"myCobotPro Adaptive Gripper Compatible models: myCobot 320, myCobot Pro 630,myCobot Pro 600,myCobot Pro 450 Product Image Specifications Name myCobotPro Adaptive Gripper Black and White Material Photosensitive resin + nylon Process technology 3D printing Gripping range 0-90 mm Clamping force 1000 grams Drive mode Electric drive Gearbox mode Gear + connecting rod Dimensions 158x105x55mm Weight 350 grams Fixing method Screw fixing Environment requirements Normal temperature and pressure Control interface Serial port/IO control Applicable devices myCobot 320 series, myCobot Pro 630, myCobot Pro 600, myCobot Pro 450 Used For Grabbing Objects Introduction A manipulator is a robot component that works like a human hand. It has the advantages of complex structure, firm gripping of objects, not easy to fall, and easy operation. The gripper kit includes gripper connection wires and flanges. The end effector of the manipulator is controlled by a programmable system to realize functions such as grabbing objects and multi-point positioning. The gripper can be used in all development environments, such as ROS, Arduino, Roboflow, etc. Working Principle Driven by the motor, the finger surface of the manipulator makes linear reciprocating motion to achieve opening or closing actions. The acceleration and deceleration of the electric manipulator are controllable, the impact on the workpiece is minimal, the positioning point is controllable, and the clamping is controllable. Applicable Objects Small cubes Small balls Long objects Installation And Use Gripper installation: Structural installation: Align the gasket with the hole at the end of the robot arm and tighten it with screws: Align the screw holes of the gripper with the holes around the gasket and tighten them with thin screws: Electrical connection: Note that the robot arm should be powered off, that is, the green light at the end should not be on when plugging and unplugging. If hot-plugging is performed with power on, there is a risk of damaging the gripper. Align the m8 cable with the interface of the robot arm. Note that there is a notch at the interface and a corresponding protrusion on the connecting cable. After confirming the direction, insert it and tighten it: Insert the gripper control interface, and also pay attention to the direction of the notch: Python Programming Control You need to use roboflow to enable the robot first, then run the following python script to test whether the gripper is normal Confirm the IP address of the robot: Enter ifconfig in the terminal to obtain Python Programming Control You need to use roboflow to enable the robot first, then run the following python script to test whether the gripper is normal Confirm the IP address of the robot: Enter ifconfig in the terminal to obtain IO Control Mode from pymycobot import ElephantRobot import time # Change the ip to the real-time ip of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_gripper_mode(1) time.sleep(1) #elephant_client.power_off()#When changing the IO mode from gripper to gripper, you need to shut down the machine and restart the robot. If you only use gripper to gripper mode, you do not need to shut down the robot elephant_client.power_off() time.sleep(3) elephant_client.state_off() time.sleep(3) elephant_client.power_on() time.sleep(3) elephant_client.state_on() time.sleep(3) elephant_client.set_digital_out(16, 0) # IO restores low level time.sleep(1) elephant_client.set_digital_out(17, 0) # IO restores low level time.sleep(1) # IO mode # Gripper full open and full closed control code. Note that when the gripper is transparently switched to IO mode, you need to shut down the machine and restart the robot once before switching back to the gripper IO mode for i in range(3): elephant_client.set_digital_out(16, 1) # Close the gripper time.sleep(1) elephant_client.set_digital_out(17, 0) # IO restores low level time.sleep(1) elephant_client.set_digital_out(16, 0) #IO restores low level time.sleep(1) elephant_client.set_digital_out(17, 1) # Open the gripper time.sleep(1) elephant_client.set_digital_out(16, 0) # IO restores low level time.sleep(1) elephant_client.set_digital_out(17, 0) # IO returns to low level time.sleep(1) Transparent Transmission Mode from pymycobot import ElephantRobot import time # Change the IP address to the real IP address of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_gripper_mode(0) time.sleep(1) # elephant_client.power_off()#When changing the IO mode of the gripper through transmission, you need to shut down the machine and restart the robot once. If you only use the gripper through transmission mode, you do not need to shut down the robot elephant_client.state_off() time.sleep(3) elephant_client.power_on() time.sleep(3) elephant_client.state_on() time.sleep(3) #Transparent transmission mode for i in range(3): elephant_client.set_gripper_value(26,20) time.sleep(1) elephant_client.set_gripper_value(86,20) time.sleep(1) Gripper Zero Position Calibration The gripper has been zero-calibrated before leaving the factory. If the gripper's stroke is incorrect, you can calibrate it according to the following steps First turn off the robot in roboflow, and manually open the gripper to the maximum Then start the robot Then execute the following script from pymycobot import ElephantRobot import time # Change the IP address to the real IP address of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_gripper_mode(0) time.sleep(1) elephant_client.set_gripper_calibrate() time.sleep(1) ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.4-phoneHolder.html":{"url":"4-SupportAndService/Accessories/10.4-phoneHolder.html","title":"10.4 PhoneHolder","keywords":"","body":"myCobot Phone Holder Applicable models: ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myCobot Pro 450 Product image Specifications: Name myCobot Phone Holder Model myCobot_PhoneHolder_J6 Material ABS injection molding Size Diameter 34*10 Color White+Black Clamping weight 50g Service life Two years Fixing method LEGO connector Environmental requirements Normal temperature and pressure Applicable equipment ER myCobot 280 series ER mechArm 270 series ER myPalletizer 260 series ER myCobot Pro 450 myCobot mobile phone holder: Used to hold mobile phones or objects Introduction Suitable for devices that require physical clamping, such as photography, and can hold a variety of mobile phones. It has a simple structure and is easy to install and disassemble. Applicable objects Camera equipment Installation Insert the LEGO connector into the holder hole: Insert the holder with the connector installed into the end of the robot arm Use Pull the holder open, put the camera in, and let go. After confirming that the device is fixed, it can be used. ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.5-3DCamera.html":{"url":"4-SupportAndService/Accessories/10.5-3DCamera.html","title":"10.5 3DCamera","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.6-SingleSuctionPump.html":{"url":"4-SupportAndService/Accessories/10.6-SingleSuctionPump.html","title":"10.6 SingleSuctionPump","keywords":"","body":"Under Preparation ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.7-ModuleSuctionCup.html":{"url":"4-SupportAndService/Accessories/10.7-ModuleSuctionCup.html","title":"10.7 ModuleSuctionCup","keywords":"","body":"Suction Cup Module Compatible Models: myCobot 320, myCobot Pro 600, myCobot Pro 630, myCobot Pro 450 Product Image Specifications Name Module Suction Cup Model myCobotPro_suctionPump Material Nylon 7100 Number of Suction Cups 1/2/4 Suction Cup Size Diameter 33mm Suction Weight Maximum 1000g Power Source Equipment Suction and Blowing Air Compressor Fixing Method Screw Fixing Control interface IO control Environment requirements Normal temperature and pressure Applicable equipment myCobot 320, myCobot Pro 600, myCobot Pro 630, myCobot Pro 450 Suction cup suction pump: Used to adsorb objects Introduction The suction cup suction pump is connected to the object to be adsorbed through the suction cup, pipe and other components, and the suction cup is vacuumed, causing the internal air pressure to change from normal pressure to negative pressure, and the pressure difference between the external atmospheric pressure and this negative pressure is used to achieve the purpose of adsorbing the object. The overall structure is a multifunctional expandable suction cup, which can be installed up to 4; high-pressure resistant hose, which can be reused many times; suction and blowing integrated air compressor, which can expand other functions. Working principle Start the vacuum equipment to suck, so that negative air pressure is generated in the suction cup, so that the object to be lifted is firmly sucked, and the object to be lifted can be transported. When the object to be lifted is transported to the destination, air is steadily inflated into the vacuum cup, so that the negative pressure in the vacuum cup changes to zero pressure or slightly positive pressure, and the vacuum cup is separated from the object to be lifted, thus completing the task of lifting and transporting heavy objects. Applicable objects Applicable to flat objects Installation and use Need to be used with air compressor: Insert the black plug into the power strip; Insert the matching red hose into the interface on the machine: The red button is a switch. Pull it out to turn it on, and press it back to turn it off: Suction cup installation: Connect the other end of the red hose of the air compressor to the interface of the solenoid valve: Use the transparent hose that comes with the module suction cup to connect the interfaces above the solenoid valve and the module suction cup hose branch: Fix the module suction cup to the end of the robot arm with the matching screws: Install the hose branch on the module suction cup: Electrical connection: Connect the black cable to the base of the robot arm GND, red connects to any one of OUT1~OUT6, change the pin number of the subsequent program according to the selected interface, here use OUT1: 3 Control By Python You need to start the robot system before use Confirm the IP address of the robot: Enter ifconfig in the terminal to obtain from pymycobot import ElephantRobot import time # Change the IP address to the real IP address of the P600 Raspberry Pi elephant_client = ElephantRobot(\"192.168.10.158\", 5001) # Necessary commands to start the robot elephant_client.start_client() time.sleep(1) elephant_client.set_digital_out(0,1)#Absorb time.sleep(2) elephant_client.set_digital_out(0,0)#Release time.sleep(2) ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.8-CameraModulePro.html":{"url":"4-SupportAndService/Accessories/10.8-CameraModulePro.html","title":"10.8 CameraModulePro","keywords":"","body":"myCobotPro Camera Module Compatible models: myCobot 320, myCobot Pro 630, myCobot Pro 600, myCobot Pro 450 Product Images Specifications: Name myCobotPro camera module Model myCobot_Pro_cameraHolder_J6 Material Photosensitive resin USB protocol USB2.0 HS/FS Lens focal length Standard 1.7mm Field of view About 60° Supported systems Win7/8/10, Linux, MAC Fixing method Screw fixing Operating environment requirements Normal temperature and pressure Applicable equipment myCobot 320, myCobot Pro 600, myCobot Pro 630, myCobot Pro 450 Camera flange: Machine vision Introduction USB high-definition camera can be used with suction pump, adaptive gripper, artificial intelligence kit, etc., to achieve precise positioning and calibration with eye in hand. Installation and Use Check if the accessories package is complete: screws and hex wrench, camera module with USB cable Camera installation: Structural installation: Align the camera module with the end of the robot arm according to the required direction, and tighten the screws with the hex wrench Electrical connection: Plug the USB cable into the USB port of the base: Python Programming Control Enter the robot system, open the terminal and enter the following command to install opencv sudo apt-get install -y libopencv-dev python3-opencv Create a new python file and fill in the following code #encoding=utf-8 import cv2 import numpy as np cap = cv2.VideoCapture(0) while(True): ret, frame = cap.read() cv2.imshow('frame', frame) # Press 'q' to exit if cv2.waitKey(1) & 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() Then use python3 in the terminal Run the newly created python file ← Previous Chapter | Next Chapter→ "},"4-SupportAndService/Accessories/10.9-penHolder.html":{"url":"4-SupportAndService/Accessories/10.9-penHolder.html","title":"10.9 PenHolder","keywords":"","body":"myCobot Pen Holder Applicable models: ER myCobot 280 series, ER myPalletizer 260 series, ER mechArm 270 series, ER myBuddy 280 series, ER myCobot Pro 450 Product image Specifications: Name myCobotPro Pen Holder Model myCobot_penHolder_J6 Material Photosensitive resin (painted white) Dimensions 47.5 x 25.0 x 45.5 mm Weight Approx. 35g (excluding pen weight) Pen tip clearance ±1 mm Service life One year Fixing method Lego connector Environment requirements Normal temperature and pressure Applicable equipment Support ER myCobot 280 series ER myPalletizer 260 series ER mechArm 270 series ER myBuddy 280 series ER myCobot Pro 450 myCobot pen holder: Used when writing and drawing with a robotic arm Introduction Overall solid color design, supports 15mm large stroke extension and retraction, effectively reduces errors, and can be used for writing, drawing and other applications. Applicable objects Whiteboard pen Installation and use Installation Insert the Lego connector into the holder hole: Insert the holder with the connector installed into the end of the robot arm Use Insert the pen into the round hole and tighten the four screws to fix it. ← Previous Chapter | Next Chapter→ "},"5-Acknowledgments/5-Acknowledgments.html":{"url":"5-Acknowledgments/5-Acknowledgments.html","title":"11. Acknowledgments","keywords":"","body":"Acknowledgements We would like to express our deep gratitude to all the people who have participated in the development, testing and improvement of the myCobot series of products (including myCobot 280 pi, myCobot 280 M5, myCobot 280 JN, myCobot 280 For Arduino, myCobot Pro 450 and kits). Every detail polished and every feature innovative is inseparable from the hard work and dedication of the team behind it. Special Thanks: R&D Team: Thank you for your innovative thinking and countless days and nights of hard work to transform complex technology into user-friendly products. QA & Testing Team: Your strict control of every detail ensures the reliability of our products and the ultimate experience of users. Customer Support Team: Thank you for providing professional support to our users to help them solve every problem during use. Partners & Suppliers: Your support and service are crucial to the success of the product. Thank you for your high-quality raw materials and components, and your attitude of being ready to support. Investors and Advisors: Without your trust and financial support, we would not be able to bring these innovations to the market. Your insights and guidance have always been our driving force. User Thanks: We are especially grateful to every user who has chosen and trusted the myCobot series of products. Your feedback and suggestions are the driving force for our continuous progress and improvement. We promise to continue to listen to your voice and continuously optimize our products and services. Future Outlook: We look forward to continuing to explore and progress on the road of robotics with all stakeholders. Let us work together to create more possibilities and bring greater convenience and innovation to the world. ← Previous Chapter "}}