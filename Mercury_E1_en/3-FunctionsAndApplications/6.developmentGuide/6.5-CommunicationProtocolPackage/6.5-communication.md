# Development and Use Based on Communication Protocol Packets

## Communication Settings
### Ethernet TCP/IP
- Bus Interface: Gigabit Ethernet Port
- IP: Static IP: 192.168.0.232; For Wi-Fi or Dynamic IP, please refer to the Connection interface on the screen.
- Port: 4500
### 485 Modbus
- Bus Interface: Bottom 485
- Baud Rate: 115200
- Data Bits: 8
- Parity: None
- Stop Bits: 1

## Robotic arm motion and speed parameter table

| Joints | minimum angle(°) |  maximum angle(°) | maximum speed(°/s) | maximum acceleration(°/s²) |
|------|----------------|----------------|---------------------|------------------------|
| J1    | -162           | 162            | 150                | 200                      |
| J2    | -125           | 125            | 150                | 200                    |
| J3    | -154           | 154            | 150                | 200                        |
| J4    | -162           | 162            | 150                | 200                        |
| J5    | -162           | 162            | 150                | 200                 |
| J6    | -165           | 165            | 150                | 200                        |

| Coords | minimum coord(mm) | maximum coord(mm) | maximum speed(mm/s) | maximum acceleration(mm/s²) |
|------|----------------|----------------|---------------------|------------------------|
| x    | -466           | 466            | 200                 | 400                       |
| y    | -466           | 466            | 200                 | 400                    |
| z    | -150           | 677            | 200                 | 400                       |
| rx/ry/rz   | -180°          | 180°           | 40°/s               | 66°/s²                 |
<br>

## Introduction to TCP/IP Commands for Network Interfaces
### Send and Receive Format Both sending and receiving are represented in hexadecimal. Each command contains 5 parts, as shown below:<br> 
`[Frame Header][Frame Header][Length][Function Code][Data][Checksum - High Byte][Checksum - Low Byte]`<br> 
1. Frame Header (2 bytes): 0xFE 0XFE<br>
2. Valid Length (1 byte): 3-N, length starts from the function code and ends with the checksum.<br>
3. Function Code (1 byte): 1-255<br>
4. Data Bits: 0-N, high byte first.<br>
5. Frame Trailer: crc16-modbus, high byte first.<br>
- All commands have first-level receive feedback; position mode control has position feedback.<br>

### Basic Control
1. Read Master Control Version Number<br>
Function Code: 02<br>
Send Data Bits: None<br>
Feedback Data Bits: Version Number - 1 byte, requires /10.0<br>
Send Command: `FE FE 03 02 0D D1`<br>
Feedback Command Example: `FE FE 04 02 0A 51 7D`, where the version number is V1.0<br>

2. Read End Version Number<br>
Function Code: 09<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte 1: Version Number, requires /10.0<br>

3. Start Robot<br>
Function Code: 0x10<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte 1: Startup Status, 0-2; 0 - Startup Failed, 1 - Startup Successful, 2 - Emergency Stop Triggered<br>

4. Shut down the robot<br>
Function code: 0x11<br>
Send data bits: None<br>
Feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>
Feedback command: `FE FE 05 11 FF 01 E8 EC`<br>

5. Read robot startup status<br>
Function code: 0x12<br>
Send data bits: None<br>
Feedback data bits: Byte 1: Startup status, 0-2; 0-Startup failed 1-Startup successful 2-Emergency stop triggered<br>

6. Read zero-position calibration status<br>
Function code: 0x5A<br>
Send data bits: None<br>
Feedback data bits: Byte 1: 0/1; Overall zero-position calibration status Bytes 2-7: 1X6 joint zero-position calibration status<br>

7. Switch Modbus communication<br>
Function code: 0x6A<br>
Send data bits: Byte 1: 0/1 1 - On, 0 - Off. Default is Off.<br>Modbus Send Command: `FE FE 04 6A 01 9D 92`<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

8. Read Modbus Communication Status<br>
Function Code: 0x6B<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte 1: Status 0/1 1 - On, 0 - Off<br>

### Motion Control
- Motion control speed range: 1-100, please refer to the above table of robotic arm motion and speed parameters for actual speed percentage.
- Motion modes: Position interpolation, refresh interruption, torque; only position interpolation provides motion positioning feedback.
- Position positioning feedback data: FE FE 04 5B Status CRC-High CRC-Low; Normal motion command: `FE FE 04 5B 00 CD 46`; Abnormal motion command - J6 over-limit: `FE FE 04 5B 06 CF C6`

1. Full joint angle control<br>
Function code: 0x22<br>
Send data bits: Bytes 1-12: 2X6 joint angle (angle * 100.0) Byte 13: Speed<br>
`[90, 10, -90, 45, 80, -100]`, running speed 50%, send command: `FE FE 10` 22 23 28 03 E8 DC D8 11 94 1F 40 27 10 32 E3 57`<br>
First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>
Second-level position feedback: Only available in interpolation motion mode, `FE FE 04 5B 00 CD 46`<br>

2. Single joint angle control<br>
Function code: 0x21<br>
Send data bits: Byte 1: Joint; Bytes 2-3: Angle (angle * 100.0) Byte 4: Speed<br>J1 moves to 50°, running speed 10%, send command: `FE FE 07 21 01 13 88 0A 82 7A`<br>
First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>

3. Read All Joint Angles<br>
Function Code: 0x20<br>Send Data Bits: None<br>
Feedback Data Bits: Bytes 1-12: 2x6 Joint Angles (Angle/100.0)<br>
`[90, 10, -90, 45, 80, -100]` Feedback Command: `FE FE 10 20 23 28 03 E8 DC D8 11 94 1F 40 27 10 32 21 54`<br>

4. Full Coordinate Control<br>
Function Code: 0x25<br>
Send Data Bits: Bytes 1-12: 2x6 Coordinates (XYZ*10.0, RXRYRZ*100.0) Byte 13: Speed<br>
First Layer Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

5. Single coordinate control<br>
Function code: 0x24<br>
Send data bits: Byte 1: Coordinate axis; Bytes 2-3: Coordinate (XYZ*10.0, RXRYRZ*100.0) Byte 4: Velocity<br>
First layer feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>

6. Read full coordinates<br>
Function code: 0x23<br>
Send data bits: None<br>
Feedback data bits: Bytes 1-12: 2X6 coordinate (XYZ/10.0, RXRYRZ/100.0)<br>

7. Read robot motion status<br>
Function code: 0x2B<br>Send data bits: None<br>
Feedback data bits: Byte 1: Motion status 0/1, 0 - not moving; 1 - moving<br>

8. Detecting if the robot has reached the designated point<br>
 Code: 0x2A, Error accuracy within 1° angle, within 2mm coordinates<br>
 Send Data Bits: Bytes 1-12: 2*6 joint angles/coordinates (angle * 100.0, coordinates XYZ * 10.0, RXRYRZ * 100.0); Byte 13: Mode 1/2 1-Angle 2-Coordinate<br>
 Feedback Data Bits: Byte 1: Position Status 0/1 0-Not in position, 1-In position<br>

9. Motion Pause<br>
Function Code: 0x26<br>
Send Data Bits: None<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

10. Motion Resumption<br>
Function Code: 0x28<br>
Send Data Bits: None<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

11. Movement End<br>
Function Code: 0x29<br>
Send Data Bits: None<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

12. Detect Movement Pause<br>
Function Code: 0x27<br>
Send Data Bits: None<br>Feedback Data Bits: Byte 1: Pause Status 0/1, 0 - Not Manually Paused; 1 - Paused<br>

13. Continuous Joint Movement<br>
Function Code: 0x30<br>
Send Data Bits: Byte 1: Joint; Byte 2: Direction 0/1 0 - Reverse Rotation 1 - Forward Rotation Byte 3: Speed<br>
First Layer Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

14. Continuous Coordinate Movement<br>
Function Code: 0x32<br>
Send Data Bits: Byte 1: Coordinate Axis; Byte 2: Direction 0/1 0 - Reverse Rotation 1-Forward Rotation Byte 3: Speed<br>
First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>

15. RPY Rotation<br>
Function Code: 0xF5<br>
Send Data Bits: Byte 1: Mode 1-3 1-Roll Angle 2-Pitch Angle 3-Yaw Angle; Byte 2: Direction 0/1 0-Reverse Rotation 1-Forward Rotation Byte 3: Speed<br>
First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>

16. Joint Stepping Control<br>
Function Code: 0x33<br>
Send Data Bits: Byte 1: Joint; Bytes 2-3: Step Value * 100.0 Byte 3: Speed<br>
First-level feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>

17. Coordinate Stepping Control<br>
Function Code: 0x34<br>
Send Data Bits: Byte 1: Coordinate Axis; Bytes 2-3: Step Value (XYZ*10.0, RXRYRZ*100.0) Byte 4: Velocity<br>
First Layer Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

18. Calculate Inverse Kinematics<br>
Function Code: 0x8D<br>
Send Data Bits: Bytes 1-12: Current Angle of 2x6 Joint Bytes 13-26: Target Coordinate Value of 2x6 Joint<br>
Feedback Data Bits: Bytes 1-24: Angle of 4x6 Joint (/100.0)<br>

19. Start Drag Teaching<br>
Function Code: 0x70<br>
Send Data Bits: None<br>
Feedback Data Bits: 0xFF 0x01<br>

20. Pause Sampling<br>
Function Code: 0x72<br>
Send Data Bits: None<br>
Feedback Data Bits: 0xFF 0x01<br>

21. Execute Teaching Point<br>
Function Code: 0x71<br>
Send Data Bits: None<br>
Feedback Data Bits: 0xFF 0x01<br>

22. Clear Sampling Point<br>
Function Code: 0x73<br>
Send Data Bits: None<br>
Feedback Data Bits: 0xFF 0x01<br>

23. Query Collision Detection Mode<br>
Function Code: 0xFD<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte 1: 0/1, 1-open 0-close<br>

24. Set Collision Detection Mode<br>
Function Code: 0x74<br>
Send Data Bits: 1-open 0-close After enabling collision detection, the robotic arm will automatically stop if a collision lasting longer than 200ms and exceeding the collision threshold occurs during movement.<br>
Feedback Data Bits: 0xFF 0x01<br>

25. Set Collision Threshold<br>
Function Code: 0x75<br>
Send Data Bits:<br>
Byte 1: joint range:(1-6)<br>
Byte 2: radio range:(50-250)%<br>
You can set the collision threshold for the joints. The default value is 100%. The smaller the value, the easier it is to trigger a collision.<br>
Feedback Data Bits: 0xFF 0x01<br>

26. Get Collision Threshold<br>
Function Code: 0x76<br>
Send Data Bits: None<br>
Feedback Data Bits:<br>
Bytes 1-6: Collision threshold for all joints<br>

27. Set Torque Compensation Coefficient<br>
Function Code: 0x77<br>
Send Data Bits:<br>
Byte 1: joint range:(1-6)<br>
Byte 2: radio range:(0-250)% Friction compensation coefficient for the torque ring. The default value is 0. The larger the coefficient, the easier it is to drag.<br>
Byte 3: Damping: 0-close 1-open Impedance switch, default is off. Turning it on increases damping; higher damping makes it harder to drive.<br>
Feedback data bits: 0xFF 0x01<br>

28. Obtain Torque Compensation Coefficient<br>
Function Code: 0x78<br>
Send Data Bits: None<br>
Feedback Data Bits:<br>
Bytes 1-6: Full-Joint Torque Compensation Coefficient<br>
Bytes 7-12: Full-Joint Impedance Switch<br>

29. Execute Dynamic Trajectory Identification<br>
Function Code: 0xF8<br>
Send Data Bits: Byte 1: rank (0-1), 0: Identify Trajectory, 1: Low-Speed ​​Identify Trajectory<br>
Feedback Data Bits: 0xFF 0x01<br> 
Execute the trajectory identification, which takes 24 seconds. The movement is relatively large, so please pay attention to safety. Before use, you need to execute the low-speed trajectory using fourier_trajectories(1) to confirm the safe range. After the low-speed execution is completed, execute the normal speed fourier_trajectories(0).<br> 

30. Dynamic parameter identification<br> 
Function code: 0x97<br> 
Send data bits: None<br> 
Feedback data bits: 0xFF 0x01<br> 
One-click identification requires first executing the dynamic trajectory identification to generate the identify_data.log file. The identification takes five minutes. After the identification is completed, the identification accuracy will be automatically calculated. If the accuracy meets the standard, it will be automatically written to the dynamic_paremeters.log file.<br> 

31. Circular Trajectory Motion<br>
Function Code: 0x8C<br>
Send Data Bits:<br>
Circular Trajectory Points (transpoint) Circular End Points (endpoint)<br>
Bytes 1-2: transpoint.x (*10) Bytes 13-14: endpoint.x (*10)<br>
Byte 25: speed (1-100)<br>
Bytes 3-4: transpoint.y Bytes 15-16: endpoint.y<br>
Bytes 5-6: transpoint.z Bytes 17-18: endpoint.z<br>
Bytes 7-8: transpoint.rx (*100)<br>
Bytes 19-20: endpoint.rx (*100)<br>
Bytes 9-10: transpoint.ry Bytes 21-22: endpoint.ry<br>
Bytes 11-12: transpoint.rz Bytes 23-24: endpoint.rz<br> Feedback data bits: 0xFF 0x01<br> 
Based on the current position of the robotic arm (starting point), the given arc transit point (transpoint), and the arc ending point (endpoint), an arc is determined by these three points, causing the robotic arm to execute the arc trajectory in the order of starting point, transit point, and ending point.<br> 

32. Set Motion Mode<br> 
* This interface takes a relatively long time to execute, approximately 4ms.<br> 
Function code: 0x16<br> 
Send data bits: Byte 1: Mode 0/1 0-Position 1-Refresh, the robot intelligently uses refresh mode; default is position mode.<br> 
Feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>

33. Read Motion Mode<br> 
Function code: 0x17<br> 
Send data bits: None<br> 
Feedback data bits: Byte 1: Mode 0/1 0-Position 1-Refresh<br>

34. Set Motion Control Mode
* This interface takes a relatively long time to execute, approximately 4ms.<br>
Function Code: 0x1E<br>
Send Data Bits: Byte 1: Mode 0/1 0-Position 1-Torque, zero-force drag; Default position mode<br>
Feedback Data Bits: Byte 1: 0xFF, Byte 2: 0/1 0-Setting failure, incorrect parameters; 1-Parameter correct<br>

35. Read Motion Control Mode<br>
Function Code: 0x1F<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte 1: Mode 0/1 0-Position 1-Torque, zero-force drag<br>

36. Over-limit Return to Zero
* After exceeding the limit, manual movement back to the limit is not required; currently only supported in position mode, not in refresh mode control.<br>
Function Code: 04<br>
Send Data Bits: None<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

### Auxiliary Functions
#### Configuration
* Zero position setting is required after system update before movement.<br>
1. Setting Zero Position<br>
Function Code: 0x54<br>
Send Data Bits: Byte 1: Joint<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

2. Setting Robot Torque Status<br>
Function Code: 0x13<br>
Send Data Bits: Byte 1: Joints 1-6 254-All; Byte 2: Mode 0/1 0-Disabled 1-Enabled; Movement is only possible when enabled<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

3. Setting RGB Color<br>
Function Code: 0x0C<br>
Send Data Bits: Bytes 1-3: R, G, B Range 0-255, All 0s-Lights off<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

4. Set Maximum Speed<br>
Function Code: 0x41<br>
Send Data Bits: Byte 1: Mode 0/1 0-Angle 1-Coordinate Bytes 2-3: Speed, set only within the maximum range<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

5. Set Maximum Acceleration<br>
Function Code: 0x43<br>Send Data Bits: Byte 1: Mode 0/1 0-Angle 1-Coordinate Bytes 2-3: Acceleration, set only within the maximum range<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

6. Read Maximum Speed<br>
Function Code: 0x40<br>
Send Data Bits: None<br>
Feedback Data Bits: Bytes 1-2: Speed<br>

7. Read Maximum Acceleration<br>
Function Code: 0x42<br>
Send Data Bits: None<br>
Feedback Data Bits: Bytes 1-2: Acceleration<br>

8. Set Joint Minimum Angle<br>
Function Code: 0x4c<br>
Send Data Bits: Byte 1: Joint Bytes 2-3: Minimum Angle * 10.0; Can only be set within the default range, no error will occur upon power failure<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

9. Read Joint Minimum Angle<br>
Function Code: 0x4a<br>
Send Data Bits: Byte 1: Joint<br>
Feedback Data Bits: Bytes 1-2: Minimum Angle / 10.0<br>

10. Set Joint Maximum Angle<br>
Function Code: 0x4d<br>
Send Data Bits: Byte 1: Joint Bytes 2-3: Maximum angle * 10.0; can only be set within the default range, no error will occur upon power failure.<br> 
Feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>

11. Read the maximum angle of the joint<br>
Function code: 0x4b<br>
Send data bits: Byte 1: Joint<br>
Feedback data bits: Bytes 1-2: Maximum angle / 10.0<br>

12. Set the joint direction<br>
* Pls move to zero position,then read the current direction first, latest set it<br>
Function code: 0x7D<br>
Send data bits: Byte 1: Joint Byte 2: Direction 0/1 1-Same direction 0-Opposite direction<br>
Feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>

13. Read Joint Direction<br>
Function Code: 0x7C<br>
Send Data Bits: None<br>
Feedback Data Bits: Bytes 1-6: 1x6 Joint Direction<br>

14. Read VR Mode<br>Function Code: 0x79<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte: 1-open 0-close<br>
Enabling VR mode reduces the motion command buffer length from 80 to 2. Suitable for development scenarios where motion buffer accumulation is undesirable, such as VR control and remote control.<br>

15. Set VR Mode<br>
Function Code: 0x7a<br>
Send Data Bits: Byte: 1-open 0-close<br>
Feedback Data Bits: 0xFF 0x01<br>

16. Set Free Movement Status<br>
* Off by default. When enabled, the robotic arm can be manually rotated by pressing and holding the end button for 1 second.<br>
Function Code: 0x1A<br>
Send Data Bits: Byte 1: 1-open 0-close<br>
Feedback Data Bits: 0xFF 0x01<br>

17. Read Free Movement Status<br>
Function Code: 0x1B<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte 1: 1-open 0-close<br>

#### IO Control
##### Bottom IO
1. Set Base IO Output<br>
Function Code: 0xA0<br>
Transmit Data Bits: Byte 1: Pin Number 1-12 Byte 2: Status 0/1 0 - Low 1 - High<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

2. Read Base IO Input<br>
Function Code: 0xA1<br>
Transmit Data Bits: Byte 1: Pin Number 1-12<br>
Feedback Data Bits: Byte 1: Status 0/1 0 - Low 1 - High<br>

##### End IO
1. Set End IO Output<br>
Function Code: 0x61<br>
Transmit Data Bits: Byte 1: Pin Number 1/2 Byte 2: Status 0/1 0 - Low 1 - High<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

2. Read all pin statuses at the end<br>
Function code: 0x7B<br>
Transmit data bits: None<br>
Feedback data bits: Byte 1: Input 1 status 0/1 0-low level 1-high level; Byte 2: Input 2 status; Byte 3: End button 1 status; Byte 4: End button 2 status<br>


#### External 485/CAN communication device control
1. Bottom external device configuration<br>
Function code: 0x65<br>
Transmit data bits: Byte 1: Mode 1/2 1-485 device 2-CAN device; Bytes 2-5: Baud rate; Bytes 6-9: Timeout<br>
Feedback fixed data bits: Bytes 1-2: 0xFF 0x01<br>

2. Read bottom external device configuration<br>
Function code: 0x67<br>
Transmit data bits: None<br>
Feedback data bits: Byte 1: Mode 1/2 1-485 device; 2-CAN device; Bytes 2-5: Baud rate; Bytes 6-9: Timeout<br>

3. Bottom External Device Control<br>
Function Code: 0x66<br>
Send Data Bits: CAN Device: Bytes 1-4: CAN_id; Bytes 5-N: CAN data, maximum 8; 485 Device: 1-N: 485 data, maximum 100<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

4. End 485 External Device Control<br>
Function Code: 0xB5<br>
Send Data Bits: Bytes 1-N: 485 data, maximum 45<br>
Feedback Data Bits: Bytes 1-N: 485 data returned by the device<br>

5. Set Terminator 485 Baud Rate
* Default 115200<br> 
Function Code: 0xB8<br> 
Send Data Bits: Bytes 1-4: Baud Rate<br> 
Feedback Data Bits: 0xFF 0x01<br>

6. Set Terminator 485 Timeout<br>
* Default 10s<br> Function Code: 0xB9<br> 
Send Data Bits: Bytes 1-2: Timeout, Unit: ms, Range: 1-10s<br> 
Feedback Data Bits: 0xFF 0x01<br>

7. Read Terminator 485 Baud Rate Timeout<br> 
Function Code: 0xBA<br> 
Send Data Bits: None<br> 
Feedback Data Bits: Bytes 1-4: Baud Rate, Bytes 5-6: Timeout<br>

#### Status Query
1. Read Robot Status<br>
Function Code: 0xA2<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte 1: Collision Detection Status 0/1 1-Collision; Byte 2: Movement Status 0/1 1-In Motion; Bytes 3-8: 1x6 Joint Exceeding Limits 0/1 1-Exceeding Limits; Bytes 9-20: 2x6 Joint Motor Errors 0-Normal >0 Abnormal; Bytes 21-32: 2x6 Joint Motor Software Errors 0-Normal >0 Abnormal; See error messages and position feedback table for details.<br>

2. Read Motion Error Information<br>
Function Code: 0x07<br>
Send Data Bits: None<br>
Feedback Data Bits: Bytes 1-2: Error Messages, see error messages and position feedback table for details.<br>

3. Read Joint Communication Error Count<br>
Function Code: 0xA3<br>
Send Data Bits: Byte 1: Joints 1-6<br>
Feedback Data Bits: Bytes 1-2: Joint Send Error Count 0-32700; Bytes 3-4: Joint Read Error Count 0-32700; Bytes 5-6: Endpoint Send Error Count 0-32700; Bytes 7-8: Endpoint Read Error Count 0-32700<br>

4. Read Joint Running Speed<br>
Function Code: 0xE1<br>
Send Data Bits: None<br>
Feedback Data Bits: Bytes 1-12: 2x6 Running Speed ​​/ 100.0 0-30rpm<br>

5. Get Joint Current<br>
Function Code: 0xE2<br>
Send Data Bits: None<br>
Feedback Data Bits: Bytes 1-12: 2x6 Joint Current Unit: MA<br>

#### Set Coordinate System
1. Set Tool Coordinate System<br>
Function Code: 0x81<br>
Send Data Bits:<br>
Bytes 1-2: x (±1000) (10xmm)<br>
Bytes 3-4: y (±1000)<br>
Bytes 5-6: z (±1000)<br>
Bytes 7-8: rx (±180) (100xDeg)<br>
Bytes 9-10: ry (±180)<br>
Bytes 11-12: rz (±180)<br>
Feedback Data Bits: 0xFF 0x01<br>

2. Read Tool Coordinate System<br>
Function Code: 0x82<br>
Send Data Bits: None<br>
Feedback Data Bits:<br>
Bytes 1-2: x (±1000) (10xmm)<br>
Bytes 3-4: y(±1000)<br>
Bytes 5-6: z (±1000)<br>
Bytes 7-8: rx (±180) (100xDeg)<br>
Bytes 9-10: ry (±180)<br>
Bytes 11-12: rz (±180)<br>

3. Set World Coordinate System<br>
 Function Code: 0x83<br>
 Data Bits Sent:<br>
 Bytes 1-2: x (±1000) (10xmm)<br>
 Bytes 3-4: y(±1000)<br>
 Bytes 5-6: z (±1000)<br>
 Bytes 7-8: rx (±180) (100xDeg)<br>
 Bytes 9-10: ry (±180)<br>
 Bytes 11-12: rz (±180) <br>
 Feedback Data Bits: 0xFF 0x01<br>

4. Read World Coordinate System<br>
 Function Code: 0x84<br>
 Send Data Bits: None<br>
 Feedback Data Bits:<br>
 Bytes 1-2: x (±1000) (10xmm)<br>
 Bytes 3-4: y (±1000)<br>
 Bytes 5-6: z (±1000)<br>
 Bytes 7-8: rx (±180) (100xDeg)<br>
 Bytes 9-10: ry (±180)<br>
 Bytes 11-12: rz (±180)<br>

5. Set Base Coordinate System<br>
 Function Code: 0x85<br>
 Send Data Bits: Byte 1: base type (0-base coordinate system 1-world coordinate system)<br>
 Feedback Data Bits: 0xFF 0x01<br>

6. Read Base Coordinate System<br>
Function Code: 0x86<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte 1: base type (0-Base Coordinate System 1-World Coordinate System)<br>

7. Set End Coordinate System<br>
Function Code: 0x89<br>
Send Data Bits: Byte 1: end type (0-Flange 1-Tool)<br>
Feedback Data Bits: 0xFF 0x01<br>

8. Read End Coordinate System<br>
Function Code: 0x8A<br>
Send Data Bits: None<br>
Feedback Data Bits: Byte 1: end type (0-Flange 1-Tool)<br>

#### Error Clearing
1. Clear Motion Errors<br>
* Clear motion reading errors, such as exceeding limits, coordinates unreachable, etc.<br>
Function Code: 08<br>
Send Data Bits: None<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

2. Joint Abnormal Recovery<br>
* Clear some joint motor errors<br>
Function Code: 0xE7<br>
Send Data Bits: Byte 1: Joints 1-6, 254-All Joints<br>
Feedback Fixed Data Bits: Bytes 1-2: 0xFF 0x01<br>

## Introduction to 485 Modbus RTU Commands
### Transmit/Receive Formats
#### Basic Parameters
| Parameter | Value (decimal) | Value (hexadecimal) |
|------|--------------|----------------|
| Address | 45 | 0x2D |
| Write Function Code | 16 | 0x10 |
| Read Function Code | 03 | 0x03 |

#### Communication Frame Format

##### 1. Write Command (Host → Device)

| Field | Length | Hexadecimal Representation | Description |
|------|------|--------------|------|
| Address | 1 byte | `0x2D` | Device Address: 45 (0x2D) |
| Function Code | 1 byte | `0x10` | Write to multiple registers |
| Starting Register Address | 2 bytes | `HH LL` | Register Start Address (low byte first) |
| Number of Registers | 2 bytes | `HH LL` | Number of registers to write N |
| Number of Data Bytes | 1 byte | `0xMM` | Number of data bytes = 2×N |
| Data | 2×N bytes | `DD DD ...` | Actual data (2 bytes per register) |
| Checksum | 2 bytes | `CC CC` | Modbus CRC16 (low byte first) |

**Format:** `[Address-45][Function Code-0x10][Start Register Address-2 bytes][Number of Registers-2 bytes][Number of Data Bytes-1 byte][Data-2*N bytes][Checksum-2 bytes modbus_crc16-low byte first]`

##### 2. Write Feedback (Device → Host)

| Fields | Length | Hexadecimal Representation | Description |
|------|------|--------------|------|
| Address | 1 byte | `0x2D` | Device Address: 45 (0x2D) |
| Function Code | 1 byte | `0x10` | Write Multiple Registers |
| Starting Register Address | 2 bytes | `HH LL` | Register Start Address (Low Byte First) |
| Number of Registers | 2 bytes | `HH LL` | Number of Registers Written |
| Checksum | 2 bytes | `CC CC` | Modbus CRC16 (Low Byte First) |

**Format:** `[Address-45][Function Code-0x10][Starting Register Address-2 bytes][Number of Registers-2 bytes][Checksum-2 bytes modbus_crc16-Low Byte First]`

##### 3. Read Command (Host → Device)
| Fields | Length | Hexadecimal Representation | Description |
|------|------|--------------|------|
| Address | 1 byte | `0x2D` | Device Address: 45 (0x2D) |
| Function Code | 1 byte | `0x03` | Read Multiple Registers |
| Starting Register Address | 2 bytes | `HH LL` | Register Start Address (Low Byte First) |
| Number of Registers | 2 bytes | `HH LL` | Number of Registers to Read N |
| Checksum | 2 bytes | `CC CC` | Modbus CRC16 (Low Byte First) |

**Format:** `[Address-45][Function Code-03][Starting Register Address-2 bytes][Number of Registers-2 bytes][Checksum-2 bytes modbus_crc16-Low Byte First]`

##### 4. Read Feedback (Device → Host)
| Field | Length | Hexadecimal Representation | Description |
|------|------|--------------|------|
| Address | 1 byte | `0x2D` | Device Address: 45 (0x2D) |
| Function Code | 1 byte | `0x03` | Read multiple registers |
| Number of Data Bytes | 1 byte | `0xMM` | Number of Data Bytes = 2×N |
| Data | 2×N bytes | `DD DD ...` | Data read (2 bytes per register) |
| Checksum | 2 bytes | `CC CC` | Modbus CRC16 (low byte first) |

**Format:** `[Address-45][Function Code-03][Number of Data Bytes-1 byte][Data-2*N bytes][Checksum-2 bytes modbus_crc16-low byte first]`

##### Case Studies:

1. Read angle in hexadecimal format: `2D 03 00 20 00 01 82 6C`<br>

Feedback: `2D 03 0C 23 28 00 10 11 94 00 20 03 A8 DC D8 3B 46`<br>
2. Move all joints at 16% speed to `[90, 0.16, 45, 0.32, 10, -90]`: `2D 10 00 22 00 07 0E 23 28 00 10 11 94 00 20 03 A8 DC D8 00 10 66 60`<br>

First-level feedback: `2D 10 00 22 00 07 26` 6D`<br>
Second layer feedback: Normal positioning: `2D 10 00 5B 00 07 00 00 46 47`, J1 over-limit: `2D 10 00 5B 00 07 00 01 87 87`<br>

### Basic Control
1. Read Main Control Version Number<br>
Register Address: 00 02<br>
Number of Registers: 00 01<br>
Feedback Data Bits: 2 bytes, requires /10.0<br>
Send Command (Hexadecimal): 2D 03 00 02 00 01 22 66<br>
Feedback Command Example: 2D 03 02 00 0A A9 85, version number is V1.0<br>

2. Start Robot<br>
Register Address: 00 16<br>
Number of Registers: 00 00<br>
Send Data Bits: None<br>
Feedback Data Bits: Bytes 1-2: Startup Status, 0-2; 0 - Startup Failed, 1 - Startup Successful, 2 - Emergency Stop Triggered<br>

3. Shut Down Robot<br>
Register Address: 00 17<br>
Number of Registers: 00 00<br>
Send data bits: None<br>

4. Read robot startup status<br>
Register address: 00 18<br>
Number of registers: 00 01<br>
Feedback data bits: Bytes 1-2: Startup status, 0-2; 0 - Startup failed, 1 - Startup successful, 2 - Emergency stop detected<br>

### Motion Control
- Motion control speed range: 1-100, actual speed percentage can be found in the robotic arm motion and speed parameter table.
- Position feedback format: `[address][function code][register address][number of registers][position status][crc]`
- Position feedback data: Normal position: `2D 10 00 5B 00 07 00 00 46 47`, J3 over-limit: `2D 10 00 5B 00 07 00 03 06 46`

1. Full joint angle control<br>
Register address: 00 34<br>
Number of registers: 00 07<br>
Send data bits: Bytes 1-12: 2x6 joint angle (angle * 100.0) Bytes 13-14: Speed<br>

2. Single joint angle control<br>
Register address: 00 33<br>
 Number of registers: 00 03<br>
 Transmit data bits: Bytes 1-2: Joint; Bytes 3-4: Angle (angle * 100.0); Bytes 5-6: Speed<br>

3. Read all joint angles<br>
 Register address: 00 32<br>
 Number of registers: 00 01<br>
 Feedback data bits: Bytes 1-12: 2x6 joint angle (angle / 100.0)<br>

4. Full coordinate control<br>
 Register address: 00 37<br>
 Number of registers: 00 07<br>
 Transmit data bits: Bytes 1-12: 2x6 coordinates (XYZ * 10.0, RXRYRZ * 100.0); Bytes 13-14: Speed<br>

5. Single coordinate control<br>
 Register address: 00 36<br>
 Number of registers: 00 03<br>
Send data bits: Bytes 1-2: Coordinate axes; Bytes 3-4: Coordinates (XYZ*10.0, RXRYRZ*100.0); Bytes 5-6: Velocity<br>

6. Read all coordinates<br>
Registry address: 00 35<br>
Number of registers: 00 01<br>
Feedback data bits: Bytes 1-12: 2x6 coordinates (XYZ/10.0, RXRYRZ/100.0)<br>

7. Read robot motion status<br>
Registry address: 00 43<br>
Number of registers: 00 01<br>
Feedback data bits: Bytes 1-2: Motion status 0/1, 0 - not moving; 1 - moving<br>

8. Pause motion<br>
Registry address: 00 38<br>
Number of registers: 00 01<br>
Send data bits: Bytes 1-2: 0/1 1 - Slow pause 0 - Emergency pause<br>

9. Movement recovery<br>
Register address: 00 40<br>
Number of registers: 00 00<br>
Send data bits: None<br>

10. Movement end<br>
Register address: 00 41<br>
Number of registers: 00 00<br>
Send data bits: None<br>

11. Detect movement pause<br>
Register address: 00 39<br>
Number of registers: 00 01<br>
Feedback data bits: Bytes 1-2: Pause status 0/1, 0 - Not manually paused; 1 - Paused<br>

12. Continuous joint movement<br>
Register address: 00 48<br>
Number of registers: 00 03<br>
Send data bits: Bytes 1-2: Joint; Bytes 3-4: Direction 0/1 0 - Reverse 1 - Forward Bytes 5-6: Speed<br>

13. Continuous Coordinate Motion<br>
Registry Address: 00 50<br>
Number of Registers: 00 03<br>
Send Data Bits: Bytes 1-2: Coordinate Axis; Bytes 3-4: Direction 0/1 0 - Reverse 1 - Forward Bytes 5-6: Speed<br>

14. RPY Rotation<br>
Registry Address: 00 245<br>
Number of Registers: 00 03<br>
Send Data Bits: Bytes 1-2: Mode 1-3 1 - Roll Angle 2 - Pitch Angle 3 - Yaw Angle; Bytes 3-4: Direction 0/1 0 - Reverse 1 - Forward Bytes 5-6: Speed<br>

15. Joint Stepping Control<br>
Registry Address: 00 51<br>
Number of Registers: 00 03<br>
Send data bits: Bytes 1-2: Joint; Bytes 3-4: Step value * 100.0; Bytes 5-6: Speed<br>

16. Coordinate Stepping Control<br>
Register Address: 00 52<br>
Number of Registers: 00 03<br>
Send data bits: Bytes 1-2: Coordinate axis; Bytes 3-4: Step value (XYZ * 10.0, RXRYRZ * 100.0); Bytes 5-6: Speed<br>

17. Over-limit Return to Zero
* After exceeding the limit, it is not necessary to manually move back to the limit; currently only supported in position mode, not in refresh mode control<br>
Register Address: 00 04<br>
Number of Registers: 00 00<br>
Send data bits: None<br>

### Auxiliary Functions
#### Configuration
1. Set RGB Color<br>
Register Address: 00 12<br>
Number of Registers: 00 03<br>
Send Data Bits: Bytes 1-2: R; Bytes 3-4: G; Bytes 5-6: B Range 0-255, all 0s - light off<br>

2. Set Robot Torque Status<br>
Register Address: 00 19<br>
Number of Registers: 00 02<br>
Send Data Bits: Bytes 1-2: Joints 1-6 254 - All; Bytes 3-4: Mode 0/1 0 - Disabled 1 - Enabled; Movement is only possible when enabled<br>

#### IO Control
##### Bottom IO
1. Set Base IO Output<br>
Register Address: 00 160<br>
Number of Registers: 00 02<br>
 Transmit data bits: Bytes 1-2: Pin numbers 1-12 Bytes 3-4: Status 0/1 0-Low level 1-High level<br>

2. Read dock I/O input<br>
 Register address: 00 161<br>
 Number of registers: 00 01<br>
 Feedback data bits: Bytes 1-24: 2*12 pin status 0/1 0-Low level 1-High level<br>

##### Terminal I/O
1. Set terminal I/O output<br>
 Register address: 00 97<br>
 Number of registers: 00 02<br>
 Transmit data bits: Bytes 1-2: Pin numbers 1/2 Bytes 3-4: Status 0/1 0-Low level 1-High level<br>

2. Read all terminal pin statuses<br>
 Register address: 00 123<br>
 Number of registers: 00 01<br>
Send data bits: None<br>
Feedback data bits: Bytes 1-2: Input 1 status 0/1 0-low level 1-high level; Bytes 3-4: Input 2 status; Bytes 5-6: End button 1 status; Bytes 7-8: End button 2 status<br>

#### Status Query
1. Read robot status<br>
Register address: 00 162<br>
Number of registers: 00 01<br>
Feedback data bits: Bytes 1-2: Collision detection status 0/1 1-collision; Bytes 3-4: Movement status 0/1 1-moving; Bytes 5-16: 1x6 joint over-limit status 0/1 1-over-limit; Bytes 17-28: 2x6 joint motor error status 0-normal >0 abnormal; Bytes 29-40: 2x6 joint motor software error 0-normal >0 abnormal; See error information and position feedback table for details<br>

2. Read Motion Error Information<br>
Registry Address: 00 07<br>
Number of Registers: 00 01<br>
Feedback Data Bits: Bytes 1-2: Error information, see error information and position feedback table for details<br>

3. Read Joint Running Speed<br>
Registry Address: 00 225<br>
Number of Registers: 00 01<br>
Feedback Data Bits: Bytes 1-12: 2x6 running speed / 100.0 +-30rpm<br>

4. Get Joint Current<br>
Registry Address: 00 226<br>
Number of Registers: 00 01<br>
Feedback Data Bits: Bytes 1-12: 2x6 joint current, unit: MA<br>

#### Exception Clearing
1. Clear Motion Errors<br>
* Clear motion reading errors, such as exceeding limits, coordinates not reaching, etc.<br>
Registry Address: 00 08<br>
 Number of registers: 00 00<br>
 Data bits sent: None<br>

2. Joint Abnormal Recovery<br>
* Clear some joint motor errors<br>
Register address: 00 231<br>
Number of registers: 00 01<br>
Data bits sent: Bytes 1-2: Joints 1-6, 254-All joints<br>

## Common Problems
1. Robotic arm cannot move?<br>
* Check if the robotic arm is enabled, if there are any errors in the joint motors, and if any joints are out of limits. You can call **Read Robot Status**.<br>
2. No response to commands<br>
* Check if the sent commands are correct. All commands have a first-level handshake feedback.<br>

## Error Messages and Position Feedback Form
### Position Feedback Form
#### 0-20 Joint Overlimit, Collision, Pause, etc.
| Hexadecimal (Decimal) | Description |
|-----------------|------|
| 0 | Movement in Position |
| 1-7 | Joint Overlimit |
| 8 | End of Movement Mode Setting |
| 10-13 | Collision Protection |
| A (10) | End of Ease Marker |
| B (11) | Command Stop Marker |

#### 20-23 (32-35) Coordinate motion anomaly (Check joint limits)
| Hexadecimal (Decimal) | Description |
|-----------------|------|
| 20 (32) | No coordinate solution |
| 21 (33) | No adjacent solution for linear motion |
| 22 (34) | Velocity fusion error |
| 23 (35) | No adjacent solution for zero-space motion |
| 24 (36) | No solution for singular position |
| 31 (49) | Identification accuracy error |

#### 41-47 (65-71) Joint Abnormality
| Hexadecimal (Decimal) | Description |
|-----------------|------|
| 41-47 (65-71) | 1-7 Joint Position Accuracy Abnormality |
| 51-57 (81-87) | 1-7 Joint Collision Detection Abnormality |
| 0x61-67 | 1-7 Joint CAN Transmission Failure |
| 0x71-77 | 1-7 Joint CAN Reception Abnormality |
| 0x81-87 | 1-7 Joint Enabled |
| 0x91-97 | 1-7 Joint Motor Error (Can be used with 0x9c interface after error) |
| 0xA1-A7 | 1-7 Joint Motor Encoder Error |
| 0xC1-C7 | 1-7 Joint Position Out of Tolerance |
<br>

### Motion Error Message Table
**Return Data Format:** 0xD0 + xx (e.g., 0xD001 indicates 1 joint exceeds limit)
#### 0-6 Joint Exceeds Limit
| Status Code (Decimal) | Hexadecimal | Description |
|------------------|--------|------|
| 0 | 0x00 | Normal Motion |
| 1 | 0x01 | 1 Joint Exceeds Limit |
| 2 | 0x02 | 2 Joints Exceeds Limit |
| 3 | 0x03 | 3 Joints Exceeds Limit |
| 4 | 0x04 | 4 Joints Exceeds Limit |
| 5 | 0x05 | 5 Joints Exceeds Limit |
| 6 | 0x06 | 6 Joints Exceeds Limit |

#### 20-24 (32-36) Coordinate Motion Abnormality
| Status Code (Decimal) | Hexadecimal | Explanation |
|------------------|--------|------|
| 20 (32) | 0x14 | No solution for coordinates, please check if the arm span is near the limit |
| 21 (33) | 0x15 | No adjacent solution for linear motion |
| 22 (34) | 0x16 | Velocity fusion error |
| 23 (35) | 0x17 | No adjacent solution for zero-space motion |
| 24 (36) | 0x18 | No solution for singular position, please use joint control to leave the singular point |
<br>

### Joint Motor Error Message Table
#### 1. Software Error Alarms
Bits (2 bytes) | Error Status (1 - Abnormal, 0 - Normal) | Description and Handling Suggestions
---|---|---
0 | Can Initialization Abnormal | Requires checking the main control board. After fixing the control board abnormality, power off and then power on again. <br>Symptoms: The machine cannot be enabled or controlled, etc.
1 | Motor Initialization Abnormal | Requires checking the motor communication line, etc. After fixing the abnormality, power off and then power on again. <br>Symptoms: The machine cannot properly feedback joint information or control, etc.
2 | Motor Sending Abnormal | Requires checking the motor communication line, etc. <br>Symptoms: Abnormal machine position feedback, etc.; can be cleared using abnormal recovery.
3 | Motor Receiving Abnormal | Requires checking the motor communication line, etc. <br>Symptoms: Abnormal machine position feedback, etc.; can be cleared using abnormal recovery. <br>This feedback allows normal machine control and does not require user notification; it is mainly used for troubleshooting.
4 | Position Out of Tolerance | Requires checking the motor encoder, etc. <br>Symptoms: Machine is disabled and cannot be controlled; can be cleared using exception recovery.
5 | End-point transmission anomaly | Need to check end-point communication lines, etc.Symptoms: End-point interface feedback anomaly; can be cleared using exception recovery.
6 | End-point reception anomaly | Need to check end-point communication lines, etc.Symptoms: End-point interface feedback anomaly; can be cleared using exception recovery.This feedback allows normal machine control without user notification; mainly used for troubleshooting anomalies.
7 | Motor encoder error | When the encoder reports an error, movement is impossible; the encoder error needs to be cleared.Older motor drive boards do not report errors - even if an encoder error is reported, the software cannot provide feedback.How to distinguish between new and old: The board with a battery is the newer drive board.
8 | Disabled feedback | The machine must be enabled before movement.

#### 2 Motor Built-in Error Alarms
Bits (2 bytes) | Error Status | Handling Method
---|---|---
0 | CAN Bus Error | Can be recovered using exception recovery. If recovery fails, check the communication line, repair, and then power on to enable.
1 | Short Circuit | Can be recovered using exception recovery.
2 | Invalid Setting Data | —
3 | Control Error | Can be recovered using exception recovery.
4 | CAN Communication Error | Can be recovered using exception recovery. If recovery fails, check the communication line, repair, and then power on to enable.
5 | Feedback Error | Can be recovered using exception recovery.
6 | Positive Limit Switch Activated | —
7 | Negative Limit Switch Activated | —
8 | Overcurrent | Can be recovered using exception recovery.
9 | I2t Protection | Can be recovered using exception recovery.
10 | Overtemperature | Can be recovered using exception recovery.
11 | Driver Board Overtemperature | Can be recovered using exception recovery.
12 | Overvoltage | Can be recovered using exception recovery.
13 | Undervoltage | Can be recovered using exception recovery.
14 | Command Error | —
15 | Enabled is inactive | —
<br>

[← Previous Chapter](../6.4-Cplus/README1.md) | [Next Chapter →](../../7.SuccessfulCase/README.md)
